fmod datos_primitivos is 
  pr INT .
  pr STRING .
  ***pr NAT .
  pr CONVERSION .
  

  sort EnteroUint EnteroInt Entero TipoEntero TipoEnteroUint TipoEnteroInt TipoOpToNat TipoOpto ByStr32 Tipo_to_string Byte Bytes TipoHash DeclaracionOp
       TipoClave TipoValor Map MapVacio ByStr20 BNum DeclaracionOpMapI .
  **** TipoClaveF TipoValorF DeclaracionOp Tipo_to_string Pareja Map1 Map2 Cadena .
  ***TipoClave comprende los siguientes tipos.
  ***subsort String Int ByStr32 BNum < TipoClaveF .
  --- ***Todos los tipos excepto una función (añadir más)
  --- subsort String Int ByStr32 BNum < TipoValorF .
  subsort EnteroUint EnteroInt < Entero .
  subsorts TipoEnteroUint TipoEnteroInt < TipoEntero .
  subsorts Nat Byte < Bytes .
  subsort TipoEntero < TipoClave .
  ***Puede ser cualquier tipo definido tambien por el usuario (mapas o datos alegbraicos)
  subsorts TipoEntero Map < TipoValor .
  ***subsort Int ByStr20 ByStr32 < Tipo_to_string .
  ***subsort Pareja < Map1 .
  ***subsort Map1 < Map2 .
  --- subsort Integer String ByStr32 Map ByStr20 BNum DeclaracionOp Bool Map2 < Sistema .

  ***vars n n1 : Int .
  ***vars TC TC' : TipoClaveF .
  ***vars TV TV' : TipoValorF . 
  ***vars M M' : Map1 .
  ***var s : String . 
  ***Acepta tambien cualquier bystrX 
  ops String ByStr32 ByStr BNum : -> TipoClave [ctor] .
  ops String ByStr32 ByStr BNum : -> TipoValor [ctor] .

  --- op num(_) : Nat -> Numero [ctor] .
  --- op num(-_) : Nat -> Numero [ctor].

  ***Declaración de los distintos tipos que puede ser un entero 
  ops Uint32 Uint64 Uint128 Uint256 : -> TipoEnteroUint [ctor] .
  ops Int32 Int64 Int128 Int256 : -> TipoEnteroInt [ctor] .

  ***Declaración de entero (Nombre de su tipo y el valor), los uint los trato como naturales.
  op __ : TipoEnteroUint Nat -> EnteroUint [ctor] .
  op __ : TipoEnteroInt Int -> EnteroInt [ctor] . 


  ***Declaración de operaciones de los enteros (las entradas son strings porque se usa el nombre para hacer referencia al entero).
  ***Declaración de la operacion de igualdad.
  op eq__ : String String -> DeclaracionOp [ctor comm] .
  --- op igualdad__ : Numero Numero -> Bool [ctor comm] .
  --- eq igualdad n n1 = if n == n1 
  ---               then true
  ---               else
  ---                 false 
  ---               fi .
  ***Declaración de la operación Suma.
  op add__ : String String -> DeclaracionOp [ctor comm] .
  --- op suma__ : Numero Numero -> Numero [ctor assoc comm] .
  --- eq suma num(n2) num(n3) = num( n2 + n3 ) .
  --- eq suma num(- n2) num(n3) = if n2 > n3
  ---                            then num(- sd(n2,n3))
  ---                            else
  ---                              num(sd(n3,n2))
  ---                            fi .
  --- --- eq add num(n2) num(- n3) = if n2 > n3
  --- ---                            then num(sd(n2,n3))
  --- ---                            else
  --- ---                              num(- sd(n3,n2))
  --- ---                            fi .
  --- eq suma num(- n2) num(- n3) = num(- (n2 + n3)) .
  ***Declaración de la operación resta
  op sub__ : String String -> DeclaracionOp [ctor] .
  --- op resta__ : Numero Numero -> Numero [ctor assoc] .
  --- eq resta num(n2) num(n3) = if n2 >= n3
  ---                            then num(sd(n2,n3))
  ---                            else
  ---                              num(- sd(n3,n2))
  ---                            fi .
  --- eq resta num(n2) num(- n3) = num(n2 + n3) .
  --- eq resta num(- n2) num(n3) = num(- (n2 + n3)) .
  --- eq resta num(- n2) num(- n3) = if n3 >= n2
  ---                            then num(sd(n3,n2))
  ---                            else
  ---                              num(- sd(n2,n3))
  ---                            fi .

  ***Declaración de la operación de multiplicación.
  op mul__ : String String -> DeclaracionOp [ctor comm] .
  --- op multiplicacion__ : Numero Numero -> Numero [ctor assoc comm] .
  --- eq multiplicacion num(n2) num(n3) = num(n2 * n3) .
  --- eq multiplicacion num(- n2) num(n3) = num(- (n2 * n3)) .
  --- eq multiplicacion num(- n2) num(- n3) = num(n2 * n3) .

  ***Declaración de la operación de división.
  op div__ : String String -> DeclaracionOp [ctor] .
  --- op _/_ : Nat Nat -> Nat [ctor] .
  --- ceq n2 / n3 = 0 if n3 > n2 .
  --- eq n2 / n3 = ((sd(n2,n3)) / n3) + 1 [owise] .
  --- op division__ : Numero Numero -> Numero [ctor assoc] .
  --- eq division num(n2) num(n3) = num(n2 / n3) .
  --- eq division num(- n2) num(n3) = num(- (n2 / n3)) .
  --- eq division num(n2) num(- n3) = num(- (n2 / n3)) .
  --- eq division num(- n2) num(- n3) = num(n2 / n3) .

  ***Declaración de la operación resto.
  op rem__ : String String -> DeclaracionOp [ctor] .
  --- op resto__ : Numero Numero -> Numero [ctor assoc] .
  --- op _mod_ : Nat Nat -> Nat [ctor assoc] .
  --- ceq n2 mod n3 = n2 if n3 > n2 .
  --- eq n2 mod n3 = (sd(n2,n3)) mod n3 [owise] .
  --- eq resto num(n2) num(n3) = num(n2 mod n3) .
  --- eq resto num(- n2) num(n3) = num(n2 mod n3) .
  --- eq resto num(n2) num(- n3) = num(n2 mod n3) .
  --- eq resto num(- n2) num(- n3) = num(n2 mod n3) .

  ***Declaración de la operación menor
  op lt__ : String String -> DeclaracionOp [ctor] .
  --- op menor__ : Numero Numero -> Bool [ctor] .
  --- eq menor num(n2) num(n3) = if n2 < n3 
  ---                           then true
  ---                           else
  ---                             false 
  ---                           fi .
  --- eq menor num(- n2) num(- n3) = if n2 > n3 
  ---                           then true
  ---                           else
  ---                             false 
  ---                           fi .
  --- eq menor num(- n2) num(n3) = true .
  --- eq menor num(n2) num(- n3) = false .

  ***Declaración de la operación de exponente.
  op pow__ : String String -> DeclaracionOp [ctor] .
  --- op elevar__ : Numero Nat -> Numero [ctor] .
  --- eq elevar num(n2) n3 = num(n2 ^ n3) .
  --- ceq elevar num(- n2) n3 = num(n2 ^ n3) if n3 mod 2 = 0 .
  --- eq elevar num(- n2) n3 = num(- (n2 ^ n3)) [owise] .

  ***Declaración de la operación de raíz cuadrada.
  op isqrt_ : String -> DeclaracionOp [ctor] .
  --- op raiz1__ : Nat Nat -> Nat [ctor] .
  --- ceq raiz1 n2 n3 = n3
  ---     if n3 * n3 == n2 .
  --- ceq raiz1 n2 n3 = n3 
  ---     if n3 * n3 < n2 /\ (n3 + 1) * (n3 + 1) > n2 .
  --- ceq raiz1 n2 n3 = raiz1 n2 sd(n3,1)
  ---     if n3 * n3 > n2 .
  --- op raiz_ : Nat -> Nat [ctor] .
  --- eq raiz n2 = raiz1 n2 n2 .

  ***Declaración de la operación to_nat.
  op to-nat : -> TipoOpToNat [ctor] .
  op __ : TipoOpToNat String -> DeclaracionOp [ctor] .

  ***Declaración de la operación to_(u)int32/64/128/256.
  ops to-int32 to-int64 to-int128 to-int256 to-uint32 to-uint64 to-uint128 to-uint256 : -> TipoOpto [ctor] .
  op __ : TipoOpto String -> DeclaracionOp [ctor] . 
  
  ***Los strings ya están definidos por defecto.
  ***Operaciones para los strings.
  ***La operación eq ya está definida anteriormente para los enteros y como es la misma es la que usaremos.
  ***Declaración de la operacion de concatenar dos strings.
  op concat__ : String String -> DeclaracionOp [ctor comm] .
  ***Declaración de la operación de substring (string posición_inicio longitud_substring).
  op substr___ : String String String -> DeclaracionOp [ctor] .
  op substr___ : String Nat Nat -> DeclaracionOp [ctor] .
  ***Declaración de la operacion to-string que convierte un elemento de tipo Intx/Uintx/BystrX/ByStr a string.
  op to-string_ : String -> DeclaracionOp [ctor] .
  ***Declaración de la operacion strlen (devuelve la longitud del string).
  op strlen_ : String -> DeclaracionOp [ctor] .


  ***Definición Hash
  ops a b c d e f : -> Byte [ctor] .
  op __ : Bytes Bytes -> Bytes [ctor assoc] .
  op [0x_] : Bytes -> ByStr32 [ctor] .
  ***Definición de operación eq (usaremos la definida para enteros).
  ***Definición operación sha256hash.
  op sha256hash_ : String -> DeclaracionOp [ctor] .
  ***Definición operación keccak256hash.
  op keccak256hash_ : String -> DeclaracionOp [ctor] .
  ***Definición operación ripemd160hash.
  op ripemd160hash_ : String -> DeclaracionOp [ctor] .
  ***Definición operación to_bystr (convierte un hash en un tipo ByStr).
  op to-bystr : String -> DeclaracionOp [ctor] .
  ***Definición operación substr (extrae una subcadena del hash).
  op substr___ : String String String -> DeclaracionOp [ctor] .
  op substr___ : String Nat Nat -> DeclaracionOp [ctor] .
  ***Definición operación strrev (da la vuelta a los bytes).
  op strrev_ : String -> DeclaracionOp [ctor] .
  ***Definición operación to_bystrX

  ***Definición operación to_uint(32/64/128/256)-> convierte el hash a un uint, el hash debe ser menor que 4/8/16/32 respectivamente.
  ops to-uint32 to-uint64 to-uint128 to-uint256 : -> TipoHash [ctor] .
  op __ : TipoHash String -> DeclaracionOp [ctor] .
  ***Definición operación schnorr_verify.
  op schnorr-verify___ : String String String -> DeclaracionOp [ctor] .
  ***Definición operación ecdsa_verify.
  op ecdsa-verify___ : String String String -> DeclaracionOp [ctor] .
  ***Definición operación ecdsa_recover_pk.
  op ecdsa-recover-pk___ : String String String -> DeclaracionOp [ctor] .
  ***Definición operación concat -> concatena los dos hashes ByStrx ByStrY resultado ByStr(X+Y).
  ***op concat__ : String String -> DeclaracionOp [ctor] .  Ya está definido para los strings
  ***Definición operación strlen.
  op strlen_ : String -> DeclaracionOp [ctor] .
  ***Definición operación bech32_to_bystr20.
  op bech32-to-bystr20__ : String String -> DeclaracionOp [ctor] .
  ***Definición operación bystr20_to_bech32
  op bystr20-to-bech32__ : String String -> DeclaracionOp [ctor] .
  ***Definición operación alt_bn128_G1_add
  op alt-bn128-G1-add__ : String String -> DeclaracionOp [ctor] .
  ***Definición operación alt_bn128_G1_mul
  op alt-bn128-G1-mul__ : String String -> DeclaracionOp [ctor] .
  ***Definición operación alt_bn128_pairing_product
  op alt-bn128-pairing-product_ : String -> DeclaracionOp [ctor] .

  ***Definición maps
  op Emp__ : TipoClave TipoValor -> MapVacio [ctor] .
  op Map__ : TipoClave TipoValor -> Map [ctor] .
  ***Definición operación insertar.
  ***Funcional
  op put___ : String String String -> DeclaracionOp [ctor] .
  ***In-place.
  op _[_]:=_ : String String String -> DeclaracionOpMapI [ctor] .
  ***Definición operación obtener valor.
  ***Funcional
  op get__ : String String -> DeclaracionOp [ctor] .
  ***In-place
  op _<-_[_] : String String String -> DeclaracionOpMapI [ctor] .
  ***Definición operación contener.
  ***Funcional
  op contains__ : String String -> DeclaracionOp [ctor] .
  ***In-place
  op _<-exists_[_] : String String String -> DeclaracionOpMapI [ctor] .
  ***Definición operación eliminar.
  ***Funcional
  op remove__ : String String -> DeclaracionOp [ctor] .
  ***In-place
  op delete_[_] : String String -> DeclaracionOpMapI [ctor] .
  ***Definición operación convertir a lista.
  ***Funcional
  op to-list_ : String -> DeclaracionOp [ctor] .
  ***Definición operación obtener tamaño.
  ***Funcional
  op size_ : String -> DeclaracionOp [ctor] .


  --- op (_,_) : TipoClaveF TipoValorF -> Pareja [ctor] .
  --- op mv : -> Map1 [ctor] .
  --- op __ : Map1 Map1 -> Map1 [ctor assoc comm id: mv] .
  --- op [_:_] : String Map1 -> Map2 [ctor] .
  --- op [_[_]:=_] : String String String -> DeclaracionOp [ctor] .
  --- op insertar : Map2 TipoClaveF TipoValorF -> Map2 [ctor] .
  --- eq insertar([s : mv], TC, TV) = [s : mv(TC,TV)] .
  --- eq insertar([s : M(TC,TV)M'], TC, TV') = [s : M(TC,TV')M'] .
  --- eq insertar([s : M], TC, TV) = [s : M(TC,TV)] .

  ***Definición direcciones
  op 0x_ : Bytes -> ByStr20 [ctor] .
  ***Solo tiene una operación, la de eq y usaremos la misma que la que está definida para los enteros.

  ***Definición número de bloques
  op 'BNum_' : Int -> BNum [ctor] .
  ***Definción de operaciones
  ***La operación eq ya está definida para los enteros.
  ***Definición operación blt(menor o igual).
  op blt__ : String String -> DeclaracionOp [ctor] .
  --- --- op menorIgual__ : Numero Numero -> Bool [ctor] .
  --- --- eq menorIgual num(n2) num(n2) = true .
  --- --- eq menorIgual num(- n2) num(- n2) = true .
  --- --- eq menorIgual n n1 = menor n n1 .
  ***Declaración operación badd (suma un Bnum con un UintX).
  op badd__ : String String -> DeclaracionOp [ctor] .
  --- --- op sumaBNums__ : Numero Nat -> Numero [ctor] .
  --- --- eq sumaBNums n n2 = suma n num(n2) .
  ***Declaración operación bsub(resta de dos Bnums).
  op bsub__ : String String -> DeclaracionOp [ctor] .
  --- --- op restaBNums__ : Numero Numero -> Numero [ctor] .
  --- --- eq restaBNums n n1 = resta n n1 .

endfm

fmod datos_algebraicos is 
  pr datos_primitivos .
---   pr NAT .
  sort NombreTipo Option Lista Par Natural .

---   sort Booleano ConstOp TipoList DeclaracionAlg .
---   --- subsort Bool TipoInteger < TipoList .
---   ***subsort Nat < TipoList .
  subsort TipoEntero Map < NombreTipo .
   
  ***Declaración booleano -> ya está predefinido en maude.

  ***Declaración option
  ops String ByStr32 ByStr20 BNum Bool : -> NombreTipo [ctor] .
  op Option_ : NombreTipo -> Option [ctor] .
  ***Constructoras option
  op None{_} : NombreTipo -> Option [ctor] .
  op None : -> Option [ctor] .
  op Some{_}_ : NombreTipo String -> Option [ctor] . 
  op Some_ : String -> Option [ctor] .


  ***Declaración Lista
  op List_ : NombreTipo -> Lista [ctor] .
  ***Constructoras de las listas
  op Nil{_} : NombreTipo -> Lista [ctor] .
  op Cons{_}__ : NombreTipo String String -> Lista [ctor] .

  ***Declaración Pares
  op Pair__ : NombreTipo NombreTipo -> Par [ctor] .
  ***Constructora Pair
  op Pair{__}__ : NombreTipo NombreTipo String String -> Par [ctor] .

  ***Declaración Nat
  op Nat : -> Natural [ctor] .
  ***Constructoras de Nat
  op Zero : -> Natural [ctor] .
  op Succ_ : String -> Natural [ctor] .
  ***op Succ_ : Nat -> Natural [ctor] .

endfm

fmod ADT is
  ***pr datos_primitivos .
  pr STRING .

  sort Constructora Constructoras ADTS Nombre ListaArgumentos .
  subsort Constructora < Constructoras .
  subsort String < Nombre .
  subsort Nombre < ListaArgumentos .

  op |_ : String -> Constructora [ctor] .
  ops String ByStr32 ByStr20 BNum Bool : -> ListaArgumentos [ctor] .
  op __ : ListaArgumentos ListaArgumentos -> ListaArgumentos [ctor assoc] .
  op |_of_ : String ListaArgumentos -> Constructora [ctor] . 
  op __ : Constructoras Constructoras -> Constructoras [ctor assoc] .
  op type_=_ : Nombre Constructoras -> ADTS [ctor] .

endfm

fmod param_inmutables is

  pr datos_algebraicos .
  ***pr expresiones .
  ***pr STRING .

  sort TipoParamInm ParamInm ParamInmSolo ListaParamInm ParametrosInm Restriccion OperacionBooleana .
  subsort TipoEntero Map Option Lista Par Natural < TipoParamInm .
  subsort ParamInm < ListaParamInm .
  ***subsort ExpresionBuilt < OperacionBooleana .
  
  ops ByStr20 BNum String ByStr32 Bool : -> TipoParamInm [ctor] .
  ***op _:_ : String TipoParamInm -> ParamInmSolo [ctor] .
  op _:_ : String TipoParamInm -> ParamInm [ctor] .
  ***op vacio : -> ListaParamInm [ctor] .
  ***op _ : ParamInm -> ListaParamInm [ctor] .
  op _,_ : ListaParamInm ListaParamInm -> ListaParamInm [ctor assoc comm] . 
  ***op <> : -> ParametrosInm [ctor] .
  op <_> : ListaParamInm -> ParametrosInm [ctor] .
  ***op [_with_=>] : ParametrosInm OperacionBooleana -> Restriccion [ctor] .

endfm

fmod campos_modificables is
  pr param_inmutables .

  sort ValorCampo Campo_mod ListaCamposMod .
  subsort Entero MapVacio ByStr32 ByStr20 Option Lista Par Natural String Bool < ValorCampo .
  subsort Campo_mod < ListaCamposMod .

  op field_=_ : ParamInm ValorCampo -> Campo_mod [ctor] .
  op __ : ListaCamposMod ListaCamposMod -> ListaCamposMod [ctor assoc] . 

endfm 

***Librerías por defecto de scilla

fmod BoolUtils is 
  pr STRING .
  sort DeclaracionOpBools .

  var b : Bool . 

  ops andb__ orb__ : String String -> DeclaracionOpBools [ctor] .
  ops negb_ boolToString_ : String -> DeclaracionOpBools [ctor] .
  --- op pasarString : Bool -> String .
  --- eq pasarString(true) = "True" .
  --- eq pasarString(false) = "False" .
endfm

fmod IntUtils is
  pr STRING .
  pr datos_primitivos .

  sort DeclaracionOpInts .

  ops _-eq__ _-neq__ _-lt__ _-le__ _-gt__ _-ge__ : TipoEntero String String -> DeclaracionOpInts [ctor] .

endfm

fmod ListUtils is
  pr STRING .

endfm

fmod expresiones is
  pr param_inmutables .
  pr BoolUtils .
  pr IntUtils .
  sort TipoDato Expresion Operacion ListaEntradas EventoMsg Opcion ListaOpciones Argumento ListaArgumentos 
       ExpresionBuilt Expresiones ExpresionFuncion Expresion@ OperacionBuilt TipoOpcion ExpresionMatch .
  subsorts Entero String Bool ExpresionBuilt Map ByStr32 ByStr20 BNum Option Lista Par Natural Expresion < TipoDato .
  subsorts ExpresionFuncion ExpresionBuilt EventoMsg Expresion@ ExpresionMatch < Expresion .
  subsort ParamInm < ListaEntradas .
  subsort Opcion < ListaOpciones .
  subsort Expresion DeclaracionOpBools DeclaracionOpInts < Operacion .
  subsort Argumento < ListaArgumentos .
  subsort DeclaracionOp < OperacionBuilt .
  subsorts Option Bool Par < TipoOpcion .
  ***subsort Expresion ExpresionBuilt < Expresiones .
  ***Entrada: nombre de la variable y el valor
  op let_=_ : String TipoDato -> Expresion [ctor]  .

  op let_=_in_ : String TipoDato Operacion -> Expresion [ctor] .

  ***Declaracion expresion de evento o mensaje
  ***op _:_ : String String -> Entrada [ctor] .
  op _:_ : String String -> ParamInm [ctor] .
  op _;_ : ListaEntradas ListaEntradas -> ListaEntradas [ctor assoc] .
  op {_} : ListaEntradas -> EventoMsg [ctor] .

  ***Declaracion de funcion
  op fun(_) =>_ : ParamInm Operacion -> ExpresionFuncion [ctor] .

  ***op __ : String String -> Expresion [ctor] .

  op tfun'_=>_ : String Operacion -> Expresion [ctor] .

  op @__ : String String -> Expresion@ [ctor] .  ***No es exactamente string (hay que cambiarlo).

  op [_] : String -> Argumento [ctor] .
  op __ : ListaArgumentos ListaArgumentos -> ListaArgumentos [ctor] .
  ***op builtin__ : OperacionBuilt ListaArgumentos -> ExpresionBuilt [ctor] . ***No es exactamente string (hay que cambiarlo).
  op builtin_ : OperacionBuilt -> ExpresionBuilt [ctor] .

  op |_=>_ : TipoOpcion String -> Opcion [ctor] .  ***La segunda entrada no sería un string sino un statement.
  op __ : ListaOpciones ListaOpciones -> ListaOpciones [ctor] .
  op match_with_end : String ListaOpciones -> ExpresionMatch [ctor] .

endfm

fmod declaraciones is
  pr expresiones .

  sort Declaracion Valor ListaDeclaraciones DeclaracionFuncion .
  subsorts Entero String DeclaracionFuncion EventoMsg ExpresionBuilt Option Lista Par Natural DeclaracionOpBools DeclaracionOpInts < Valor .
  subsorts Declaracion ExpresionMatch < ListaDeclaraciones .
  subsort DeclaracionFuncion < Declaracion .

  
  op _<-_ : String String -> Declaracion [ctor] .
  op _:=_ : String String -> Declaracion [ctor] .
  op _<-&BLOCKNUMBER : String -> Declaracion [ctor] .
  op _=_ : String Valor -> Declaracion [ctor] .
  op __ : String ListaArgumentos -> DeclaracionFuncion [ctor] .
  op forall__ : String String -> Declaracion [ctor] .
  op accept : -> Declaracion [ctor] .
  op send_ : String -> Declaracion [ctor] .
  op event_ : String -> Declaracion [ctor] .

  op _;_ : ListaDeclaraciones ListaDeclaraciones -> ListaDeclaraciones [ctor assoc] .

endfm


fmod transiciones is
  pr declaraciones .
  ***pr param_inmutables .

  sort Transicion .
  
  op transition_(_)_end : String ListaParamInm ListaDeclaraciones -> Transicion [ctor] .

endfm

fmod procedimientos is
  pr declaraciones .
  ***pr param_inmutables .

  sort Procedimiento .
  
  op procedure_(_)_end : String ListaParamInm ListaDeclaraciones -> Procedimiento [ctor] .

endfm

fmod libreria is
  ***pr STRING .
  pr expresiones .
  
  sort DeclaracionLibreria ListaParamLibreria Libreria .
  ***Dentro de las librerias puede haber las expresiones: let, let ... in..., funciones, tfun, @, ADT
  subsort Expresion < ListaParamLibreria .

  op library_ : String -> DeclaracionLibreria [ctor] .
  op __ : ListaParamLibreria ListaParamLibreria -> ListaParamLibreria [ctor assoc] .
  op __ : DeclaracionLibreria ListaParamLibreria -> Libreria [ctor] .

endfm

fmod Contrato is
  ***pr NAT .
  ***pr STRING .
  ***pr param_inmutables .
  pr campos_modificables .
  pr transiciones .
  pr procedimientos .
  pr libreria .

  sort Version LibreriaImp Importacion NombreContrato ListaTP Contrato .
  subsort Transicion Procedimiento < ListaTP .
  ***Este subsort solo es para probar

  ***Estructura contrato: Version Importacion Librerias NombreContrato ParametrosInm ListaCamposMod ListaTransicionesyprocedimientos.
  ops BoolUtils IntUtils ListUtils NatUtils PairUtils : -> LibreriaImp [ctor] .
  op scilla-version_ : Nat -> Version [ctor] .
  op iv : -> Importacion [ctor] .
  op import_ : LibreriaImp -> Importacion [ctor] .
  op import_as_ : LibreriaImp String -> Importacion [ctor] .
  op contract_ : String -> NombreContrato [ctor] .
  op __ : ListaTP ListaTP -> ListaTP [ctor assoc] .
  op _______ : Version Importacion Libreria NombreContrato ParametrosInm ListaCamposMod ListaTP -> Contrato [ctor] .
  ***op __ : Version String -> Contrato [ctor] .

endfm

fmod TEST is
  pr Contrato .

  op init : -> Contrato .

  eq init = scilla-version 1 import BoolUtils library "HelloWorld" (let "one_msg" = (fun ("msg" : String) => (let "nil_msg" = (Nil {String}) in (Cons {String} "msg" "nil_msg"))))
            let "not_owner_code" = (Int32 -1) in (orb "s" "s") let "set_hello_code" = (Uint32 2)
            contract "HelloWorld" < ("owner" : ByStr20) , ("w" : Uint32) > (field ("welcome_msg" : String) = "") (field ("welcome_msg" : Uint32) = (Uint32 0))
            transition "setHello" ("msg" : String) "is_owner" = builtin (eq "owner" "_sender") ; send "is_owner" end 
            procedure "setHello" ("msg" : String) "is_owner" = builtin (eq "owner" "_sender") ; send "is_owner" end .
  ***import "Bool" library "HelloWorld" let "not_owner_code" = (Uint32 1) let "set_hello_code" = (Uint32 2)
     ***      contract "HelloWorld" < "owner" : ByStr20 > field ("welcome_msg" : String) = "" transition "setHello" ("msg" : String) 
        ***  "is_owner" = builtin (eq "owner" "_sender") ; "r" <- "velcome_msg" end .
    ***eq init = scilla-version -1 iv .


endfm

mod reglas is
  pr Contrato .

  var v : Version .
  var i : Importacion .
  var l : Libreria .
  var n : NombreContrato .
  var pi : ParametrosInm .
  var lm : ListaCamposMod .
  var ltp : ListaTP .
  var dl : DeclaracionLibreria .
  var lpl lpl' : ListaParamLibreria .


  vars in in' : Int .
  vars t t' : TipoEntero .
  vars s s' : String .
  var b : Bool .

  ***Reglas para enteros
  crl[uint] : let s = (Uint32 in) => let s = (Uint32 in) 
              if in >= 0 /\ in < 10 .
---   ***rl[uint] : [s = tu num(na)]sys => [s = tu num(na)] .
---   crl[igual] : let s = t n sys let s1 = t n1 sys1 eq s s1 => let s = t n sys let s1 = t n1 sys1 bo
---                if bo := igualdad n n1 .
---   --- crl[suma] : [s = t n]sys[s1 = t n1]sys1 add(s s1)sys2 => [s = t n]sys[s1 = t n1]sys1 n2 sys2
---   ---              if n2 := suma n n1 .
---   --- rl[resta] : [s = t n]sys[s1 = t n1]sys1 sub s s1 => [s = t n]sys[s1 = t n1]sys1 resta n n1 .
---   --- rl[multi] : [s = t n]sys[s1 = t n1]sys1 mul s s1 => [s = t n]sys[s1 = t n1]sys1 multiplicacion n n1 .

endm

--- fmod sist is
---   --- pr BoolUtils .
---   ***pr datos_algebraicos .
---   ***pr ADT .
---   ***pr campos_modificables .
---   --- pr IntUtils .
---   --- pr NatUtils .
---   pr transiciones .
---   pr procedimientos .
---   --- ***pr declaraciones .
---   --- pr campos_modificables .
---   --- pr transiciones .
---   --- pr procedimientos .

---   sort Sistema .

---   ***subsort ByStr32 Map ByStr20 BNum DeclaracionOp Bool Map2 DeclaracionOpBools Booleano DeclaracionOpInts
---           ***DeclaracionOpNats Expresiones EventoMsg Transicion ParametrosInm Restriccion Campo_mod Procedimiento < Sistema .
---   ***subsort ParametrosInm < Sistema . 
---   ***subsort EnteroUint DeclaracionOp DeclaracionOpMapI ByStr32 Map BNum Option Lista Par Natural ParametrosInm Expresion 
---      ***   ListaDeclaraciones Transicion Procedimiento < Sistema .

---     subsort EnteroInt < Sistema .
 
---   op sisv : -> Sistema [ctor] .
---   op __ : Sistema Sistema -> Sistema [ctor assoc id: sisv] .

--- endfm


--- fmod TEST is
---   pr sist .

---   op init : -> Sistema .

---   ***eq init = tfun ' "A" => let "s" = Uint32 num(3) .
---   ***eq init = fun ("h" : "a") => let "s" = Uint32 num(3) .
---   ***eq init = builtin "eq" ["s1"] ["s2"] .
---   ***eq init = match "Prueba" with | "true" => "hola" | "false" => "p" end .
---   ***eq init = let "s" = Uint32 -3 procedure "hola"("h" : BNum) accept ; send "h" ; event "f" ; event "h" ; ("h" <- "h") ; accept end .
---   ***eq init = @ "hola" "Hola" .
---   ***eq init = [< "owner" : ByStr20 , "max" : Uint128 > with builtin "eq" ["s1"] ["s2"] =>] let "s" = Uint128 num(8) .
---   ***eq init = field "hola" : Uint128 = num(- 2) .
---   ***Prueba que funcionan los enteros
---   ***eq init = type "hola" = | "hola" (| "Hola" of String) | "Adios" (| "hola" of "hola") | "a" .
---   ***eq init = < ("hola" : BNum) , ("a" : Uint32) , ("g" : String) > .
---   ***Probar los campos modificables.
---   ***eq init = field "s" : Option ByStr20 = None {ByStr20} .
---   ***Probar las expresiones.
---   ***eq init = let "s" = true .
---   ***eq init = let "s" = Zero in let "s" = (Uint32 0) .
---   ***eq init = {("s" : "g") ; ("f" : "h") ; ("g" : "j")} .
---   ***eq init = fun ("s" : BNum) => let "s" = (Uint32 0) .
---   ***eq init = builtin (eq "s1" "s2") .
---   ***eq init = match "s" with | Some "v" => "hola" | None => "Adios" end .
---   ***Probar las declaraciones 
---   ***eq init = forall "s" "s1" ; match "s" with | true => "s" end ; ("s" = None {ByStr20}) ; accept ; send "s" ; event "s" .
---   ***Probar los mapas
---   ***eq init = (builtin delete "s"["g"]) .
---   ***Probar las transiciones.
---  *** eq init = transition "hola" (("hola" : BNum) , ("s" : Uint32)) accept ; ("s" := "d") ; send "e" ; ("s" <- "f") end .
---   ***Probar los procedimientos.
---   ***eq init = procedure "hola" (("hola" : BNum) , ("s" : Uint32)) accept ; ("s" := "d") ; send "e" ; ("s" <- "f") end .
---   ***Probar los enteros
---   eq init = Uint32 -1 .

--- endfm




--- fmod NatUtils is
---   pr datos_algebraicos .
---   pr NAT .

---   sort DeclaracionOpNats . 

---   var na : Nat .
---   var nat : Natural .

---   op nat-prev_ : String -> DeclaracionOpNats [ctor] .

---   op previo_ : Natural -> Option [ctor] .
---   eq previo Zero = None .
---   eq previo Succ na = Some sd(na, 1) .

--- endfm














--- mod REGLAS is 
---   pr sist .
---   pr BOOL .
---   --- pr datos_primitivos .
---   --- pr datos_algebraicos .
---  --- pr BoolUtils .
---   var tipo : TipoOpEnteros .
---   vars s s1 s2 s3 s4 : String .
---   vars n n1 n2 : Numero .
---   vars sys sys1 sys2 : Sistema .
---   vars t t1 : TipoInteger .
---   vars na na' : Nat .
---   var i : Integer .
---   var tu : TipoIntegerUint .
---   var bo : Bool .
---   var m : Map1 .
---   vars b b' : Bool .
---   var ti : TipoIntegerInt .
---   vars ca ca' : Cadena .
  
---   ***Reglas para enteros
---   ***rl[uint] : [s = tu num(na)]sys => [s = tu num(na)] .
---   crl[igual] : let s = t n sys let s1 = t n1 sys1 eq s s1 => let s = t n sys let s1 = t n1 sys1 bo
---                if bo := igualdad n n1 .
---   --- crl[suma] : [s = t n]sys[s1 = t n1]sys1 add(s s1)sys2 => [s = t n]sys[s1 = t n1]sys1 n2 sys2
---   ---              if n2 := suma n n1 .
---   --- rl[resta] : [s = t n]sys[s1 = t n1]sys1 sub s s1 => [s = t n]sys[s1 = t n1]sys1 resta n n1 .
---   --- rl[multi] : [s = t n]sys[s1 = t n1]sys1 mul s s1 => [s = t n]sys[s1 = t n1]sys1 multiplicacion n n1 .

---   ***Reglas para strings
---   crl[igual_string] : let s = s2 sys let s1 = s3 sys1 eq s s1 => let s = s2 sys let s1 = s3 sys1 bo
---                       if bo := s2 == s3 .
---   rl[concatenar] : let s = s2 sys let s1 = s3 sys1 concat s s1 => let s = s2 sys let s1 = s3 sys1 s2 + s3 .
---   --- rl[subString] : [s = s1]sys substr s na na' => [s = s1]sys substr(s1, na, na') .
---   ***rl[to_string] : [s = s1]sys to-string s => [s = s1]sys .
---   ***rl[longitudStr] : [s = s1]sys strlen s => [s = s1]sys length(s1) .

---   ***Reglas para Hash
  
---   ***Reglas para mapas
---   --- rl[crear_map] : [s = t n]sys[s1 = t n1]sys1[s4 :Map Numero Numero]sys2 [s4[s] := s1] => 
---   ---                     [s = t n]sys[s1 = t n1]sys1[s4 : mv]sys2 [s4[s] := s1] .
---   --- rl[insert_map] : [s = t n]sys[s1 = t n1]sys1[s4 : m]sys2 [s4[s] := s1] => 
---   ---                     [s = t n]sys[s1 = t n1]sys1[s4 :Map Numero Numero]sys2 insertar([s4 : m], n, n1) .

---   ***Reglas para direcciones
---   rl[igual_direcciones] : [s =0x s1]sys[s2 =0x s3]sys1 eq s s2 => [s =0x s1]sys[s2 =0x s3]sys1 s1 == s3 .

---   ***Reglas para BNums
---   rl[igual_Bnum] : [s =BNum n]sys[s1 =BNum n1]sys1 eq s s1 => [s =BNum n]sys[s1 =BNum n1]sys1 igualdad n n1 .
---   rl[menorIgual_Bnum] : [s =BNum n]sys[s1 =BNum n1]sys1 blt s s1 => [s =BNum n]sys[s1 =BNum n1]sys1 menorIgual n n1 .
---   ***rl[suma_Bnum] : [s =BNum n]sys[s1 = t num(na)]sys1 badd s s1 => [s =BNum n]sys[s1 = t num(na)]sys1 sumaBNums n na .
---   rl[resta_Bnum] : [s =BNum n]sys[s1 =BNum n1]sys1 bsub s s1 => [s =BNum n]sys[s1 =BNum n1]sys1 restaBNums n n1 .

---   ***Reglas librería BoolUtils
---   --- crl[and] : (s = b)sys(s1 = b')sys1 andb s s1 => (s = b)sys(s1 = b')sys1 bo
---   ---           if bo := b and b' .
---   --- crl[or] : (s = b)sys(s1 = b')sys1 orb s s1 => (s = b)sys(s1 = b') bo
---   ---           if bo := b or b' .
---   --- crl[or] : (s = b)sys negb s => (s = b)sys bo
---   ---           if bo := not b .
---   --- rl[bool-to-string] : (s = b)sys boolToString s => (s = b)sys pasarString(b) .

---   ***Reglas librería IntUtils
---   --- rl[eq] : [s = t n]sys[s1 = t n1]sys1 t -eq s s1 => [s = t n]sys[s1 = t n1]sys1 igualdad n n1 .
---   --- rl[lt] : [s = t n]sys[s1 = t n1]sys1 t -lt s s1 => [s = t n]sys[s1 = t n1]sys1 menor n n1 .
---   --- rl[neq] : [s = t n]sys[s1 = t n1]sys1 t -neq s s1 => [s = t n]sys[s1 = t n1]sys1 distinto n n1 .
---   --- rl[le] : [s = t n]sys[s1 = t n1]sys1 t -le s s1 => [s = t n]sys[s1 = t n1]sys1 menorIgual n n1 .
---   --- rl[gt] : [s = t n]sys[s1 = t n1]sys1 t -gt s s1 => [s = t n]sys[s1 = t n1]sys1 mayor n n1 .
---   --- rl[ge] : [s = t n]sys[s1 = t n1]sys1 t -ge s s1 => [s = t n]sys[s1 = t n1]sys1 mayorIgual n n1 .
  
--- endm
  
