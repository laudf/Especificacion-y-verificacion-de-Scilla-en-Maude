***Gramática con una sintaxis parecida a Scilla
fmod GRAMMAR is
  pr STRING .
  pr INT .
  sorts @Token@ @Bubble@ @NeTokenList@ .
  sort @DeclaracionOp@ @Prog@ @TipoEntero@ @Num@ @Entero@ @TipoOpto@ @BNum@ @NombreTipo@ @Option@ @Lista@ @Par@ @Natural@ @Contrato@ .
  ***subsort @DeclaracionOp@ @Entero@ String @BNum@ @Option@ @Lista@ @Par@ @Natural@ @ParametrosInm@ @Campo_mod@ @Version@ < @Prog@ .

  ***DATOS PRMITIVOS

  ***ENTEROS
  ***Declaración de entero (Nombre de su tipo y el valor), los uint los trato como naturales.
  ops Uint32 Uint64 Uint128 Uint256 Int32 Int64 Int128 Int256 : -> @TipoEntero@ [ctor] .
  op __ : @TipoEntero@ Int -> @Entero@ [ctor prec 11] .
  ***op __ : @TipoEnteroInt@ Num -> @EnteroInt@ [ctor] . 

  ***Declaración de la operacion de igualdad.
  op eq__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor comm prec 13] .
  ***Declaración de la operación Suma.
  op add__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor comm prec 13] .
  ***Declaración de la operación resta
  op sub__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 14] .
  ***Declaración de la operación de multiplicación.
  op mul__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor comm prec 14] .
  ***Declaración de la operación de división.
  op div__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 14] .
  ***Declaración de la operación resto.
  op rem__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 14] .
  ***Declaración de la operación menor
  op lt__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 13] .
  ***Declaración de la operación de exponente.
  op pow__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 14] .
  ***Declaración de la operación de raíz cuadrada.
  op isqrt_ : @Token@ -> @DeclaracionOp@ [ctor prec 14] .
  ***Declaración de la operación to_nat.
  op to-nat_ : @Token@ -> @DeclaracionOp@ [ctor prec 14] .
  ***Declaración de la operación to_(u)int32/64/128/256.
  ops to-int32 to-int64 to-int128 to-int256 to-uint32 to-uint64 to-uint128 to-uint256 : -> @TipoOpto@ [ctor] .
  op __ : @TipoOpto@ @Token@ -> @DeclaracionOp@ [ctor prec 14] . 

  ***STRINGS
  ***La operación eq ya está definida anteriormente para los enteros y como es la misma es la que usaremos.
  ***Declaración de la operacion de concatenar dos strings.
  op concat__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor comm prec 14] .
  ***Declaración de la operación de substring (string posición_inicio longitud_substring).
  op substr___ : @Token@ @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 14] .
  ***op substr___ : @Token@ Nat Nat -> @DeclaracionOp@ [ctor] .
  ***Declaración de la operacion to-string que convierte un elemento de tipo Intx/Uintx/BystrX/ByStr a string.
  op to-string_ : @Token@ -> @DeclaracionOp@ [ctor prec 14] .
  ***Declaración de la operacion strlen (devuelve la longitud del string).
  op strlen_ : @Token@ -> @DeclaracionOp@ [ctor prec 14] .

  ***HASHES
  op sha256hash_ : @Token@ -> @DeclaracionOp@ [ctor prec 14] .
  op schnorr-verify___ : @Token@ @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 14] . 
  op ecdsa-verify___ : @Token@ @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 14] .

  ***MAPAS
  sort @TipoClave@ @TipoValor@ @MapVacio@ @Map@ @DeclaracionOpMapI@ @posicion@ @ListaPosiciones@ .
  ***subsort @TipoEntero@ < @NombreTipo@ .
  subsort @NombreTipo@ < @TipoClave@ .
  subsort @NombreTipo@ @Par@  < @TipoValor@ .
  subsort @posicion@ < @ListaPosiciones@ .

  op Emp__ : @TipoClave@ @TipoValor@ -> @MapVacio@ [ctor prec 15] .
  op Emp__ : @TipoClave@ @Bubble@ -> @MapVacio@ [ctor prec 15] .
  op Map__ : @TipoClave@ @TipoValor@ -> @Map@ [ctor prec 15] .
  op Map__ : @TipoClave@ @Bubble@ -> @Map@ [ctor prec 15] .
  op [_] : @Token@ -> @posicion@ [ctor prec 18] .
  op __ : @ListaPosiciones@ @ListaPosiciones@ -> @ListaPosiciones@ [ctor assoc prec 19] .
  ***Definición operación insertar.
---   ***Funcional
  op put___ : @Token@ @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 19] .
  ***In-place.
  op __:=_ : @Token@ @ListaPosiciones@ @Token@ -> @DeclaracionOpMapI@ [ctor prec 19] .
  ***Definición operación obtener valor.
  ***Funcional
  op get__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 13] .
  ***In-place
  op _<-__ : @Token@ @Token@ @ListaPosiciones@ -> @DeclaracionOpMapI@ [ctor prec 19] .
  ***Definición operación contener.
  ***Funcional
  op contains__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 13] .
  ***In-place
  op _<-exists__ : @Token@ @Token@ @ListaPosiciones@ -> @DeclaracionOpMapI@ [ctor prec 19] .
  ***Definición operación eliminar.
  ***Funcional
  op remove__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 13] .
  ***In-place
  op delete__ : @Token@ @ListaPosiciones@ -> @DeclaracionOpMapI@ [ctor prec 19] .

  ***BNUM
  ***Definición número de bloques
  op BNum_ : Int -> @BNum@ [ctor] .
  ***Definción de operaciones
  ***La operación eq ya está definida para los enteros.
  ***Definición operación blt(menor o igual).
  op blt__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 14] .
  ***Declaración operación badd (suma un Bnum con un UintX).
  op badd__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 14] .
  ***Declaración operación bsub(resta de dos Bnums).
  op bsub__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 14] .

  ***Falta por meter los mapas, hashes y direcciones.

  ***DATOS ALGEBRAICOS
  ***Declaración option
  subsort @TipoEntero@ @Map@ < @NombreTipo@ .
  ops String ByStr32 ByStr33 ByStr20 BNum Bool Message Error ByStr ByStr64 Unit : -> @NombreTipo@ [ctor] .  ***Falta meter los enteros
  op Option_ : @NombreTipo@ -> @Option@ [ctor prec 13] .  ***A lo mejor hay que hacer un tipo declaracionOption para diferenciarlo.
  ***Constructoras option
  op None{_} : @NombreTipo@ -> @Option@ [ctor prec 13] .
  op None : -> @Option@ [ctor] .
  op Some{_}_ : @NombreTipo@ @Token@ -> @Option@ [ctor prec 13] . 
  op Some_ : @Token@ -> @Option@ [ctor prec 13] .

  ***Declaración Lista
  op List_ : @NombreTipo@ -> @Lista@ [ctor prec 13] .
  ***Constructoras de las listas
  op Nil{_} : @NombreTipo@ -> @Lista@ [ctor prec 13] .
  op Cons{_}__ : @NombreTipo@ @Token@ @Token@ -> @Lista@ [ctor prec 13] .

  ***Declaración Pares
  op Pair__ : @NombreTipo@ @NombreTipo@ -> @Par@ [ctor prec 13] .
  ***Constructora Pair
  op Pair{__}__ : @NombreTipo@ @NombreTipo@ @Token@ @Token@ -> @Par@ [ctor prec 13] .

  ***Declaración Nat
  op Nat : -> @Natural@ [ctor] .
  ***Constructoras de Nat
  op Zero : -> @Natural@ [ctor] .
  op Succ_ : @Token@ -> @Natural@ [ctor prec 13] .

  ***PARÁMETROS INMUTABLES
  sort @TipoParamInm@ @ParamInm@ @ListaParamInm@ @ParametrosInm@ .
  subsort @NombreTipo@ @Map@ @Option@ < @TipoParamInm@ .
  subsort @ParamInm@ < @ListaParamInm@ .

  ***ops ByStr20 BNum String ByStr32 Bool Message : -> @TipoParamInm@ [ctor] .
  ***op _:_ : String TipoParamInm -> ParamInmSolo [ctor] .
  op _:_ : @Token@ @TipoParamInm@ -> @ParamInm@ [ctor prec 15] .
  op _:_ : @Token@ @Bubble@ -> @ParamInm@ [ctor prec 15] .
  ***op vacio : -> ListaParamInm [ctor] .
  ***op _ : ParamInm -> ListaParamInm [ctor] .
  op lpv : -> @ListaParamInm@ [ctor] .
  op (_,_) : @ListaParamInm@ @ListaParamInm@ -> @ListaParamInm@ [ctor assoc prec 17 id: lpv] . 
  ***op <> : -> ParametrosInm [ctor] .
  ***op _ : @ListaParamInm@ -> @ParametrosInm@ [ctor] .
  --- ***op [_with_=>] : ParametrosInm OperacionBooleana -> Restriccion [ctor] .

  ***CAMPOS MODIFICABLES
  sort @ValorCampo@ @Campo_mod@ @ListaCamposMod@ .
  ***subsort @Entero@ @Option@ @Lista@ @Par@ @Natural@ String Bool < @ValorCampo@ .
  subsort @Entero@ @Option@ @Lista@ @Par@ @Natural@ @MapVacio@ Bool @Expresion@ String < @ValorCampo@ .
  ***subsort Bool < @ValorCampo@ .
  subsort @Campo_mod@ < @ListaCamposMod@ .
  op cv : -> @Campo_mod@ [ctor] .
  op field_=_ : @ParamInm@ @ValorCampo@ -> @Campo_mod@ [ctor prec 19] .
  op field_=_ : @ParamInm@ @ExpresionAplicarF@ -> @Campo_mod@ [ctor prec 19] .
  op __ : @ListaCamposMod@ @ListaCamposMod@ -> @ListaCamposMod@ [ctor assoc prec 20] .

  ***EXPRESIONES
  sort @TipoDato@ @Expresion@ @Operacion@ @ExpresionFuncion@ @ListaArgumentos@ @OperacionBuilt@ @ListaExpresiones@ @TipoOpcion@ @Opcion@
       @ListaOpciones@ @Expresiones@ @ExpresionMatch@ @ListaArg@ @ExpresionLet@ @ExpresionAplicarF@ .
  --- ***Entero String Bool ExpresionBuilt Map ByStr32 ByStr20 BNum Option Lista Par Natural Expresion
  subsort @Entero@ String @BNum@ @Option@ @Lista@ @Par@ @Natural@ @ExpresionFuncion@ @Expresion@ @ExpresionMatch@ @MapVacio@ @ExpresionAplicarF@ @DeclaracionOpInt@ < @TipoDato@ .
  --- --- subsort Expresion DeclaracionOpBools DeclaracionOpInts < Operacion .
  subsort @Expresion@ @Lista@ @ExpresionFuncion@ @ExpresionMatch@ @Excepcion@ @Par@ < @Operacion@ .
  subsort @TipoEntero@ @NombreTipo@ @Par@ < @ListaArgumentos@ .
  subsort @DeclaracionOp@ @DeclaracionOpBools@  < @OperacionBuilt@ .
  subsort @ExpresionLet@ @ADTS@ < @ListaExpresiones@ . 
 *** subsort @Declaracion@ @ExpresionMatch@ < @Expresiones@ .
  subsort @ListaDeclaraciones@ @Entero@ @Expresion@ < @Expresiones@ .
  subsort @Option@ @Par@ Bool < @TipoOpcion@ .
  subsort @Opcion@ < @ListaOpciones@ .
  subsort @Token@ < @ListaArg@ .
  ***subsort @Bubble@ < @ExpresionAplicarF@ .

  op let_=_ : @Token@ @TipoDato@ -> @ExpresionLet@ [ctor prec 20]  .
  op let_=_in_ : @Token@ @TipoDato@ @Operacion@ -> @Expresion@ [ctor prec 20] .
  --- ***Falta añadir los mensajes
  op fun(_)=>_ : @ParamInm@ @Operacion@ -> @ExpresionFuncion@ [ctor prec 20] .
  op `(_`) :  @Bubble@ -> @ExpresionAplicarF@ [ctor prec 19] .
  op @___ : @Token@ @TipoParamInm@ @TipoParamInm@ -> @Expresion@ [ctor prec 20] .  
  op builtin_ : @OperacionBuilt@ -> @Expresion@ [ctor prec 19] .
  op ev : -> @Expresiones@ [ctor] .
  op |_=>_ : @TipoOpcion@ @Expresiones@ -> @Opcion@ [ctor prec 20] . 
  op |_=>_ : @Bubble@ @Expresiones@ -> @Opcion@ [ctor prec 20] .
  op |_=>_ : @TipoOpcion@ @Bubble@ -> @Opcion@ [ctor prec 20] .
  op ov : -> @ListaOpciones@ [ctor] .
  op __ : @ListaOpciones@ @ListaOpciones@ -> @ListaOpciones@ [ctor assoc prec 21] .
  op match_with_end : @Token@ @ListaOpciones@ -> @ExpresionMatch@ [ctor prec 21] .
  op __ : @ListaExpresiones@ @ListaExpresiones@ -> @ListaExpresiones@ [ctor assoc prec 22] .

  ***DECLARACIONES
  sort @Declaracion@ @Valor@ @ListaDeclaraciones@ .
  subsorts @Entero@ String @Option@ @Lista@ @Par@ @Natural@ @Evento@ @Expresion@ @Mensaje@ Bool @DeclaracionOpBools@ @ExpresionMatch@ @ExpresionAplicarF@ @DeclaracionOpInt@ < @Valor@ .
  subsort @Declaracion@ @ExpresionMatch@ @DeclaracionOpMapI@ @Expresion@ @Error@ @ExpresionAplicarF@ < @ListaDeclaraciones@ .

  op _<-_ : @Token@ @Token@  -> @Declaracion@ [ctor prec 19] .
  op _:=_ : @Token@ @Token@ -> @Declaracion@ [ctor prec 19] .
  op _<-&BLOCKNUMBER : @Token@ -> @Declaracion@ [ctor prec 19] .
  op _=_ : @Token@ @Valor@ -> @Declaracion@ [ctor prec 19] .
  op forall__ : @Token@ @Token@ -> @Declaracion@ [ctor prec 19] .
  op accept : -> @Declaracion@ [ctor] .
  op send_ : @Token@ -> @Declaracion@ [ctor prec 19] .
  op event_ : @Token@ -> @Declaracion@ [ctor prec 19] .

  op _;_ : @ListaDeclaraciones@ @ListaDeclaraciones@ -> @ListaDeclaraciones@ [ctor assoc prec 20] .

  ***TRANSICIONES Y PROCEDIMIENTOS
  sort @Transicion@ @ListaTransiciones@ @Procedimiento@ .
  subsort @Transicion@ @Procedimiento@ < @ListaTransiciones@ .

  op procedure_(_)_end : @Token@ @ListaParamInm@ @ListaDeclaraciones@ -> @Procedimiento@ [ctor prec 23] .
  op transition_(_)_end : @Token@ @ListaParamInm@ @ListaDeclaraciones@ -> @Transicion@ [ctor prec 23] .
  op tv : -> @ListaTransiciones@ [ctor] .
  op __ : @ListaTransiciones@ @ListaTransiciones@ -> @ListaTransiciones@ [ctor assoc prec 24] .

  ***COMUNICACIONES
  sort @NombreEvento@ @ListaCamposEvento@ @Evento@ @CampoEvento@ @TagMensaje@ @EnvioMensaje@ @CantidadMensaje@ @Mensaje@ @NombreExcepcion@ @Excepcion@ .
  subsort @CampoEvento@ < @ListaCamposEvento@ .
  ***Eventos
  op -eventname:_ : String -> @NombreEvento@ [ctor prec 12] .
  op _:_ : @Token@ @Token@ -> @CampoEvento@ [ctor prec 12] .
  op lcv : -> @ListaCamposEvento@ [ctor] .
  op _;_ : @ListaCamposEvento@ @ListaCamposEvento@ -> @ListaCamposEvento@ [ctor assoc prec 13] .
  op {_;_} : @NombreEvento@ @ListaCamposEvento@ -> @Evento@ [ctor prec 14] .
  ***Mensajes
  op -tag:_ : String -> @TagMensaje@ [ctor prec 12] .
  op -recipient:_ : @Token@ -> @EnvioMensaje@ [ctor prec 12] .
  op -amount:_ : @Entero@ -> @CantidadMensaje@ [ctor prec 12] .
  op -amount:_ : @Token@ -> @CantidadMensaje@ [ctor prec 12] .
  op {_;_;_;_} : @TagMensaje@ @EnvioMensaje@ @CantidadMensaje@ @ListaCamposEvento@ -> @Mensaje@ [ctor prec 14] .

  op -exception:_ : String -> @NombreExcepcion@ [ctor prec 12] .
  op {_;_} : @NombreExcepcion@ @ListaCamposEvento@ -> @Excepcion@ [ctor prec 14] .

  ***LIBRERIA BOOLUTILS
  sort @DeclaracionOpBools@ .

  ops andb__ orb__ : @Token@ @Token@ -> @DeclaracionOpBools@ [ctor prec 14] .
  ops negb_ bool-to-string_ : @Token@ -> @DeclaracionOpBools@ [ctor prec 14] .
  ops _.andb__ _.orb__ : @Token@ @Token@ @Token@ -> @DeclaracionOpBools@ [ctor prec 14] .
  ops _.negb_ _.bool-to-string_ : @Token@ @Token@ -> @DeclaracionOpBools@ [ctor prec 14] .

  sort @DeclaracionOpInt@ .
  op uint128-le__ : @Token@ @Token@ -> @DeclaracionOpInt@ [ctor prec 14] .


  ***ADTS
  sort @ADTS@ @Constructora@ @Constructoras@ .
  subsort @Constructora@ < @Constructoras@ .
  op |_ : @Token@ -> @Constructora@ [ctor prec 15] .
  op __ : @Constructoras@ @Constructoras@ -> @Constructoras@ [ctor assoc prec 16] .
  op type_=_ : @Token@ @Constructoras@ -> @ADTS@ [ctor prec 17] .

  ***ERRORES
  sort @Error@ .
  op throw : -> @Error@ [ctor] .
  op throw_ : @Token@ -> @Error@ [ctor prec 19] .

  sort @NombreLibreria@ @NombreContrato@ @Libreria@ @LibImportar@ @Importacion@ @ListaImportar@ .
  subsort @LibImportar@ < @ListaImportar@ .

  op library_ : @Token@ -> @NombreLibreria@ [ctor] .
  op contract_ : @Token@ -> @NombreContrato@ [ctor] .
  ops BoolUtils IntUtils PairUtils ListUtils : -> @LibImportar@ [ctor] .
  op iv : -> @Importacion@ [ctor] .
  op __ : @ListaImportar@ @ListaImportar@ -> @ListaImportar@ [ctor assoc] .
  op import_ : @ListaImportar@ -> @Importacion@ [ctor] .
  op import_as_ : @LibImportar@ @Token@ -> @Importacion@ [ctor] .

  op __ : @NombreLibreria@ @ListaExpresiones@ -> @Libreria@ [ctor] .

  op scilla-version_______ : Nat @Importacion@ @Libreria@ @NombreContrato@ @ListaParamInm@ @ListaCamposMod@ @ListaTransiciones@ -> @Contrato@ [ctor] .

endfm

***Modulo donde se definen las funciones para realizar el parseado.
fmod PARSING is
 pr META-LEVEL .
 pr CONVERSION .
 pr PREPARSE .

 vars T T1 T1' T2 T2' T3 T3' T4 T4' T5 T5' T6 T6' T7 T7' : Term .
 var  TL TL' TL1 : TermList .
 var  Ct : Constant .
 var  S : String .
 var  F : Float .
 vars Q Q' : Qid .
 var  I : Int .
 vars St St' St'' St''' : String .
 vars  N N' : Nat .
 vars QIL QIL1 : QidList .

 op parse : Term -> Term .

 ceq parse('scilla-version_______[T1, T2, T3, T4, T5, T6, T7]) = 'Contrato_______[T1', T2', T3', T4', T5', T6', T7']
  if T1' := parse(T1) /\
     T2' := parse(T2) /\
     T3' := parse(T3) /\
     T4' := parse(T4) /\
     T5' := parse(T5) /\
     T6' := parse(T6) /\
     T7' := parse(T7)  .

 ceq parse('token[T]) = upTerm(F)
  if Q := downQid(T) /\
     S := string(Q) /\
     F := float(S) .
 ceq parse('token[T]) = upTerm(F)
  if Q := downQid(T) /\
     S := string(Q) /\
     rat(S, 10) :: Nat /\
     F := float(S + ".0") .
 ceq parse('token[T]) = upTerm(St)
  if Q := downQid(T) /\
     S := string(Q) /\
     N := find(S, "\"", 0) /\
     St := substr(S, N + 1, sd(length(S), 2)) /\
     St :: String [print St]  .
 ceq parse('token[T]) = T
  if Q := downQid(T) /\
     S := string(Q) /\
     not (float(S) :: Float) /\
     not (rat(S, 10) :: Nat)  .


 eq parse('bubble[TL]) = TL .



 ***ENTEROS
 ceq parse('eq__[T1, T2]) = '_==._[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('add__[T1, T2]) = '_+._[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('sub__[T1, T2]) = '_-_[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('mul__[T1, T2]) = '_*_[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('div__[T1, T2]) = '_/_[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('rem__[T1, T2]) = '_rem_[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('lt__[T1, T2]) = '_<._[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('pow__[T1, T2]) = '_^_[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('isqrt_[T1]) = 'raiz_[T1']
  if T1' := parse(T1) .
 ceq parse('to-nat_[T1]) = 'to-nat_[T1']
  if T1' := parse(T1) .

 ***STRINGS
 ceq parse('concat__[T1, T2]) = '_++_[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('substr___[T1, T2, T3]) = 'substr___[T1', T2', T3']
  if T1' := parse(T1) /\
     T2' := parse(T2) /\
     T3' := parse(T3) .
 ceq parse('to-string_[T1]) = 'to-string_[T1']
  if T1' := parse(T1) .
 ceq parse('strlen_[T1]) = 'length_[T1']
  if T1' := parse(T1) .

 ***HASHES
 ceq parse('sha256hash_[T1]) = 'sha256hash_[T1']
  if T1' := parse(T1) .
 ceq parse('schnorr-verify___[T1, T2, T3]) = 'schnorr-verify___[T1', T2', T3']
  if T1' := parse(T1) /\
     T2' := parse(T2) /\
     T3' := parse(T3) .
 ceq parse('ecdsa-verify___[T1, T2, T3]) = 'ecdsa-verify___[T1', T2', T3']
  if T1' := parse(T1) /\
     T2' := parse(T2) /\
     T3' := parse(T3) .

 ***MAPS
 ceq parse('Emp__[T1, T2]) = 'Emp__[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('Map__[T1, T2]) = 'Map__[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('`[_`][T1]) = 'posicion_[T1']
  if T1' := parse(T1) .
 ceq parse('put___[T1, T2, T3]) = 'put___[T1', T2', T3']
  if T1' := parse(T1) /\
     T2' := parse(T2) /\
     T3' := parse(T3) .
 ceq parse('__:=_[T1, T2, T3]) = 'insertar___[T1', T2', T3']
  if T1' := parse(T1) /\
     T2' := parseL(T2) /\
     T3' := parse(T3) .
 ceq parse('_<-__[T1, T2, T3]) = 'obtener___[T1', T2', T3']
  if T1' := parse(T1) /\
     T2' := parse(T2) /\
     T3' := parseL(T3) .
 ceq parse('get__[T1, T2]) = 'get__[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('contains__[T1, T2]) = 'contains__[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('_<-exists__[T1, T2, T3]) = 'existe___[T1', T2', T3']
  if T1' := parse(T1) /\
     T2' := parse(T2) /\
     T3' := parseL(T3) .
 ceq parse('remove__[T1, T2]) = 'remove__[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('delete__[T1, T2]) = 'delete__[T1', T2']
  if T1' := parse(T1) /\
     T2' := parseL(T2) .

 ***BNUM
 ceq parse('blt__[T1, T2]) = '_<._[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('badd__[T1, T2]) = '_+._[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('bsub__[T1, T2]) = '_-_[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .

 ***DATOS ALGEBRAICOS
 ***Option
 ceq parse('None`{_`}[T1]) = 'None`{_`}[T1']
  if T1' := parse(T1) .
 ceq parse('Some`{_`}_[T1, T2]) = 'Some__[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('Some_[T1]) = 'Some_[T1']
  if T1' := parse(T1) .
 ceq parse('Option_[T1]) = 'Option_[T1']
  if T1' := parse(T1) .
 ***Listas
 ceq parse('List_[T1]) = 'List_[T1']
  if T1' := parse(T1) .
 ceq parse('Nil`{_`}[T1]) = 'Nil`{_`}[T1']
  if T1' := parse(T1) .
 ceq parse('Cons`{_`}__[T1, T2, T3]) = 'Cons___[T1', T2', T3']
  if T1' := parse(T1) /\
     T2' := parse(T2) /\
     T3' := parse(T3) .
 ***Pares
 ceq parse('Pair`{__`}__[T1, T2, T3, T4]) = 'Pair____[T1', T2', T3', T4']
  if T1' := parse(T1) /\
     T2' := parse(T2) /\
     T3' := parse(T3) /\ 
     T4' := parse(T4) .
 ceq parse('Pair__[T1, T2]) = 'Pair__[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ***Naturales
 ceq parse('Succ_[T1]) = 'Sucesor_[T1']
  if T1' := parse(T1) .

 ***PARÁMETROS INMUTABLES
 ceq parse('_:_[T1, T2]) = '_:_[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 eq parse('_`,_[TL]) = '_`,_[parseL(TL)]  .

 ***CAMPOS MODIFICABLES
 ceq parse('field_=_[T1, T2]) = 'campo_=_[T1', T2'] 
  if T1'  := parse(T1) /\
     T2'  := parse(T2) .
 eq parse('__[TL]) = '__[parseL(TL)] .

 ***EXPRESIONES
 ceq parse('let_=_[T1, T2]) = 'let__[T1', T2'] 
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('let_=_in_[T1, T2, T3]) = 'let__in_[T1', T2', T3']
  if T1' := parse(T1) /\
     T2' := parse(T2) /\
     T3' := parse(T3) .
 ceq parse('fun`(_`)=>_[T1, T2]) = 'funcion__[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('_=__[T1, T2, T3]) = 'aplicarFuncion___[T1', T2', T3']
  if T1' := parse(T1) /\
     T2' := parse(T2) /\
     T3' := parse(T3) .

 ceq parse('`(_`)['bubble[TL]]) = 'aplicarF_[TL']
  if TL' := parseL(TL) .
 

 ceq parse('@___[T1, T2, T3]) = '@___[T1', T2', T3']
  if T1' := parse(T1) /\
     T2' := parse(T2) /\
     T3' := parse(T3) .
 ceq parse('builtin_[T1]) = 'builtin_[T1']
  if T1' := parse(T1) .
 ceq parse('|_=>_[T1, T2]) = 'opcionMatch__[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('match_with_end[T1, T2]) = 'match__[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .

 ***DECLARACIONES
 ceq parse('_<-_[T1, T2]) = 'guardar__[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('_:=_[T1, T2]) = 'actualizar__[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('_<-&BLOCKNUMBER[T1]) = '_<-&BLOCKNUMBER[T1']
  if T1' := parse(T1) .
 ceq parse('_=_[T1, T2]) = '_=_[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('forall__[T1, T2]) = 'forall__[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('send_[T1]) = 'enviar_[T1']
  if T1' := parse(T1) .
 ceq parse('event_[T1]) = 'evento_[T1']
  if T1' := parse(T1) .
 eq parse('_;_[('_:_[T1, T2], TL)]) = '_;_[parse('_:_[T1, T2]), parseL(TL)] .
 eq parse('_;_[TL]) = '__[parseL(TL)] .


 ***COMUNICACIONES 
 ceq parse('`{_;_`}[T1, T2]) = '`{_;_`}[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('-recipient:_[T1]) = 'dirEnvio_[T1']
  if T1' := parse(T1) .
 ceq parse('-amount:_[T1]) = 'cantidadEnvio_[T1']
  if T1' := parse(T1) .
 ceq parse('`{_;_;_;_`}[T1, T2, T3, T4]) = '`{_;_;_;_`}[T1', T2', T3', T4']
  if T1' := parse(T1) /\
     T2' := parse(T2) /\
     T3' := parse(T3) /\
     T4' := parse(T4) .

 ***TRANSICIONES Y PROCEDIMIENTOS
 ceq parse('procedure_`(_`)_end[T1, T2, T3]) = 'procedimiento___end[T1', T2', T3']
  if T1' := parse(T1) /\
     T2' := parse(T2) /\
     T3' := parse(T3) .
 ceq parse('transition_`(_`)_end[T1, T2, T3]) = 'transicion___end[T1', T2', T3']
  if T1' := parse(T1) /\
     T2' := parse(T2) /\
     T3' := parse(T3) .

***BOOLUTILS
 ceq parse('andb__[T1, T2]) = '_and_[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('_.andb__[T1, T2, T3]) = '_and.__[T1', T2', T3']
  if T1' := parse(T1) /\
     T2' := parse(T2) /\
     T3' := parse(T3) .
 ceq parse('orb__[T1, T2]) = '_or_[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('_.orb__[T1, T2, T3]) = '_or.__[T1', T2', T3']
  if T1' := parse(T1) /\
     T2' := parse(T2) /\
     T3' := parse(T3) .
 ceq parse('negb_[T1]) = 'negb_[T1']
  if T1' := parse(T1) .
 ceq parse('_.negb_[T1, T2]) = 'negb.__[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('bool-to-string_[T1]) = 'bool-to-string_[T1']
  if T1' := parse(T1) .
ceq parse('_.bool-to-string_[T1, T2]) = 'bool-to-string.__[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .

 ***INTUTILS
 ceq parse('uint128-le__[T1, T2]) = '_<._[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .

 ***ADTS
 ceq parse('|_[T1]) = '|_[T1']
  if T1' := parse(T1) .
 ceq parse('type_=_[T1, T2]) = 'tipo__[T1', T2']
  if T1' := parse(T1) /\
     T2' := parseL(T2) .

 ***Errores
 ceq parse('throw_[T1]) = 'throw_[T1']
  if T1' := parse(T1) .

 ceq parse('library_[T1]) = 'NombreLibreria_[T1']
  if T1' := parse(T1) .
 ceq parse('contract_[T1]) = 'NombreContrato_[T1']
  if T1' := parse(T1) .
 ceq parse('import_[T1]) = 'import_[T1']
  if T1' := parse(T1) .


 ceq parse(T) = Q'
    if St := string(T) /\
    N := find(St, "@", 0) /\ 
    St' := substr(St, 0, N) /\
    St'' := substr(St, N + 1, length(St)) /\
    N' := find(St'', "@", 0) /\
    St''' := substr(St'', 0, N') /\
    Q' := qid(St' + St''') .
   

 
 var QL : QidList .
 eq parse(T) = T [owise] .

 op parseL : TermList -> TermList .
 eq parseL(empty) = empty .

 eq parseL((T, TL)) = parse(T), parseL(TL) .

 op downQid : Term -> [Qid] [memo] .
 eq downQid(Ct)
    = qid(substr(string(getName(Ct)), 1, length(string(getName(Ct))))) .

 op downQidType : Term -> [Qid] [memo] .
 eq downQidType(Ct)
    = qid(substr(string(getName(Ct)), 0, length(string(getName(Ct))))) .

 op downQidList : TermList -> QidList [ctor] .
 eq downQidList(T)
    = downQid(T) .
 eq downQidList(T TL)
    = downQid(T) downQidList(TL) [print TL] .
 
***Operación para obtener los parámetros inmutables.
 op obtenerEntradas : Term -> Term [ctor] .
 eq obtenerEntradas('__['Entrada`[_=>_`][T, T1], TL]) = '`{_:_`}[T, T1] .
 eq obtenerEntradas('`[_`,_`][T, T1]) = obtenerEntradas(T)  .

***Operación para obtener los parámetros de entrada de las transiciones.
 op obtenerEntradasTransicion : Term -> Term [ctor] .
 eq obtenerEntradasTransicion('__['Entrada`[_=>_`][T, T1], TL]) = '`{_:_`}[T, T1] .
 eq obtenerEntradasTransicion('`[_`,_`][T, '`[_`,_`,_`][T1, T2, T3]]) = obtenerEntradasTransicion(T3)  .

***Comprueba si hay más parámetros inmutables sin valor.
 op hayEntradas : Term -> Bool [ctor] .
 eq hayEntradas('__['Entrada`[_=>_`][T, T1], TL]) = true .
 eq hayEntradas(T) = false [owise] .
 eq hayEntradas('`[_`,_`][T, T1]) = hayEntradas(T)  .

***Comprueba si hay más entrdas sin valor en las transiciones.
 op hayEntradasTransicion : Term -> Bool [ctor] .
 eq hayEntradasTransicion('__['Entrada`[_=>_`][T, T1], TL]) = true .
 eq hayEntradasTransicion(T) = false [owise] .
 eq hayEntradasTransicion('`[_`,_`][T, '`[_`,_`,_`][T1, T2, T3]]) = hayEntradasTransicion(T3)  .

***Modifica el sistema para solo tener las dos memorias.
 op modificarTermino : Term -> Term [ctor] .
 eq modificarTermino('`[_`,_`,_`][T, T1, T2]) = '`[_`,_`][T1, T2] .

***Obtiene la memoria de las variables globales.
 op obtenerTermino : Term -> Term [ctor] .
 eq obtenerTermino('`[_`,_`][T, T1]) = T .

***Obtiene la segunda memoria.
 op obtenerTerminoTransiciones : Term -> Term [ctor] .
 eq obtenerTerminoTransiciones('`[_`,_`][T, T1]) = T1 .

***Sustituye la primera memoria por otra (esto es para cargar los valores)
 op sustituirTermino : Term Term -> Term [ctor] .
 eq sustituirTermino('`[_`,_`][T, T1], '`{_`,_`}[T2, T3]) = '`[_`,_`][T2, T1]  .
 eq sustituirTermino('`[_`,_`][T, T1], '`[_`,_`][T2, T3]) = '`[_`,_`][T2, T1]  .

***Sustituye la segunda memoria por otra (esto es para cargar los valores, en este caso de las transiciones)
 op sustituirTerminoTransicion : Term Term -> Term [ctor] .
 eq sustituirTerminoTransicion('`[_`,_`][T, T1], '`{_`,_`}[T2, T3]) = '`[_`,_`][T, T2]  .

***Obtiene los nombres de todas las transiciones.
 op obtenerNombresTransiciones : TermList -> QidList [ctor] .
 eq obtenerNombresTransiciones(empty) = nil .
 eq obtenerNombresTransiciones(('`[_`,_`,_`][T, T1, T2], TL)) = downQid(T) obtenerNombresTransiciones(TL) .
 eq obtenerNombresTransiciones('`[_`,_`][T, '__[TL]]) = obtenerNombresTransiciones(TL) .
 eq obtenerNombresTransiciones('`[_`,_`][T, T1]) = obtenerNombresTransiciones(T1) .

***Devuelve un String a partir de una lista de Qids.
 op devolverString : QidList -> String [ctor] .
 eq devolverString(Q) = string(Q) .
 eq devolverString(Q QL) = string(Q) + ", " + devolverString(QL) .

 op tenerDev : TermList -> Bool [ctor] .
 eq tenerDev(('`[_=>_`][''enviar.Qid, TL], TL')) = true .
 eq tenerDev(('`[_=>_`][''evento.Qid, TL], TL')) = true .
 eq tenerDev(('`[_=>_`][''evento.Qid, TL], TL')) = true .
 eq tenerDev((T, TL')) = tenerDev(TL') .
 eq tenerDev(TL) = false [owise] .

***Obtiene solo los eventos y los mensajes del resultado de una transición.
 op obtenerResultado : TermList -> TermList [ctor] .
 eq obtenerResultado(empty) = empty .
 ceq obtenerResultado((TL1, '`[_=>_`][''enviar.Qid, TL], TL')) = '`[_=>_`][''enviar.Qid, TL], obtenerResultado(TL')
    if not(tenerDev(TL1)) .
 ceq obtenerResultado((TL1, '`[_=>_`][''evento.Qid, TL], TL')) = '`[_=>_`][''evento.Qid, TL], obtenerResultado(TL') 
    if not(tenerDev(TL1)) .
 eq obtenerResultado('`[_`,_`,_`][T, '__[TL], T2]) = obtenerResultado(TL) .
 eq obtenerResultado('`[_`,_`,_`][T, 'mv.Memoria, T2]) = empty .
 eq obtenerResultado('`[_`,_`,_`][T, '`[_=>_`][''evento.Qid, TL], T2]) = '`[_=>_`][''evento.Qid, TL] .
 eq obtenerResultado('`[_`,_`,_`][T, '`[_=>_`][''enviar.Qid, TL], T2]) = '`[_=>_`][''enviar.Qid, TL] .
 eq obtenerResultado('`[_`,_`,_`][T, '`[_=>_`][''throw.Qid, TL], T2]) = '`[_=>_`][''throw.Qid, TL] .
 eq obtenerResultado('`[_`,_`][T, T1]) = obtenerResultado(T1) .

***Obtiene el nombre de los campos inmutables (usado para posteriormente solo coger esos campos al mostrar los resultados)
 op obtenerCampos : QidList -> QidList [ctor] .
 eq obtenerCampos(nil) = nil .
 eq obtenerCampos('field Q QIL) = Q obtenerCampos(QIL) .
 eq obtenerCampos(Q QIL) = obtenerCampos(QIL) .

 var C : Constant .
 var Q'' : Qid .

***Obtener tanto el nombre como el valor y el tipo de los campos modificables
 op obtenerCamposMod : TermList QidList Nat -> TermList [ctor] .
 eq obtenerCamposMod(TL, nil, N) = empty .
 ceq obtenerCamposMod((TL1, '`[_=>_|_`][C, T, T1], TL'), Q QIL, N) = '`[_=>_|_`][C, T, T1], obtenerCamposMod((TL1, TL'), QIL, N)
   if Q' := getName(C) /\
      S := string(Q') /\
      St := substr(S, 1, length(S)) /\
      Q'' := qid(St) /\
      Q'' == Q  .
 ceq obtenerCamposMod('__[TL], QIL, N) = '__[obtenerCamposMod(TL, QIL, N)] 
    if N > 1 .
 eq obtenerCamposMod('__[TL], QIL, N) = obtenerCamposMod(TL, QIL, N) [owise] .

***Obtener el tamaño de una lista de Qids.
 op obtenerTamaño : QidList -> Nat [ctor] .
 eq obtenerTamaño(nil) = 0 .
 eq obtenerTamaño(Q QIL) = 1 + obtenerTamaño(QIL) . 

 vars St1 St2 : String .
***Quita las ' de un string dado para mostrar mejor la salida.
 op quitarComillas : String -> String [ctor] .
 ceq quitarComillas(St) = St1 + " " + quitarComillas(St2)
      if N := find(St, "['", 0) /\
         St1 := substr(St, 0, N + 1) /\
         St2 := substr(St, N + 2, length(St)) .

 eq quitarComillas(St) = St [owise] .
endfm

***Modulo que define la gramática interna que va a usar el programa
fmod PROGRAMA is
  pr QID .
  pr QID-LIST .
  pr INT .
  sort DeclaracionOp TipoEntero Entero Contrato Igualdad TipoOpto .
  subsort DeclaracionOp Entero < Expresion .

  ***DATOS PRMITIVOS

  ***ENTEROS
  ***Declaración de entero (Nombre de su tipo y el valor), los uint los trato como naturales.
  ops Uint32 Uint64 Uint128 Uint256 Int32 Int64 Int128 Int256 : -> TipoEntero [ctor] .
  op __ : TipoEntero Int -> Entero [ctor prec 11] .

  ***Declaración de la operacion de igualdad.
  op _==._ : Qid Qid -> DeclaracionOp [ctor comm prec 13] .
  op _==._ : Int Int -> DeclaracionOp [ctor comm prec 13] .
  ***Declaración de la operación Suma.
  op _+._ : Qid Qid -> DeclaracionOp [ctor comm prec 13] .
  ***Declaración de la operación resta
  op _-_ : Qid Qid -> DeclaracionOp [ctor prec 14] .
  ***Declaración de la operación de multiplicación.
  op _*_ : Qid Qid -> DeclaracionOp [ctor comm prec 14] .
  ***Declaración de la operación de división.
  op _/_ : Qid Qid -> DeclaracionOp [ctor prec 14] .
  ***Declaración de la operación resto.
  op _%_ : Qid Qid -> DeclaracionOp [ctor prec 14] .
  ***Declaración de la operación menor
  op _<._ : Qid Qid -> DeclaracionOp [ctor prec 13] .
  ***Declaración de la operación de exponente.
  op _^_ : Qid Qid -> DeclaracionOp [ctor prec 14] .
  ***Declaración de la operación de raíz cuadrada.
  op raiz_ : Qid -> DeclaracionOp [ctor prec 14] .

  op cv : -> Contrato [ctor] .
  op __ : Contrato Contrato -> Contrato [ctor id: cv] .
  ops to-int32 to-int64 to-int128 to-int256 to-uint32 to-uint64 to-uint128 to-uint256 : -> TipoOpto [ctor] .
  op __ : TipoOpto Qid -> DeclaracionOp [ctor prec 14] . 

  ***STRINGS
  ***La operación eq ya está definida anteriormente para los enteros y como es la misma es la que usaremos.
  ***Declaración de la operacion de concatenar dos strings.
  op _++_ : Qid Qid -> DeclaracionOp [ctor comm prec 14] .
  ***Declaración de la operación de substring (string posición_inicio longitud_substring).
  op substr___ : Qid Qid Qid -> DeclaracionOp [ctor prec 14] .
  ***Declaración de la operacion to-string que convierte un elemento de tipo Intx/Uintx/BystrX/ByStr a string.
  op to-string_ : Qid -> DeclaracionOp [ctor prec 14] .
  ***Declaración de la operacion strlen (devuelve la longitud del string).
  op length_ : Qid -> DeclaracionOp [ctor prec 14] .

  ***HASHES
  sort Byte ByStr20 .
  subsort Byte < ByStr20 .
  op a b c d e f 1 2 3 4 5 6 7 8 9 : -> Byte [ctor] .
  op __ : ByStr20 ByStr20 -> ByStr20 [ctor] .
  op sha256hash_ : Qid -> DeclaracionOp [ctor prec 14] .
  op schnorr-verify___ : Qid Qid Qid -> DeclaracionOp [ctor prec 14] . 
  op ecdsa-verify___ : Qid Qid Qid -> DeclaracionOp [ctor prec 14] .

  ***MAPAS
  sort TipoClave TipoValor MapVacio Map DeclaracionOpMapI posicion ListaPosiciones Clave .
  subsort NombreTipo < TipoClave .
  subsort NombreTipo Par < TipoValor .
  subsort posicion < ListaPosiciones .
  subsort ParEjecucion Bool < Clave .

  op Emp__ : TipoClave TipoValor -> MapVacio [ctor prec 15] .
  op Emp__ : TipoClave QidList -> MapVacio [ctor prec 15] .
  op Map__ : TipoClave TipoValor -> Map [ctor prec 15] .
  op Map__ : TipoClave QidList -> Map [ctor prec 15] .
  op posicion_ : Qid -> posicion [ctor prec 18] .
  op __ : ListaPosiciones ListaPosiciones -> ListaPosiciones [ctor assoc prec 19] .
  ***Definición operación insertar.
  ***Funcional
  op put___ : Qid Qid Qid -> DeclaracionOp [ctor prec 19] .
  ***In-place.
  op insertar___ : Qid ListaPosiciones Qid -> DeclaracionOpMapI [ctor prec 19] .
  ***Definición operación obtener valor.
  ***Funcional
  op get__ : Qid Qid -> DeclaracionOp [ctor prec 13] .
  ***In-place
  op obtener___ : Qid Qid ListaPosiciones -> DeclaracionOpMapI [ctor prec 19] .
  ***Definición operación contener.
  ***Funcional
  op contains__ : Qid Qid -> DeclaracionOp [ctor prec 13] .
  ***In-place
  op existe___ : Qid Qid ListaPosiciones -> DeclaracionOpMapI [ctor prec 19] .
  ***Definición operación eliminar.
  ***Funcional
  op remove__ : Qid Qid -> DeclaracionOp [ctor prec 13] .
  ***In-place
  op delete__ : Qid ListaPosiciones -> DeclaracionOpMapI [ctor prec 19] .

  ***BNUM
  sort BNum .
  ***Definición número de bloques
  op BNum_ : Int -> BNum [ctor] .

  ***DATOS ALGEBRAICOS
  ***Declaración option
  sort NombreTipo Option Lista Par Natural ParEjecucion .
  subsort TipoEntero Map Option < NombreTipo .
  ops String ByStr32 ByStr33 ByStr20 BNum Bool Message Error ByStr ByStr64 Unit : -> NombreTipo [ctor] .  
  op Option_ : NombreTipo -> Option [ctor prec 13] . 
  ***Constructoras option
  op None{_} : NombreTipo -> Option [ctor prec 13] .
  op None : -> Option [ctor] .
  op Some__ : NombreTipo Qid -> Option [ctor prec 13] . 
  op Some_ : Qid -> Option [ctor prec 13] .
  op Some_ : Nat -> Option [ctor] .
  op Some_ : Clave -> Option [ctor] .
  ***Declaración Lista
  op List_ : NombreTipo -> Lista [ctor prec 13] .
  ***Constructoras de las listas
  op Nil{_} : NombreTipo -> Lista [ctor prec 13] .
  op Cons___ : NombreTipo Qid Qid -> Lista [ctor prec 13] .

  ***Declaración Pares
  op Pair__ : NombreTipo NombreTipo -> Par [ctor prec 13] .
  op Pair__ : Bool Option -> Par [ctor prec 13] .
  ***Constructora Pair
  op Pair____ : NombreTipo NombreTipo Qid Qid -> Par [ctor prec 13] .
  op [_,_] : String Int -> ParEjecucion [ctor] .
  op [_,_] : String String -> ParEjecucion [ctor] .

  ***Declaración Nat
  op Nat : -> Natural [ctor] .
  ***Constructoras de Nat
  op Zero : -> Natural [ctor] .
  op Sucesor_ : Qid -> Natural [ctor prec 13] .

  ***PARÁMETROS INMUTABLES
  sort TipoParamInm ParamInm ListaParamInm ParametrosInm .
  subsort NombreTipo Map Option Lista Par < TipoParamInm .
  subsort ParamInm < ListaParamInm .

  op _:_ : Qid TipoParamInm -> ParamInm [ctor prec 15] .
  op _:_ : Qid QidList -> ParamInm [ctor prec 15] .
  op _:_ : Qid Qid -> ParamInm [ctor prec 15] .
  op _:_ : Qid String -> ParamInm [ctor prec 15] .
  op lpv : -> ListaParamInm [ctor] .
  op (_,_) : ListaParamInm ListaParamInm -> ListaParamInm [ctor assoc prec 17] . 

  
  ***CAMPOS MODIFICABLES
  sort ValorCampo Campo_mod ListaCamposMod .
  subsort Entero Option Lista Par Natural MapVacio Bool Expresion String  < ValorCampo .
  subsort Campo_mod < ListaCamposMod .
  op cv : -> Campo_mod [ctor] .
  op campo_=_ : ParamInm ValorCampo -> Campo_mod [ctor prec 19] .
  op campo_=_ : ParamInm ExpresionAplicarF -> Campo_mod [ctor prec 19] .
  op lcmv : -> ListaCamposMod [ctor] .
  op __ : ListaCamposMod ListaCamposMod -> ListaCamposMod [ctor assoc prec 20 id: lcmv] .

  ***EXPRESIONES
  sort TipoDato Expresion Operacion ExpresionFuncion ListaArgumentos OperacionBuilt ListaExpresiones TipoOpcion Opcion
       ListaOpciones Expresiones ExpresionMatch ListaArg ExpresionLet ExpresionAplicarF ExpresionArr .
  subsort Entero String BNum Option Lista Par Natural ExpresionFuncion Expresion ExpresionMatch MapVacio ExpresionAplicarF Bool ExpresionArr < TipoDato .
  subsort Expresion Lista ExpresionFuncion ExpresionMatch Excepcion Par Option DeclaracionOpBools ExpresionAplicarF < Operacion .
  subsort TipoEntero NombreTipo Par < ListaArgumentos .
  subsort DeclaracionOp DeclaracionOpBools  < OperacionBuilt .
  subsort ExpresionLet ADTS < ListaExpresiones . 
  subsort ListaDeclaraciones Entero Option < Expresiones .
  subsort Option Par Bool < TipoOpcion .
  subsort Opcion < ListaOpciones .
  subsort Qid < ListaArg .

  op let__ : Qid TipoDato -> ExpresionLet [ctor prec 20]  .
  op let__in_ : Qid TipoDato Operacion -> Expresion [ctor prec 20] .
  op funcion__ : ParamInm Operacion -> ExpresionFuncion [ctor prec 20] .
  op aplicarF_ :  QidList -> ExpresionAplicarF [ctor prec 19] .
  op lav : -> ListaArgumentos [ctor] .
  op @___ : Qid TipoParamInm TipoParamInm -> ExpresionArr [ctor prec 20] .  
  op builtin_ : OperacionBuilt -> Expresion [ctor prec 19] .

  op ev : -> Expresiones [ctor] .
  op opcionMatch__ : TipoOpcion Expresiones -> Opcion [ctor prec 20] . 
  op opcionMatch__ : Qid Expresiones -> Opcion [ctor prec 20] .
  op opcionMatch__ : TipoOpcion QidList -> Opcion [ctor prec 20] .
  op opcionMatch__ : TipoOpcion Bool -> Opcion [ctor prec 20] .
  op opcionMatch__ : Qid Bool -> Opcion [ctor prec 20] .
  op ov : -> ListaOpciones [ctor] .
  op __ : ListaOpciones ListaOpciones -> ListaOpciones [ctor assoc prec 21] .
  op match__ : Qid ListaOpciones -> ExpresionMatch [ctor prec 21] .
  op lev : -> ListaExpresiones [ctor] .
  op __ : ListaExpresiones ListaExpresiones -> ListaExpresiones [ctor assoc prec 22 id: lev] .

  ***DECLARACIONES
  sort Declaracion Valor ListaDeclaraciones .
  subsorts Entero String Option Lista Par Natural Evento Expresion Mensaje Bool DeclaracionOpBools ExpresionMatch ExpresionAplicarF ExpresionArr < Valor .
  subsort Declaracion ExpresionMatch DeclaracionOpMapI Expresion Error ExpresionAplicarF < ListaDeclaraciones .

  op guardar__ : Qid Qid  -> Declaracion [ctor prec 19] .
  op actualizar__ : Qid Qid -> Declaracion [ctor prec 19] .
  op _<-&BLOCKNUMBER : Qid -> Declaracion [ctor prec 19] .
  op _=_ : Qid Valor -> Declaracion [ctor prec 19] .
  op forall__ : Qid Qid -> Declaracion [ctor prec 19] .
  op accept : -> Declaracion [ctor] .
  op enviar_ : Qid -> Declaracion [ctor prec 19] .
  op evento_ : Qid -> Declaracion [ctor prec 19] .
  op ldv : -> ListaDeclaraciones [ctor] .
  op __ : ListaDeclaraciones ListaDeclaraciones -> ListaDeclaraciones [ctor assoc prec 20 id: ldv] .

  ***TRANSICIONES Y PROCEDIMIENTOS
  sort Transicion ListaTransiciones Procedimiento .
  subsort Transicion Procedimiento < ListaTransiciones .

  op procedimiento___end : Qid ListaParamInm ListaDeclaraciones -> Procedimiento [ctor prec 23] .
  op transicion___end : Qid ListaParamInm ListaDeclaraciones -> Transicion [ctor prec 23] .
  op ltv : -> ListaTransiciones [ctor] .
  op __ : ListaTransiciones ListaTransiciones -> ListaTransiciones [ctor assoc prec 24 id: ltv] .

  ***COMUNICACIONES
  sort NombreEvento ListaCamposEvento Evento CampoEvento TagMensaje EnvioMensaje CantidadMensaje Mensaje NombreExcepcion Excepcion .
  subsort ParamInm < ListaCamposEvento .
  ***Eventos
  op -eventname:_ : String -> NombreEvento [ctor prec 12] .
  op lcv : -> ListaCamposEvento [ctor] .
  op _;_ : ListaCamposEvento ListaCamposEvento -> ListaCamposEvento [ctor assoc prec 13] .
  op {_;_} : NombreEvento ListaCamposEvento -> Evento [ctor prec 14] .
  ***Mensajes
  op -tag:_ : String -> TagMensaje [ctor prec 12] .
  op dirEnvio_ : Qid -> EnvioMensaje [ctor prec 12] .
  op cantidadEnvio_ : Entero -> CantidadMensaje [ctor prec 12] .
  op cantidadEnvio_ : Qid -> CantidadMensaje [ctor prec 12] .
  op {_;_;_;_} : TagMensaje EnvioMensaje CantidadMensaje ListaCamposEvento -> Mensaje [ctor prec 14] .

  op -exception:_ : String -> NombreExcepcion [ctor prec 12] .
  op {_;_} : NombreExcepcion ListaCamposEvento -> Excepcion [ctor prec 14] .

  ***LIBRERIA BOOLUTILS
  sort DeclaracionOpBools .

  ops _and_ _or_ : Qid Qid -> DeclaracionOpBools [ctor prec 14] .
  ops negb_ bool-to-string_ : Qid -> DeclaracionOpBools [ctor prec 14] .
  ops _and.__ _or.__ : Qid Qid Qid -> DeclaracionOpBools [ctor prec 14] .
  ops negb.__ bool-to-string.__ : Qid Qid -> DeclaracionOpBools [ctor prec 14] .



  ***ADTS
  sort ADTS Constructora Constructoras .
  subsort Constructora < Constructoras .
  op |_ : Qid -> Constructora [ctor prec 15] .
  op consv : -> Constructoras [ctor] .
  op __ : Constructoras Constructoras -> Constructoras [ctor assoc prec 16 id: consv] .
  op tipo__ : Qid Constructoras -> ADTS [ctor prec 17] .

  ***ERRORES
  sort Error .
  op throw : -> Error [ctor] .
  op throw_ : Qid -> Error [ctor prec 19] .

  

  sort NombreLibreria NombreContrato Libreria LibImportar Importacion ListaImportar .
  subsort LibImportar < ListaImportar .

  op NombreLibreria_ : Qid -> NombreLibreria [ctor] .
  op NombreContrato_ : Qid -> NombreContrato [ctor] .
  ops BoolUtils IntUtils PairUtils ListUtils : -> LibImportar [ctor] .
  op iv : -> Importacion [ctor] .
  op __ : ListaImportar ListaImportar -> ListaImportar [ctor assoc] .
  op import_ : ListaImportar -> Importacion [ctor] .
  op import__ : LibImportar Qid -> Importacion [ctor] .

  op __ : NombreLibreria ListaExpresiones -> Libreria [ctor] .
  
  op Contrato_______ : Nat Importacion Libreria NombreContrato ListaParamInm ListaCamposMod ListaTransiciones -> Contrato [ctor] .


endfm



***Vistas para poder definir los mapas
view Clave from TRIV to PROGRAMA is 
  sort Elt to Clave .
endv

view Mapa from TRIV to MAP{Nat, Nat} is
  sort Elt to Map{Nat, Nat} .
endv

***Modulo que contiene toda la especificación de la memoria
fmod MEMORIA is
  pr PROGRAMA .
  pr MAP{Nat, Nat} .
  pr MAP{Nat, Clave} .
  pr MAP{Nat, Mapa} .
  pr MAP{Nat, Qid} .

  sort Memoria Variable Val Pareja PilaMemoria ParejaFuncion letIn AmbitoAplicacion memoriaTransicion Opciones ListaT memoriaLetIn ParejaAct ParejaImportacion
       ParejaAplicar ParejaPar ParejaSome ParejaNil ParejaCons ParejaFun ParejaTipo memoriaProcedimiento . 
  subsort Qid < Variable .
  subsort DeclaracionOp String Entero PilaMemoria ExpresionFuncion ParamInm Expresion ParejaFuncion Option Evento Bool Lista MapVacio ExpresionAplicarF Par ParEjecucion ExpresionArr ExpresionMatch Excepcion < Val .
  subsort Pareja < Memoria .
  subsort Option < AmbitoAplicacion .
  subsort memoriaTransicion memoriaProcedimiento memoriaLetIn ParejaAct ParejaImportacion ParejaAplicar ParejaPar ParejaSome ParejaNil ParejaCons ParejaFun ParejaTipo < Pareja .
  
  ***Declaraciones de la memoria
  op [_] : Transicion -> Pareja [ctor] .
  op [_] : Procedimiento -> Pareja [ctor] .
  op [_] : Declaracion -> Pareja [ctor] .
  op [_] : DeclaracionOp -> Pareja [ctor] .
  op [_] : DeclaracionOpBools -> Pareja [ctor] .
  op [_] : Int -> Pareja [ctor] .
  op [_] : ExpresionMatch -> Pareja [ctor] .
  op [_] : Bool -> Pareja [ctor] .
  op [_=>_,_] : Variable Val AmbitoAplicacion -> letIn [ctor] .
  op Actualizar[_,_] : Variable Qid -> ParejaAct [ctor] .
  op Actualizar[_,_] : Variable ValorCampo -> ParejaAct [ctor] .
  op Actualizar[_,_] : Variable Int -> ParejaAct [ctor] .
  op Actualizar[_,_] : Variable Val -> ParejaAct [ctor] .
  op Importaciones[_] : ListaImportar -> ParejaImportacion [ctor] .
  op AplicarF[_,_] : Variable QidList -> ParejaAplicar [ctor] .
  op AplicarF[_] : Variable -> ParejaAplicar [ctor] .
  op Par[_,_] : Qid Qid -> ParejaPar [ctor] .
  op Par[_,_] : Val Int -> ParejaPar [ctor] .
  op Par[_,_] : Val Val -> ParejaPar [ctor] .
  op Some[_] : Qid -> ParejaSome [ctor] .
  op Nil[_] : NombreTipo -> ParejaNil [ctor] .
  op None[_] : TipoParamInm -> Pareja [ctor] .
  op Cons[_,_] : Qid Qid -> ParejaCons [ctor] .
  op Funcion[_,_] : Memoria Memoria -> ParejaFun [ctor] .
  op Tipo[_,_] : Variable Constructoras -> ParejaTipo [ctor] .
  op Tipo[_,_] : Variable QidList -> ParejaTipo [ctor] .

  sort TipoEntrada .
  subsort String TipoParamInm < TipoEntrada .
  op Entrada[_=>_] : Variable TipoEntrada -> Pareja [ctor] .
  op Entrada[_=>_] : Variable Variable -> Pareja [ctor] .
  
  sort ValorVariable TipoVariable .
  subsort ValorCampo Bool String < ValorVariable .
  subsort TipoParamInm < TipoVariable .
  op [_=>_|_] : Variable ValorVariable TipoVariable  -> Pareja [ctor] .
  op [_=>_|_] : Variable Memoria Qid -> Pareja [ctor] .
  op [_=>_|_] : Variable Memoria TipoVariable  -> Pareja [ctor] .
  op [_=>_|_] : Variable Map{Nat,Clave} TipoVariable  -> Pareja [ctor] .
  op [_=>_|_] : Variable Map{Nat,Nat} TipoVariable  -> Pareja [ctor] .
  op [_=>_|_] : Variable Map{Nat,Mapa} TipoVariable  -> Pareja [ctor] .
  op [_=>_|_] : Variable Map{Nat,Qid} TipoVariable  -> Pareja [ctor] .
  op [_=>_|_] : Variable ParEjecucion Par -> Pareja [ctor] .
  op [_=>_|_] : Variable Int TipoVariable -> Pareja [ctor] .
  op [_=>_|_] : Variable Qid TipoVariable -> Pareja [ctor] .

  op [_=>_] : Variable Int -> Pareja [ctor] .
  
  op [_=>_] : Variable Val -> Pareja [ctor] .
  op [_=>_] : Variable Qid -> Pareja [ctor] .
  op [_=>_] : Variable ListaOpciones -> Pareja [ctor] .
 
  op [_=>_] : Variable Memoria -> Pareja [ctor] .
  op [_=>_] : TipoOpcion Memoria -> Pareja [ctor] .
  op [_=>_] : TipoOpcion QidList -> Pareja [ctor] .
  op [_=>_] : TipoOpcion Bool -> Pareja [ctor] .
  op [_=>_] : TipoOpcion ListaDeclaraciones -> Pareja [ctor] .
  op soloOpcion[_=>_] : TipoOpcion Memoria -> Pareja [ctor] .
  op [_=>_] : Variable TipoParamInm -> Pareja [ctor] .
  op [_=>_] : Variable Map{Nat, Clave} -> Pareja [ctor] .
  op [_=>_] : Variable Map{Nat, Nat} -> Pareja [ctor] .
  op [_=>_] : Variable Map{Nat, Mapa} -> Pareja [ctor] .
  op [_=>_] : Variable Map{Nat, Qid} -> Pareja [ctor] .
  op [_=>_] : Memoria Memoria -> Pareja [ctor] .
  op [_=>_,_] : Variable Evento Memoria -> Pareja [ctor] .
  op [_=>_,_] : Variable TipoDato Memoria -> Pareja [ctor] .
  op [_=>_,_] : Variable Memoria Memoria -> Pareja [ctor] .
  op [_,_] : Memoria QidList -> Pareja [ctor] .
  op [_=>_,_] : Variable Int Memoria -> Pareja [ctor] .
  op Existe[_=>_,_] : Variable Variable ListaPosiciones -> Pareja [ctor] .
  op Insertar[_=>_,_] : Variable Variable ListaPosiciones -> Pareja [ctor] .
  op Insertar[_=>_,_] : Variable Val Nat -> Pareja [ctor] .
  op Obtener[_=>_,_] : Variable Variable ListaPosiciones -> Pareja [ctor] .
  op Eliminar[_,_] : Qid ListaPosiciones -> Pareja [ctor] .
  op Eliminar[_,_] : Qid Nat -> Pareja [ctor] .
  op NumBloque[_] : Qid -> Pareja [ctor] .
  op [_,_,_,_,_] : Variable ListaParamInm ListaDeclaraciones Memoria Memoria -> memoriaTransicion [ctor] .
  op Proc[_,_,_,_,_] : Variable ListaParamInm ListaDeclaraciones Memoria Memoria -> memoriaProcedimiento [ctor] .
  op [_,_,_] : Variable Memoria Memoria -> memoriaTransicion [ctor] .
  op Proc[_,_,_] : Variable Memoria Memoria -> memoriaProcedimiento [ctor] .
  op @[_,_,_] : Variable TipoVariable TipoVariable -> Pareja [ctor] .
  op mv : -> Memoria [ctor] .
  op __ : Memoria Memoria -> Memoria [ctor assoc id: mv] .

  vars x x1 x2 : Qid .
  var TD : TipoDato .
  var Op : Operacion .
  var E : Expresion .
  var OPB : OperacionBuilt .
  var TE : TipoEntero .
  var IN : Int .
  var V : Valor .
  var S : String .
  var LCE : ListaCamposEvento .
  var PI : ParamInm .
  vars M M1 M2 M3 M4 M5 : Memoria .
  var LPI : ListaParamInm .
  var TPI : TipoParamInm .
  var LOP : ListaOpciones .
  var TOP : TipoOpcion .
  var EXPS : Expresiones .
  var OPC : Opcion .
  var D : Declaracion .
  var LD : ListaDeclaraciones .
  var VAL : Val .
  var xl : QidList .
  var LP : ListaPosiciones .
  vars NT NT1 : NombreTipo .
  var CONS : Constructoras .
  var CON : Constructora .
  var B : Bool .
  var EV : Evento .
  var MS : Mensaje .
  vars TV TV1 : TipoVariable .

***Indica si el valor introducido es un entero o no
  op esEntero : Val -> Bool [ctor] .
  eq esEntero(TE IN) = true .
  eq esEntero(VAL) = false [owise] .

***Operación que sirve para almacenar datos en memoria de forma recursiva
  op almacenar : Expresion -> Memoria [ctor] .
  op almacenar : Declaracion -> Memoria [ctor] .
  op almacenar : ExpresionMatch -> Memoria [ctor] .
  op almacenar : ParamInm -> Memoria [ctor] .
  op almacenar : Bool -> Memoria [ctor] .

  eq almacenar(lpv) = mv .
  eq almacenar(lcv) = mv .
  eq almacenar(true) = [true] .
  eq almacenar(false) = [false] .
  eq almacenar(TE IN) = [IN] .
  eq almacenar(builtin OPB) = [OPB] .
  eq almacenar(guardar x x2) = [x => x2] .
  eq almacenar(insertar x LP x2) = Insertar[x => x2, LP] .
  eq almacenar(obtener x x2 LP) = Obtener[x => x2, LP] .
  eq almacenar(evento x) = ['evento => x] .
  eq almacenar(enviar x) = ['enviar => x] .
  eq almacenar(throw x) = ['throw => x] .
  eq almacenar(accept) = [accept] .
  eq almacenar(OPB) = [OPB] .
  eq almacenar(Pair NT NT1 x x1) = Par[x,x1] .
  eq almacenar(Some NT x) = Some[x] .
  eq almacenar(delete x2 LP) = Eliminar[x2, LP] .
  eq almacenar(existe x x1 LP) = Existe[x => x1, LP] .
  eq almacenar(Nil{NT}) = Nil[NT] .
  eq almacenar(Cons NT x x2) = Cons[x,x2] .
  eq almacenar(x <-&BLOCKNUMBER) = NumBloque[x] .
  eq almacenar(x : TPI) = Entrada[x => TPI] .
  eq almacenar(x : x2) = [x => x2] .
  eq almacenar(x : S) = [x => S] .
  eq almacenar(@ x TV TV1) = @[x, TV, TV1] .
  eq almacenar(PI , LPI) = almacenar(PI) almacenar(LPI) .
  eq almacenar(PI ; LCE) = almacenar(PI) almacenar(LCE) .
  eq almacenar(aplicarF x) = AplicarF[x] .
  eq almacenar(aplicarF (x xl)) = AplicarF[x , xl] .
  eq almacenar(funcion PI Op) = Funcion[almacenar(PI),almacenar(Op)] .
  eq almacenar({-tag: S ; dirEnvio x ; cantidadEnvio TE IN ; LCE}) = ['tag => S] ['dirEnvio => x] ['cantidadEnvio => IN] almacenar(LCE) .
  eq almacenar({-tag: S ; dirEnvio x ; cantidadEnvio x1 ; LCE}) = ['tag => S] ['dirEnvio => x] ['cantidadEnvio => x1] almacenar(LCE) .
  eq almacenar({-eventname: S ; LCE}) = ['eventname => S] almacenar(LCE) .
  eq almacenar({-exception: S ; LCE}) = ['exception => S] almacenar(LCE) .
  eq almacenar(x = EV) = [x => almacenar(EV) | 'evento] .
  eq almacenar(x = MS) = [x => almacenar(MS) | 'mensaje] .
  eq almacenar(x = V) = [x => almacenar(V)] .
  eq almacenar(actualizar x x2) = Actualizar[x, x2] .
  eq almacenar(match x LOP) = almacenarMatch(match x LOP) .
  eq almacenar(let x TE IN in Op) = [x => TE IN , almacenar(Op)] .
  ceq almacenar(let x TD in Op) = [x => almacenar(TD) , almacenar(Op)] 
      if not(esEntero(TD)) .

***Operación para almacenar operaciones match de forma recursiva
  op almacenarMatch : ExpresionMatch -> Memoria [ctor] .
  op almacenarMatch : Opcion -> Memoria [ctor] .
  eq almacenarMatch(ldv) = mv .
  eq almacenarMatch(ev) = mv .
  eq almacenarMatch(insertar x LP x2 LD) = Insertar[x => x2, LP] almacenarMatch(LD) .
  eq almacenarMatch(obtener x x2 LP LD) = Obtener[x => x2, LP] almacenarMatch(LD) .
  eq almacenarMatch(delete x LP LD) = Eliminar[x, LP] almacenarMatch(LD) .
  eq almacenarMatch(builtin OPB LD) = [OPB] almacenarMatch(LD) .
  eq almacenarMatch(Some NT x LD) = Some[x] almacenarMatch(LD) .
  eq almacenarMatch(None{TPI} LD) = None[TPI] almacenarMatch(LD) .
  eq almacenarMatch(aplicarF (x xl) LD) = AplicarF[x , xl] almacenarMatch(LD) .
  eq almacenarMatch(D LD) = almacenar(D) almacenarMatch(LD) .
  eq almacenarMatch(E LD) = almacenar(E) almacenarMatch(LD) .
  eq almacenarMatch(opcionMatch TOP EXPS) = [TOP => almacenarMatch(EXPS)] .
  eq almacenarMatch(opcionMatch TOP x) = [TOP => x] .
  eq almacenarMatch(opcionMatch TOP B) = [TOP => B] .
  eq almacenarMatch(opcionMatch x EXPS) = [x => almacenarMatch(EXPS)] .
  eq almacenarMatch(opcionMatch x B) = [x => B] .
  eq almacenarMatch(OPC LOP) = almacenarMatch(OPC) almacenarMatch(LOP) .
  eq almacenarMatch(match x LOP) = [x => almacenarMatch(LOP)] .

 ***Operacion para almacenar un ADT en memoria
  op almacenarTipo : Constructoras -> QidList [ctor] .
  eq almacenarTipo(consv) = nil .
  eq almacenarTipo(| x CONS) = x almacenarTipo(CONS) .

endfm

***Módulo que define el sistema
fmod SISTEMA is
  pr MEMORIA .
  sort Sistema Memorias Sustituir .

  op [_,_,_] : Contrato Memoria Memoria -> Sistema [ctor] .
  op [_,_] : Memoria Memoria -> Sistema [ctor] .
  op {_,_} : Memoria Qid -> Sistema [ctor] .

  --- op init : -> Sistema .

  --- eq init = [Contrato 0 iv NombreLibreria 'HelloWorld let 'one_msg funcion 'msg : Message let 'nil_msg Nil{Message} in
  ---  Cons Message 'msg 'nil_msg let 'S1 Uint32 3 let 'S2 Uint32 2 NombreContrato 'HelloWorld ('owner : ByStr20) 
  ---           campo 'welcome_msg : Uint32 = Uint32 1 transicion 'setHello ('msg : String) 'is_owner = builtin 1 ==. 2 end   , mv, mv] .


endfm 

***Modulo de reglas para almacenar en la memoria
mod REGLAS is 
  pr SISTEMA .
  
  var M M' M1 M2 M3 M4 M5 M6 M7 M8 M10 M11 : Memoria .
  var x x' x2 x3 : Qid .
  vars E E' : Entero .
  var C : Contrato .
  var N : Nat .
  var I : Importacion .
  var L : Libreria .
  var NC : NombreContrato .
  var LPI : ListaParamInm .
  var LCM : ListaCamposMod .
  var LT : ListaTransiciones .
  var NL : NombreLibreria .
  var LE : ListaExpresiones .
  var TP : TipoParamInm .
  var V : Val .
  var P : Pareja .
  var LD : ListaDeclaraciones .
  var PI : ParamInm .
  var Op : Operacion .
  var TD : TipoDato .
  var T : Transicion .
  var VL : Valor .
  var LOP : ListaOpciones .
  var D : Declaracion .
  var OPB : OperacionBuilt .
  var TE : TipoEntero .
  vars IN IN1 : Int .
  var S : String .
  var LCE : ListaCamposEvento .
  var EXP : Expresion .
  var EM : ExpresionMatch .
  var B : Bool .
  var LIMP : ListaImportar .
  vars VCP VCP1 : ValorCampo .
  var APF : ExpresionAplicarF .
  var LP : ListaPosiciones .
  vars NT NT1 NT2 : NombreTipo .
  var TV : TipoValor .
  var CONS : Constructoras .
  var QL : QidList .
  var CON : Constructora .
  var PROC : Procedimiento .
  var DECOP : DeclaracionOpMapI .
  var MP : Map{Nat,Clave} .
  var MPN : Map{Nat,Nat} .
  var MNM : Map{Nat, Mapa} .
  var MNQ : Map{Nat, Qid} .

  ***Regla para guardar las importaciones
  rl[Contrato N import LIMP NL LE NC lpv LCM LT ,M, M'] => [Contrato N iv NL LE NC lpv LCM LT ,M Importaciones[LIMP], M'] .
  ***Regla para guardar una variable de un let en la memoria
  rl[Contrato N I NL let x TE IN LE NC lpv LCM LT ,M, M'] => [Contrato N I NL LE NC lpv LCM LT ,M[x => IN | TE], M'] .
  crl[Contrato N I NL let x V LE NC lpv LCM LT ,M, M'] => [Contrato N I NL LE NC lpv LCM LT ,M[x => V], M'] 
     if not(esEntero(V)) .
  ***Reglas para almacenar los tipos en la memoria
  rl[Contrato N I NL tipo x CONS LE NC lpv LCM LT ,M, M'] => [Contrato N I NL LE NC lpv LCM LT ,M Tipo[x, almacenarTipo(CONS)], M'] .
  
  ***Regla para guardar los parametros inmutables en la memoria.
  crl[Contrato N I NL LE NC LPI LCM LT,M, M'] => [Contrato N I NL LE NC lpv LCM LT,M almacenar(LPI), M'] 
    if not(LPI == lpv) .
  
  op esNone : ValorCampo -> Bool [ctor] .
  eq esNone(None{NT}) = true .
  eq esNone(VCP) = false [owise] .

  op hayBalance : Memoria -> Bool [ctor] .
  eq hayBalance(['_balance => 0 | Uint128] M) = true .
  eq hayBalance([x => IN | TV] M) = hayBalance(M) .
  eq hayBalance([x => V | TV] M) = hayBalance(M) .
  eq hayBalance(Entrada[x => TV] M) = hayBalance(M) [print M] .
  eq hayBalance(M) = false [owise] .
  
  ***Regla para guardar un campo en la memoria
  rl[Contrato N I NL LE NC lpv campo x : TP = APF LCM LT,M, M'] => [Contrato N I NL LE NC lpv LCM LT,M[x => almacenar(APF) | TP], M'] .
  rl[Contrato N I NL LE NC lpv campo x : TP = None{NT} LCM LT,M, M'] => [Contrato N I NL LE NC lpv LCM LT,M[x => None | TP], M'] .
  rl[Contrato N I NL LE NC lpv campo x : TE = TE IN LCM LT,M, M'] => [Contrato N I NL LE NC lpv LCM LT,M[x => IN | TE], M'] .
  crl[Contrato N I NL LE NC lpv campo x : TP = VCP LCM LT,M, M'] => [Contrato N I NL LE NC lpv LCM LT,M[x => VCP | TP], M'] 
     if not(esEntero(VCP)) /\ not(esNone(VCP)) .
  crl[Contrato N iv NL lev NC lpv lcmv LT,M [x => IN | TV], M'] => [Contrato N iv NL lev NC lpv lcmv LT,M [x => IN | TV] ['_balance => 0 | Uint128], M'] 
     if x =/= '_balance .
  crl[C,M [x => Emp NT TE | Map NT TE]M1, M'] => [C,M[x => MPN | Map NT TE]M1, M'] 
    if MPN := empty .
  crl[C,M [x => Emp NT 'Dummy | Map NT 'Dummy]M1, M'] => [C,M[x => MNQ | Map NT 'Dummy]M1, M'] 
    if MNQ := empty .
  crl[C,M [x => Emp NT (Map NT1 TE) | Map NT (Map NT1 TE)]M1, M'] => [C,M[x => MNM | Map NT (Map NT1 TE)]M1, M'] 
    if MNM := empty .
  crl[C,M [x => Emp NT TV | Map NT TV]M1, M'] => [C,M[x => MP | Map NT TV]M1, M'] 
    if MP := empty /\
       TV =/= Map ByStr20 Uint128 .
  
  
  
  ***Regla para almacenar una funcion en la memoria.
  rl[C , M2[x => funcion PI Op]M , M'] => [C , M2[x => Funcion[almacenar(PI), almacenar(Op)]]M , M'] .
  ***Regla para guardar una transicion en la memoria (en este caso se guarda la regla entera)
  rl[Contrato N I NL LE NC LPI LCM T LT ,M,M'] => [Contrato N I NL LE NC LPI LCM LT,M,M'[T]] .
  ***Regla para guardar una transicion en la memoria (se divide la transicion en [nombre, entradas, cuerpo])
  rl[C , M , M2 [transicion x LPI LD end] M'] => [C , M , M2[x, LPI, LD, mv,  Entrada['_amount => Uint128] Entrada['_sender => ByStr20]]M'] .
  ***Regla para guardar un procedimiento en la memoria (en este caso se guarda la regla entera)
  rl[Contrato N I NL LE NC LPI LCM PROC LT ,M,M'] => [Contrato N I NL LE NC LPI LCM LT,M,M'[PROC]] .
  ***Regla para guardar un procedimiento en la memoria
  rl[C , M , M2 [procedimiento x LPI LD end] M'] => [C , M , M2 Proc[x, LPI, LD, mv, mv]M'] .
  ***Regla para almacenar las declaraciones en la memoria
  rl[C , M , M3[x, LPI, D LD, M2, M4]M'] => [C , M , M3[x, LPI, LD, M2 almacenar(D), M4 ]M'] .
  ***rl[C , M , M3[x, LPI, existe x2 x3 LP LD, M2, M4]M'] => [C , M , M3[x, LPI, LD, M2 Existe[x2 => x3,LP], M4 ]M'] .
  ***rl[C , M , M3[x, LPI, delete x2 LP LD, M2, M4]M'] => [C , M , M3[x, LPI, LD, M2 Eliminar[x2,LP], M4 ]M'] .
  rl[C , M , M3[x, LPI, aplicarF (x2 QL) LD, M2, M4]M'] => [C , M , M3[x, LPI, LD, M2 AplicarF[x2,QL], M4 ]M'] .
  rl[C , M , M3[x, LPI, DECOP LD, M2, M4]M'] => [C , M , M3[x, LPI, LD, M2 almacenar(DECOP), M4 ]M'] .
  

  rl[C , M , M3 Proc[x, LPI, D LD, M2, M4]M'] => [C , M , M3 Proc[x, LPI, LD, M2 almacenar(D), M4 ]M'] .
  rl[C , M , M3 Proc[x, LPI, aplicarF (x2 QL) LD, M2, M4]M'] => [C , M , M3 Proc[x, LPI, LD, M2 AplicarF[x2,QL], M4 ]M'] .
  ***rl[C , M , M3 Proc[x, LPI, existe x2 x3 LP LD, M2, M4]M'] => [C , M , M3 Proc[x, LPI, LD, M2 Existe[x2 => x3,LP], M4 ]M'] .
  rl[C , M , M3 Proc[x, LPI, delete x2 LP LD, M2, M4]M'] => [C , M , M3 Proc[x, LPI, LD, M2 Eliminar[x2,LP], M4 ]M'] .
  rl[C , M , M3 Proc[x, LPI, throw x2 LD, M2, M4]M'] => [C , M , M3 Proc[x, LPI, LD, M2 ['throw => x2], M4 ]M'] .
  rl[C , M , M3 Proc[x, LPI, DECOP LD, M2, M4]M'] => [C , M , M3 Proc[x, LPI, LD, M2 almacenar(DECOP), M4 ]M'] .
  
  ***Regla para almacenar las entradas en la memoria
  crl[C , M , M3[x, LPI, LD, M2, M4]M'] => [C , M , M3[x, lpv, LD, M2, M4 almacenar(LPI)]M'] 
     if not(LPI == lpv) .
    
  crl[C , M , M3 Proc[x, LPI, LD, M2, M4]M'] => [C , M , M3 Proc[x, lpv, LD, M2, M4 almacenar(LPI)]M'] 
     if not(LPI == lpv) .



  ***Regla para almacenar la expresion match en la memoria ([comprobacion = > cuerpo])
  rl[C , M , M3[x, LPI, EM LD, M2, M4]M'] => [C , M , M3[x, LPI, LD, M2[EM], M4 ]M'] .
  rl[C , M , M3[x, LPI, LD, M2[EM]M5, M4]M'] => [C , M , M3[x, LPI, LD, M2 almacenarMatch(EM) M5, M4 ]M'] .

  rl[C , M , M3 Proc[x, LPI, EM LD, M2, M4]M'] => [C , M , M3 Proc[x, LPI, LD, M2[EM], M4 ]M'] .
  rl[C , M , M3 Proc[x, LPI, LD, M2[EM]M5, M4]M'] => [C , M , M3 Proc[x, LPI, LD, M2 almacenarMatch(EM) M5, M4 ]M'] .

  op noMatch : Memoria -> Bool [ctor] .
  eq noMatch([EM] M) = false .
  eq noMatch(P M1) = noMatch(M1) .
  eq noMatch(M) = true [owise] .

  rl[C , M , M3 Proc[x, lpv, ldv, M2[EM]M5 , M4]M'] => [C , M Proc[x, lpv, ldv, M2 almacenarMatch(EM) M5, M4], M3 M'] .
  crl[C , M , M3 Proc[x, lpv, ldv, M2, M4]M'] => [C , M Proc[x, lpv, ldv, M2, M4], M3 M'] 
     if noMatch(M2) .


endm

***Módulo para suprimir campos innecesarios de la memoria de las transiciones y procedimientos
mod REGLAS-SUPRIMIR is
  pr SISTEMA .

  vars M M1 M2 M3 M4 : Memoria .
  var x : Qid .

  rl [M, M1 [x, lpv, ldv, M2, M3]M4] => [M, M1 [x, M2, M3]M4] .
  rl [M Proc[x, lpv, ldv, M2, M3]M4, M1] => [M Proc[x, M2, M3]M4, M1] .

endm




***Modulo reglas para ejecutar transiciones
mod REGLAS-EJECUTAR is
  pr SISTEMA .

  vars x x1 x2 x3 x4 x5 : Qid .
  var NT NT1 NT2 : NombreTipo .
  vars M M' M1 M2 M3 M4 M5 M6 M7 M8 M9 : Memoria .
  var LPI : ListaParamInm .
  var LD : ListaDeclaraciones .
  var TE : TipoEntero .
  vars IN IN1 : Int .
  var OPB : OperacionBuilt .
  var B B1 : Bool .
  var P : Pareja .
  vars VCP VCP1 : ValorCampo .
  vars V V1 : Val .
  var TOP : TipoOpcion .
  var QL QL1 : QidList .
  vars L L1 : Lista .
  vars MP MP1 : Map{Nat,Clave} .
  vars MPN MPN1 : Map{Nat,Nat} .
  vars MNM MNM1 : Map{Nat,Mapa} .
  var N N1 : Nat .
  var LP : ListaPosiciones .
  var S : String .
  var CL : Clave .
 

  ***Reglas para sustituir variables globales (campos)
  rl[M [x2 => AplicarF[x]] M1, M3] => [M [x2 => x] M1 , M3] .
  rl[M [x => VV | TV] M1 [x2 => AplicarF[x] | TV] M2 , M3] => [M [x => VV | TV] M1 [x2 => VV | TV] M2 , M3] .
  rl[M [x2 => AplicarF[x] | TV] M1 [x => VV | TV] M2 , M3] => [M [x2 => VV | TV] M1 [x => VV | TV] M2 , M3] .
  rl[M [x => IN | TV] M1 [x2 => AplicarF[x] | TV] M2 , M3] => [M [x => IN | TV] M1 [x2 => IN | TV] M2 , M3] .
  rl[M [x2 => AplicarF[x] | TV] M1 [x => IN | TV] M2 , M3] => [M [x2 => IN | TV] M1 [x => IN | TV] M2 , M3] .
 

  ***Reglas para ejecutar un let dentro de un campo modificable.
  rl[M [x => let x3 Emp ByStr20 Uint128 in builtin put x3 x1 x2 | Map NT TE] M1 [x1 => IN | TV] M3 [x2 => IN1 | TV1] M4, M2] => [M [x => insert(IN, IN1, empty) | Map NT TE] M1 [x1 => IN | TV] M3 [x2 => IN1 | TV1] M4, M2] .
  rl[M [x => let x3 Emp ByStr20 'Dummy in builtin put x3 x1 x2 | Map NT 'Dummy] M1 [x2 => x4] M3 [x1 => IN1 | TV1] M4, M2] => [M [x => insert(IN1, x4, empty) | Map NT 'Dummy] M1 [x2 => x4] M3 [x1 => IN1 | TV1] M4, M2] .


  sort TipoEjecutar .
  subsort Bool OperacionBuilt < TipoEjecutar .
  op ejecutar : OperacionBuilt -> TipoEjecutar [ctor] .
  eq ejecutar(IN ==. IN1) = (IN == IN1) .
  eq ejecutar(OPB) = OPB [owise] .
  
  ***Operaciones que eliminan una pareja del mapa.
  op eliminar : Map{Nat,Clave} Nat -> Map{Nat,Clave} [ctor] .
  eq eliminar((MP, N |-> CL, MP1), N) = MP, MP1 .
  eq eliminar(MP, N) = MP [owise] .

  op eliminarNat : Map{Nat,Nat} Nat -> Map{Nat,Nat} [ctor] .
  eq eliminarNat((MPN, N |-> N1, MPN1), N) = MPN, MPN1 .
  eq eliminarNat(MPN, N) = MPN [owise] .
  
  ***Operaciones para obtener valores a partir de una clave en los mapas
  op obtenerValor : Map{Nat,Nat} Nat -> Option [ctor] .
  eq obtenerValor((MPN, N |-> N1, MPN1), N) = Some N1 .
  eq obtenerValor(MPN, N) = None [owise] .

  op obtenerValorC : Map{Nat,Clave} Nat -> Option [ctor] .
  eq obtenerValorC((MP, N |-> CL, MP1), N) = Some CL .
  eq obtenerValorC(MP, N) = None [owise] .

  op obtenerValorMapa : Map{Nat,Mapa} Nat Nat -> Option [ctor] .
  eq obtenerValorMapa((MNM, N |-> MPN, MNM1), N, N1) = obtenerValor(MPN, N1) .
  eq obtenerValorMapa(MNM, N, N1) = None [owise] .


  ***Sustituye los parámetros de una función
  op sustituirFuncion : Memoria Memoria QidList -> Memoria [ctor] .
  eq sustituirFuncion(M, M1, nil) = M1 .
  eq sustituirFuncion(M[x => IN | TV]M1, Funcion[Entrada[x1 => TV], M2], x QL) = Funcion[[x1 => IN | TV], sustituirFuncion(M[x => IN | TV]M1, M2, QL)] .
  eq sustituirFuncion(M[x => V | TV]M1, Funcion[Entrada[x1 => TV], M2], x QL) = Funcion[[x1 => V | TV], sustituirFuncion(M[x => V | TV]M1, M2, QL)] .
  eq sustituirFuncion(M[x => x2 | TV]M1, Funcion[Entrada[x1 => TV], M2], x QL) = Funcion[[x1 => x2 | TV], sustituirFuncion(M[x => x2 | TV]M1, M2, QL)] .
  eq sustituirFuncion(M[x => MPN | TV]M1, Funcion[Entrada[x1 => TV], M2], x QL) = Funcion[[x1 => MPN | TV], sustituirFuncion(M[x => MPN | TV]M1, M2, QL)] .
  eq sustituirFuncion(M[x => M3 | 'mensaje]M1, Funcion[Entrada[x1 => Message], M2], x QL) = Funcion[[x1 => M3 | 'mensaje], sustituirFuncion(M[x => M3]M1, M2, QL)] .
  
  ***Coge los parámetros de una función
  op cogerParamFuncion : Memoria -> Memoria [ctor] .
  eq cogerParamFuncion(Funcion[[x1 => IN | TV], M2]) = [x1 => IN | TV] cogerParamFuncion(M2) .
  eq cogerParamFuncion(Funcion[[x1 => V | TV], M2]) = [x1 => V | TV] cogerParamFuncion(M2) .
   eq cogerParamFuncion(Funcion[[x1 => x | TV], M2]) = [x1 => x | TV] cogerParamFuncion(M2) .
  eq cogerParamFuncion(Funcion[[x1 => M3 | 'mensaje], M2]) = [x1 => M3 | 'mensaje] cogerParamFuncion(M2) .
  eq cogerParamFuncion(Funcion[[x1 => MPN | TV], M2]) = [x1 => MPN | TV] cogerParamFuncion(M2) .
  eq cogerParamFuncion(M) = mv [owise] .

  ***Coger las instrucciones de una función
  op cogerInst : Memoria -> Memoria [ctor] .
  eq cogerInst(Funcion[[x1 => IN | TV], M2]) = cogerInst(M2) .
  eq cogerInst(Funcion[[x1 => V | TV], M2]) = cogerInst(M2) .
  eq cogerInst(Funcion[[x1 => x | TV], M2]) = cogerInst(M2) .
  eq cogerInst(Funcion[[x1 => M3 | 'mensaje], M2]) = cogerInst(M2) .
  eq cogerInst(Funcion[[x1 => MPN | TV], M2]) = cogerInst(M2) .
  eq cogerInst(M) = M [owise] .

  sort ValorTipo .
  ***Estructura que devuelve el valor y el tipo (usada en la ejecución de funciones)
  op |_,_| : Val TipoVariable -> ValorTipo [ctor] .
  op |_,_| : Int TipoVariable -> ValorTipo [ctor] .
  op |_,_| : Memoria Qid -> ValorTipo [ctor] .

  ***Reglas para ejecutar una función
  op ejecutarFuncion : Memoria Memoria -> ValorTipo [ctor] .
  eq ejecutarFuncion(M[x => V | TV] M1 [x1 => V1 | TV]M3, [x or x1]) = | V or V1, Bool | .
  eq ejecutarFuncion(M[x => IN | TV] M1 [x1 => IN1 | TV]M3, [x <. x1]) = | IN < IN1, Bool | .
  eq ejecutarFuncion(M[x => IN | TV] M1 [x1 => IN1 | TV]M3, [x1 <. x]) = | IN1 < IN, Bool | .
  eq ejecutarFuncion(M[x => B | Bool] M1, [negb x]) = | not B, Bool | .
  eq ejecutarFuncion(M[x => IN | TV] M1, M2 [x1 => x] M3) = | M2 [x1 => IN] M3, 'excepcion | .
  eq ejecutarFuncion(M[x => IN | TV] M1 [x1 => IN1 | TV]M3, [x2 => [x ==. x1], M2]) = ejecutarFuncion(M[x => IN | TV] M1 [x1 => IN1 | TV]M3 [x2 => IN == IN1 | Bool] , M2) .
  eq ejecutarFuncion(M[x => IN | TV] M1 [x1 => IN1 | TV]M3, [x2 => [x1 ==. x], M2]) = ejecutarFuncion(M[x => IN | TV] M1 [x1 => IN1 | TV]M3 [x2 => IN1 == IN | Bool] , M2) .
  eq ejecutarFuncion(M[x => IN | TV] M1 [x1 => IN1 | TV]M3, [x2 => [x <. x1], M2]) = ejecutarFuncion(M[x => IN | TV] M1 [x1 => IN1 | TV]M3 [x2 => IN < IN1 | Bool] , M2) .
  eq ejecutarFuncion(M[x => IN | TV] M1 [x1 => IN1 | TV]M3, [x2 => [x +. x1], M2]) = ejecutarFuncion(M[x => IN | TV] M1 [x1 => IN1 | TV]M3 [x2 => IN + IN1 | TV] , M2) .
  eq ejecutarFuncion(M[x => IN | BNum] M1 [x1 => IN1 | TE]M3, [x2 => [x +. x1], M2]) = ejecutarFuncion(M[x => IN | BNum] M1 [x1 => IN1 | TE]M3 [x2 => IN + IN1 | BNum] , M2) .
  eq ejecutarFuncion(M[x => V | TV] M1 [x1 => V1 | TV]M3, [x2 => Par[x1, x], M2]) = ejecutarFuncion(M[x => V | TV] M1 [x1 => V1 | TV]M3 [x2 => Pair V1 V] , M2) .
  eq ejecutarFuncion(M[x => V | TV] M1 [x1 => V1 | TV]M3, [x2 => Par[x, x1], M2]) = ejecutarFuncion(M[x => V | TV] M1 [x1 => V1 | TV]M3 [x2 => Pair V V1] , M2) .

  eq ejecutarFuncion(M, [x2 => TE IN, M2]) = ejecutarFuncion(M [x2 => IN | TE] , M2) .
  eq ejecutarFuncion(M[x => TOP | TV]M3, [x2 => M1[TOP => B]M2]) = | B, Bool | .
  eq ejecutarFuncion(M[x => TOP | TV]M3, [x2 => M1[x3 => B]]) = | B, Bool |  .
  eq ejecutarFuncion(M[x => Some IN | Option TV]M3, [x => M1[Some x1 => M4]]) = ejecutarFuncion(M[x => Some IN | Option TV]M3[x1 => IN | TV], M4) .
  eq ejecutarFuncion(M[x => Some IN | Option TV]M3, [x => M1[Some x1 => x1]M2]) = | IN, TV | .
  eq ejecutarFuncion(M[x1 => IN | TV] M2 [x => TOP]M3, [x2 => M1[TOP => x1]M2]) = | IN, TV | .
  eq ejecutarFuncion(M[x => TOP | Option TV]M3, [x2 => M1[TOP => 'zero]M2]) = | 0, TV | .
  eq ejecutarFuncion(M[x => TOP | TV]M3, [x2 => M1[x3 => M4]]) = ejecutarFuncion(M[x => TOP | TV]M3, M4)  .
  eq ejecutarFuncion(M[x => IN | TV]M3, Some[x]) = | Some IN, Option TV | .
  eq ejecutarFuncion(M[x => TOP | TV]M3, [x => M1[TOP => M2]M4]) = ejecutarFuncion(M[x => TOP | TV]M3, M2) .
  eq ejecutarFuncion(M[x => x1 | TV]M3, [x2 => [x => M1[x1 => [IN]]M4], M5]) = ejecutarFuncion(M[x2 => IN | TV]M3, M5) .

  vars VV VV1 : ValorVariable .
  vars TV TV1 : TipoVariable .
  var NE : NombreEvento .
  var TVal : TipoValor .

  
  ***Regla para ejecutar la operacion igual
  ***Los parámetros están en las variables globales y en la entrada de la transicion
  rl[M[x4 => IN | TV]M1 , [x, M2[x2 => [x3 ==. x4]] M3, M4[x3 => IN1 | TV] M5]] => [M[x4 => IN | TV]M1 , [x, M2[x2 => IN1 == IN | Bool] M3, M4[x3 => IN1 | TV] M5]] .
  rl[M , [x, M2[x2 => [x3 ==. x4]] M3, M4[x3 => IN1 | TV] M5[x4 => IN | TV]M1]] => [M, [x, M2[x2 => IN1 == IN | Bool] M3, M4[x3 => IN1 | TV] M5[x4 => IN | TV]M1]] .

  ***Regla para ejecutar la operacion suma
  ***Los parámetros están en las variables globales y en las variables locales
  rl[M[x4 => IN | TE]M1 , [x, M2[x3 => IN1 | TE]M5[x2 => [x3 +. x4]] M3, M4]] => [M[x4 => IN | TE]M1 , [x, M2 M5[x2 => IN + IN1 | TE] M3, M4]] .
  ***Los dos parametros estan en las variables globales
  rl[M[x4 => IN | TV]M1[x3 => IN1 | TV]M5 , [x, M2[x2 => [x4 +. x3]] M3, M4]] => [M[x4 => IN | TV]M1[x3 => IN1 | TV]M5 , [x, M2 [x2 => IN + IN1 | TV] M3, M4]] .
  ***Los dos parametros estan en las variables globales (para el caso del badd)
  rl[M[x4 => IN | BNum]M1[x3 => IN1 | TE]M5 , [x, M2[x2 => [x4 +. x3]] M3, M4]] => [M[x4 => IN | BNum]M1[x3 => IN1 | TE]M5 , [x, M2 [x2 => IN + IN1 | BNum] M3, M4]] .
  ***Uno de los parámetros está en las variable local y el otro dentro de la asignacion
  rl[M, [x, M2[x3 => IN1 | TE]M5[x2 => [x4 => IN | TE] [x3 +. x4]] M3, M4]] => [M , [x, M2 [x3 => IN1 | TE] M5[x2 => IN1 + IN | TE] M3, M4]] .
  ***Uno de los parámetros está en las variable local y el otro es un parametro de entrada
  rl[M, [x, M2[x4 => IN1 | TE]M5[x2 => [x3 +. x4]] M3, M4 [x3 => IN | TE] M1]] => [M , [x, M2 [x4 => IN1 | TE] M5[x2 => IN1 + IN | TE] M3, M4[x3 => IN | TE] M1]] .

  ***Reglas para ejecutar la resta
  rl[M, [x, M2[x3 => IN1 | TE]M5[x2 => [x3 - x4]] M3, M4 [x4 => IN | TE] M1]] => [M , [x, M2 [x3 => IN1 | TE] M5[x2 => sd(IN1, IN) | TE] M3, M4[x4 => IN | TE] M1]] .

  ***Regla para quitar el match
  rl[M , [x, M2[x2 => TOP | NT] M5 [x2 => M6 [TOP => M7] M8] M1, M4]] => [M , [x, M2 M5 M7 M1, M4]] .
  rl[M , [x, M2[x2 => Some IN | Option TV] M5 [x2 => M6 [Some x3 => M7] M8] M1, M4]] => [M , [x, M2 M5 [x3 => IN | TV] M7 M1, M4]] .
  ***En el caso de que esté dentro de un igual.
  rl[M , [x, M2[x2 => TOP | NT] M5 [x3 => [x2 => M6 [TOP => x4] M8]] M1, M4]] => [M , [x, M2 M5 [x3 => x4] M1, M4]] .
  rl[M , [x, M2[x2 => Some IN | Option TV] M5 [x4 => [x2 => M6 [Some x3 => M7] M8]] M1, M4]] => [M , [x, M2 M5 [x4 => [x3 => IN | TV] M7] M1, M4]] .

  ***Regla para ejecutar la operacion actualizar
  ***La variable x2 está en la entrada de la transicion.
  rl[M[x1 => VV | TV]M1 , [x, M2 Actualizar[x1, x2] M3, M4[x2 => VV1 | TV] M5]] => [M[x1 => VV1 | TV]M1 , [x, M2 M3, M4[x2 => VV1 | TV] M5]] .
  ***La variable x2 es una variable local, este caso solo vale para enteros.
  rl[M[x1 => IN | TV]M1 , [x, M2[x2 => IN1 | TV] M5 Actualizar[x1, x2] M3, M4]] => [M[x1 => IN1 | TV]M1 , [x, M2 [x2 => IN1 | TV] M5 M3, M4]] .
  rl[M[x1 => V1 | TV]M1 , [x, M2[x2 => V | TE] M5 Actualizar[x1, x2] M3, M4]] => [M[x1 => V | TV]M1 , [x, M2 [x2 => V | TE] M5 M3, M4]] .
  rl[M[x1 => V1 | TV]M1 , [x, M2[x2 => V | TV] M5 Actualizar[x1, x2] M3, M4]] => [M[x1 => V | TV]M1 , [x, M2 [x2 => V | TV] M5 M3, M4]] .
  ***La x2 esta en la entrada de la transicion
  rl[M[x1 => IN | TE]M1 , [x, M2 Actualizar[x1, x2] M3, M4 [x2 => IN1 | TE] M5]] => [M[x1 => IN1 | TE]M1 , [x, M2 M3, M4 [x2 => IN1 | TE] M5]] .

  ***Regla para sustituir las variables de los eventos y mensajes.
  ***Desde una variable global.
  rl[M [x2 => IN | TV] M1 , [x, M2 [x1 => M5[x3 => x2]M6 | x4] M3, M4]] => [M [x2 => IN | TV] M1 , [x, M2 [x1 => M5[x3 => IN]M6 | x4] M3, M4]] .
  rl[M [x2 => V | TV] M1 , [x, M2 [x1 => M5[x3 => x2]M6 | x4] M3, M4]] => [M [x2 => V | TV] M1 , [x, M2 [x1 => M5[x3 => V]M6 | x4] M3, M4]] .
  ***Desde una variable local
  rl[M , [x, M1[x2 => VV | TV] M2 [x1 => M5[x3 => x2]M6 | x4] M3, M4]] => [M , [x, M1 M2 [x1 => M5[x3 => VV]M6 | x4] M3, M4]] .
  ***Desde una variable local, este caso solo vale para enteros
  rl[M , [x, M1[x2 => IN | TV] M2 [x1 => M5[x3 => x2]M6 | x4] M3, M4]] => [M , [x, M1 [x2 => IN | TV] M2 [x1 => M5[x3 => IN]M6 | x4] M3, M4]] .
  ***Desde una variable que está en la entrada de la transicion
  rl[M , [x, M1 [x1 => M5[x3 => x2]M6 | x4] M3, M4[x2 => IN | TV] M2]] => [M , [x, M1 [x1 => M5[x3 => IN]M6 | x4] M3, M4 [x2 => IN | TV] M2]] .
  rl[M , [x, M1 [x1 => M5[x3 => x2]M6 | x4] M3, M4[x2 => V | TV] M2]] => [M , [x, M1 [x1 => M5[x3 => V]M6 | x4] M3, M4 [x2 => V | TV] M2]] .
  
  ***Regla para sustituir variables.
  rl[M , [x, M2 [x1 => x2] M6, M4[x2 => IN | TE] M3 ]] => [M , [x, M2 [x1 => IN | TE] M6, M4[x2 => IN | TE] M3 ]] .

  ***Regla para ejecutar la operacion evento.
  crl[M , [x, M2 [x1 => M5 | 'evento] M3 ['evento => x1] M6, M4]] => [M , [x, M2 M3 ['evento => M5] M6, M4]] 
     if not(tenerMod(M5)) .

  ***Regla para ejecutar la operacion throw.
  crl[M , [x, M2 [x1 => M5 | 'excepcion] M3 ['throw => x1] M6, M4]] => [M , [x, ['throw => M5] , M4]] 
     if not(tenerMod(M5)) .

  ***Regla para ejecutar la operacion enviar.
  crl[M , [x, M2 [x1 => M5 | 'mensaje] M3 ['enviar => x1] M6, M4]] => [M , [x, M2 M3 ['enviar => M5] M6, M4]] 
     if not(tenerMod(M5)) .

  ***Regla para quitar los accept
  rl[M , [x, M2 [accept] M3, M4]] => [M, [x, M2 M3, M4]] .

  ***Regla para sustituir variables globales en las transiciones.
  rl[M [x2 => VV | TV] M1 , [x, M2 [x1 => x2] M3, M4]] => [M [x2 => VV | TV] M1 , [x, M2 [x1 => VV | TV] M3, M4]] .
  ***Para sustituir los mapas
  rl[M [x2 => MP | TV] M1 , [x, M2 [x1 => x2] M3, M4]] => [M [x2 => MP | TV] M1 , [x, M2 [x1 => MP | TV] M3, M4]] .
  rl[M [x2 => MPN | TV] M1 , [x, M2 [x1 => x2] M3, M4]] => [M [x2 => MPN | TV] M1 , [x, M2 [x1 => MPN | TV] M3, M4]] .
  rl[M [x2 => IN | TE] M1 , [x, M2 [x1 => x2] M3, M4]] => [M [x2 => IN | TE] M1 , [x, M2 [x1 => IN | TE] M3, M4]] .

  ***Reglas para sustituir variables que son locales.
  rl[M  , [x, M2 [x2 => IN | TV] M1 [x1 => x2] M3, M4]] => [M , [x, M2[x2 => IN | TV] M1 [x1 => IN | TV] M3, M4]] .

  ***Regla para ejecutar la operacion existe
  rl[M [x => MP | TV] M1, [x1, M2 Existe[x2 => x,posicion x3]M3, M4[x3 => N | TV1]M5]] => [M [x => MP | TV] M1, [x1, M2 [x2 => $hasMapping(MP, N) | Bool]M3, M4[x3 => N | TV1]M5]] .
  
  ***Reglas para ejecutar la operacion contains
  rl[M , [x1, M2 [x => MP | Map TE TVal] M1 [x2 => [contains x x3]]M3, M4[x3 => N | TE]M5]] => [M, [x1, M2 [x => MP | Map TE TVal] M1 [x2 => $hasMapping(MP, N) | Bool]M3, M4[x3 => N | TE]M5]] .

  ***Regla para ejecutar la operacion insertar
  rl[M [x => V] M6 [x2 => MP | Map NT TVal] M1, [x1, M2 Insertar[x2 => x,posicion x3]M3, M4[x3 => N | NT]M5]] => [M [x => V] M6 [x2 => insert(N, V, MP) | Map NT TVal] M1, [x1, M2 M3, M4[x3 => N | NT]M5]]  .
  ***Solo vale para cuando el valor del mapa es un par y el parametro está en una variable local
  rl[M[x2 => MP | Map NT TVal] M1, [x1, M2 [x => V | TVal] M6  Insertar[x2 => x,posicion x3]M3, M4[x3 => N | NT]M5]] => [M [x2 => insert(N, V, MP) | Map NT TVal] M1, [x1, M2 [x => V | TVal] M6 M3, M4[x3 => N | NT]M5]]  .
  ***Solo vale para cuando el valor del mapa es un par y el parametro está en una variable local
  rl[M[x2 => MPN | Map NT TE] M1, [x1, M2 [x3 => N | NT]M5 [x => IN | NT] M6  Insertar[x2 => x,posicion x3]M3, M4]] => [M [x2 => insert(N, IN, MPN) | Map NT TE] M1, [x1, M2 [x3 => N | NT]M5 [x => IN | NT] M6  M3, M4]]  .
  rl[M[x2 => MPN | Map NT TE] M1, [x1, M2 [x => IN | TE] M6  Insertar[x2 => x,posicion x3]M3, M4[x3 => N | NT]M5 ]] => [M [x2 => insert(N, IN, MPN) | Map NT TE] M1, [x1, M2  [x => IN | TE] M6  M3, M4[x3 => N | NT]M5]]  .
  rl[M[x2 => MNM | Map NT (Map NT1 TE)] M1, [x1, M2 [x => IN | TE] M6  Insertar[x2 => x,posicion x3 posicion x4]M3, M4 [x3 => N | NT]M5 [x4 => N1 | NT1]M7 ]] => [M [x2 => insert(N, insert(N1, IN, empty), MNM) | Map NT (Map NT1 TE)] M1, [x1, M2 [x => IN | TE] M6  M3, M4 [x3 => N | NT]M5 [x4 => N1 | NT1]M7]]  .
 
  op hayMsg : Memoria -> Bool [ctor] .
  eq hayMsg(M[x => M1 | 'mensaje]M2) = true .
  eq hayMsg(M) = false [owise] .


  var VT : ValorTipo .

  op [_=>_] : Variable ValorTipo -> Memoria [ctor] .


  ***Reglas para ejecutar una funcion
  crl[M, [x, M2 [x2 => M5 | 'mensaje] M6 [x3 => M7 | 'mensaje] M8[x1 => AplicarF['two_msgs, x2 x3]] M3, M4]] => [M , [x, M2 M6 M8[x1 => [x2 => M5] [x3 => M7] | 'mensaje] M3, M4]]
    if not(tenerMod(M5)) /\ not(tenerMod(M7)) .
  crl[M [x2 => M1] M5 , [x, M2[x1 => AplicarF[x2, QL]] M3, M4]] => [M [x2 => M1] M5 , [x, M2[x1 => [M1, QL]] M3, M4]]
    if not(tenerMod(M2)) /\ x2 =/= 'two_msgs .
  crl[M , [x, M2[x1 => [M1, QL]] M3, M4]] => [M , [x, M2[x1 => [sustituirFuncion(M M2 M4, M1, QL), nil]] M3, M4]] 
     if not(QL == nil)  .
  rl[M , [x, M2[x1 => [ M1, nil]] M3, M4]] => [M , [x, M2[x1 => [ cogerParamFuncion(M1) => cogerInst(M1)]] M3, M4]] .
  rl[M , [x, M2[x1 => [ [x2 => M6 | 'mensaje] => [x3 => Nil[NT], M8]]] M3, M4]] => [M , [x, M2[x1 => M6 | 'mensaje] M3, M4]]  .
  crl[M , [x, M2[x1 => [ M5 => M6]] M3, M4]] => [M , [x, M2[x1 => VT] M3, M4]]  
     if not(hayMsg(M5)) /\ VT := ejecutarFuncion(M5, M6) .
  rl[M , [x, M2[x1 => | V, TV |] M3, M4]] => [M , [x, M2[x1 => V | TV] M3, M4]]  .
  rl[M , [x, M2[x1 => | IN, TV |] M3, M4]] => [M , [x, M2[x1 => IN | TV] M3, M4]]  .
  rl[M , [x, M2[x1 => | M5, 'excepcion |] M3, M4]] => [M , [x, M2[x1 => M5 | 'excepcion] M3 , M4]]  .

  op rellenar : Memoria QidList Memoria -> Memoria [ctor] .
  eq rellenar(M, nil, M1) = mv .
  eq rellenar(Entrada[x => TV] M, x1 QL, M1 [x1 => IN | TV] M2) = [x => IN | TV] rellenar(M, QL, M1 M2) .
  eq rellenar(Entrada[x => TV] M, x1 QL, M1 [x1 => x2 | TV] M2) = [x => x2 | TV] rellenar(M, QL, M1 M2) .

  ***Reglas para ejecutar un procedimiento
  crl[M Proc[x2, M1, M5] M6 , [x, M2 AplicarF[x2, QL] M3, M4]] => [M Proc[x2, M1, M5] M6 , [x, M2 M1 M3, M4 rellenar(M5, QL, M2 M4)]] 
      if not(tenerMod(M2)) .
    
  ***Regla para ejecutar un let in
  ***La operacion es < y una de las variables está en la entrada de la transicion
  rl[M , [x, M2 [x1 => [x2 => TE IN, [x3 <. x2]]] M3, M4 [x3 => IN1 | TE] M5]] => [M , [x, M2 [x1 => IN1 < IN | Bool] M3, M4[x3 => IN1 | TE] M5]] .
  ***La operacion badd y una de las variables es local.
  rl[M , [x, M2[x3 => IN1 | BNum] M5 [x1 => [x2 => TE IN, [x3 +. x2]]] M3, M4 ]] => [M , [x, M2[x3 => IN1 | BNum] M5 [x1 => IN1 + IN | BNum] M3, M4 ]] .

  ***Reglas para ejecutar cosas dentro de una igualdad.
  rl[M , [x, M2 [x1 => [x2 => IN | TE] [x3 +. x2]] M3, M4 [x3 => IN1 | TE] M5]] => [M , [x, M2 [x1 => IN1 + IN | TE] M3, M4[x3 => IN1 | TE] M5]] .

  ***Regla para transformar una pareja
  var PE : ParEjecucion .
  ***Ambos argumentos estan en la entrada de la transicion
  rl[M , [x, M2 [x1 => Par[x2, x3]] M3, M4 [x2 => V | NT] M5 [x3 => IN | TE] M6]] => [M , [x, M2 [x1 => [V, IN] | Pair NT TE] M3, M4 [x2 => V | NT] M5 [x3 => IN | TE] M6]] .
  crl[M , [x, M2 [x1 => Par[x2, x3]] M3, M4 [x2 => V | NT] M5 [x3 => V1 | NT1] M6]] => [M , [x, M2 [x1 => PE | Pair NT NT1] M3, M4 [x2 => V | NT] M5 [x3 => V1 | NT1] M6]] 
     if PE := [V, V1] .

  ***Regla para sustituir el some
  rl[M , [x, M2 [x1 => Some[x2]] M3, M4 [x2 => IN | TE] M5]] => [M , [x, M2 [x1 => Some IN | TE] M3, M4 [x2 => IN | TE] M5]] .
  rl[M , [x, M2 [x1 => Some[x2]] M3, M4 [x2 => IN | TV] M5]] => [M , [x, M2 [x1 => Some IN | Option TV] M3, M4 [x2 => IN | TV] M5]] .

  ***Regla para ejecutar la operacion eliminar
  rl[M [ x4 => MP | TV] M2, [x, M1 Eliminar[x4, posicion x3] M3, M4[x3 => N | TE] M5]] => [M [ x4 => eliminar(MP, N) | TV] M2, [x, M1 M3, M4[x3 => N | TE] M5]]  .
  rl[M [ x4 => MPN | TV] M2, [x, M1 Eliminar[x4, posicion x3] M3, M4[x3 => N | TE] M5]] => [M [ x4 => eliminarNat(MPN, N) | TV] M2, [x, M1 M3, M4[x3 => N | TE] M5]]  .

  ***Regla para ejecutar la operacion get
  rl[M , [x, M1 [ x2 => MPN | Map NT TE] M2 [x4 => [get x2 x3]] M3, M4[x3 => N | TV] M5]] => [M , [x, M1 [ x2 => MPN | Map NT TE] M2 [x4 => obtenerValor(MPN, N) | Option TE] M3, M4[x3 => N | TV] M5]]  .
  rl[M [ x2 => MPN | Map NT TE] M2 , [x, M1 [x3 => N | NT] M5 Obtener[x1 => x2, posicion x3] M3, M4]] => [M [ x2 => MPN | Map NT TE] M2 , [x, M1 [x3 => N | NT] M5 [x1 => obtenerValor(MPN, N) | Option TE ] M3, M4]]  .
  rl[M [ x2 => MPN | Map NT TE] M2 , [x, M1 Obtener[x1 => x2, posicion x3] M3, M4[x3 => N | NT] M5 ]] => [M [ x2 => MPN | Map NT TE] M2 , [x, M1 [x1 => obtenerValor(MPN, N) | Option TE ] M3, M4[x3 => N | NT] M5 ]]  .
  rl[M [ x2 => MP | Map NT NT1] M2 , [x, M1 Obtener[x1 => x2, posicion x3] M3, M4[x3 => N | NT] M5 ]] => [M [ x2 => MP | Map NT NT1] M2 , [x, M1 [x1 => obtenerValorC(MP, N) | Option NT1 ] M3, M4[x3 => N | NT] M5 ]]  .
  rl[M [ x2 => MNM | Map NT (Map TV TV1)] M2 , [x, M1 Obtener[x1 => x2, posicion x3 posicion x4] M3, M4[x3 => N | NT] M5 [x4 => N1 | NT1] M6 ]] => [M [ x2 => MNM | Map NT (Map TV TV1)] M2 , [x, M1 [x1 => obtenerValorMapa(MNM, N, N1) | Option TV1 ] M3, M4[x3 => N | NT] M5 [x4 => N1 | NT1] M6 ]]  .
  rl[M [ x2 => MNM | Map NT (Map TV TV1)] M2 , [x, M1 Obtener[x1 => x2, posicion x4 posicion x3] M3, M4[x3 => N | NT] M5 [x4 => N1 | NT1] M6 ]] => [M [ x2 => MNM | Map NT (Map TV TV1)] M2 , [x, M1 [x1 => obtenerValorMapa(MNM, N1, N) | Option TV1 ] M3, M4[x3 => N | NT] M5 [x4 => N1 | NT1] M6 ]]  .

  ***Regla para ejecutar la operacion BLOCKNUMBER
  rl[M , [x, M1 NumBloque[x1] M2, M3]] => [M , [x, M1 [x1 => 34 | BNum ] M2, M3]] .

  ***Regla para ejecutar la operacion negb
  rl[M Importaciones[BoolUtils] M4, [x, M1 [x2 => V | Bool] M5 [x1 => [negb x2]] M2, M3]] => [M Importaciones[BoolUtils] M4, [x, M1 [x2 => V | Bool] M5 [x1 => not(V) | Bool] M2, M3]] .

  ***Regla para ejecutar la operacion andb
  rl[M Importaciones[BoolUtils] M4, [x, M1 [x2 => V | Bool] M5 [x3 => V1 | Bool] M6 [x1 => [x2 and x3]] M2, M3]] => [M Importaciones[BoolUtils] M4, [x, M1 [x2 => V | Bool] M5 [x3 => V1 | Bool] M6 [x1 => V and V1 | Bool] M2, M3]] .

  ***Regla para ejecutar la operacion andb
  rl[M Importaciones[BoolUtils] M4, [x, M1 [x2 => V | Bool] M5 [x3 => V1 | Bool] M6 [x1 => [x3 or x2]] M2, M3]] => [M Importaciones[BoolUtils] M4, [x, M1 [x2 => V | Bool] M5 [x3 => V1 | Bool] M6 [x1 => V1 or V | Bool] M2, M3]] .

  ***Quitar la memoria de un booleano
  rl[M , [x, M1 [x1 => [B]] M2, M3]] => [M , [x, M1 [x1 => B | Bool ] M2, M3]] .

  ***Regla para ejecutar la operacion menor
  rl[M , [x, M1 [x2 => IN | TE] M4 [x1 => [x2 <. x3]] M2, M3[x3 => IN1 | TE]M5]] => [M , [x, M1 [x2 => IN | TE] M4 [x1 => IN < IN1 | Bool] M2, M3[x3 => IN1 | TE]M5]] .
  rl[M , [x, M1 [x2 => IN | TE] M4 [x1 => [x3 <. x2]] M2, M3[x3 => IN1 | TE]M5]] => [M , [x, M1 [x2 => IN | TE] M4 [x1 => IN1 < IN | Bool] M2, M3[x3 => IN1 | TE]M5]] .
  rl[M[x3 => IN1 | TV]M5 , [x, M1 [x2 => IN | TV] M4 [x1 => [x2 <. x3]] M2, M3]] => [M[x3 => IN1 | TV]M5 , [x, M1 [x2 => IN | TV] M4 [x1 => IN < IN1 | Bool] M2, M3]] .
  ***rl[M[x3 => IN1 | TE]M5 , [x, M1 [x2 => IN | TE] M4 [x1 => [x2 <. x3]] M2, M3]] => [M[x3 => IN1 | TE]M5 , [x, M1 [x2 => IN | TE] M4 [x1 => IN < IN1 | Bool] M2, M3]] .
 
  ***Regla para crear un bloque
  rl[M , [x, M1 [x1 => AplicarF['_creation_block]] M2, M3]] => [M , [x, M1 [x1 => 2 | BNum ] M2, M3]] .

  ***Regla para asociar los tipos
  rl[M Tipo['Error, QL x2 QL1] M4 , [x, M1 [x1 => AplicarF[x2]] M2, M3]] => [M Tipo['Error, QL x2 QL1]M4 , [x, M1 [x1 => x2 | Error] M2, M3]] .
  
  ***Regla para ejecutar un let in
  rl[M , [x, M2[x3 => IN1 | TE] M5 [x1 => [x2 => [x4 <. x3], M7]] M3, M4[x4 => IN | TE] M6]] => [M , [x, M2[x3 => IN1 | TE] M5 [x1 => [x2 => IN < IN1, M7]] M3, M4[x4 => IN | TE] M6]] .
  rl[M , [x, M2[x1 => [x2 => TOP, [x2 => M5 [TOP => M7]M6]]] M3, M4]] => [M , [x, M2[x1 =>  M7] M3, M4]] .
  rl[M , [x, M2[x1 => [x2 => TOP, [x2 => M5 [TOP => 'zero]M6]]] M3, M4]] => [M , [x, M2[x1 =>  0 | Uint128] M3, M4]] .


  op tenerMod : Memoria -> Bool [ctor] .
  eq tenerMod(M[x => x1] M1) = true .
  eq tenerMod(M1[x3 => AplicarF[x, x2]]M2) = true .
  eq tenerMod(M1 Actualizar[x, x2] M2) = true .
  eq tenerMod(M1 Insertar[x => x2, LP] M2) = true .
  eq tenerMod([x ==. x1]) = true .
  eq tenerMod(Par[x1, x2]) = true .
  eq tenerMod(AplicarF[x, x2]) = true .
  eq tenerMod(AplicarF[x]) = true .
  eq tenerMod(M1[x3 => M4]M2) = tenerMod(M4) or tenerMod(M2) .
  eq tenerMod(M1[x2 => soloOpcion[TOP => M3]] M7) = tenerMod(M3)  .
  eq tenerMod(M) = false [owise] .

endm

***Módulo que carga el valor de los parámetros inmutables
mod REGLAS-VALOR is
 pr SISTEMA .
 pr CONVERSION .
 vars x x1 : Qid .
 var TV : TipoVariable .
 vars M M1 M2 : Memoria .
 var IN : Int .
 vars S S' : String .
 var N : Nat .

 op convertirInt : Qid -> Int [ctor] .
 ceq convertirInt(x) = IN
    if S := string(x) /\
       ***N := sd(length(S), 2) /\
       ***S' := substr(S, 1, N) [print N] .
       IN := rat(S, 10)  .

 op convertirString : Qid -> String [ctor] .
 ceq convertirString(x) = S'
    if S := string(x) /\
       N := sd(length(S), 2) /\
       S' := substr(S, 1, N) [print N] .

 op esString : Qid -> Bool [ctor] .
 ceq esString(x) = true 
    if S := string(x) /\
       N := find(S, "\"", 0) .
 eq esString(x) = false [owise] .


 crl {Entrada[x => TV] M, x1} => {M [x => convertirInt(x1) | TV], 'q} 
   if not(x1 == 'q) /\ not(esString(x1)) .

 crl {Entrada[x => TV] M, x1} => {M [x => convertirString(x1) | TV], 'q} 
   if not(x1 == 'q) .
endm

***Módulo que carga el valor de los parámetros de entrada de una transición.
mod REGLAS-VALOR-TRANSICION is
 pr SISTEMA .
 pr CONVERSION .
 vars x x1 x2 : Qid .
 var TV : TipoVariable .
 vars M M1 M2 : Memoria .
 var IN : Int .
 vars S S' : String .
 var N : Nat .

 op convertirInt : Qid -> Int [ctor] .
 ceq convertirInt(x) = IN
    if S := string(x) /\
       ***N := sd(length(S), 2) /\
       ***S' := substr(S, 1, N) [print N] .
       IN := rat(S, 10)  .

 op convertirString : Qid -> String [ctor] .
 ceq convertirString(x) = S'
    if S := string(x) /\
       N := sd(length(S), 2) /\
       S' := substr(S, 1, N) [print N] .

 op esString : Qid -> Bool [ctor] .
 ceq esString(x) = true 
    if S := string(x) /\
       N := find(S, "\"", 0) .
 eq esString(x) = false [owise] .



 crl {[x1, M1, Entrada[x => TV] M], x2} => {[x1, M1, M [x => convertirInt(x2) | TV]], 'q} 
   if not(x2 == 'q) /\ not(esString(x2)) [print "hecho"] .

 crl {[x1, M1, Entrada[x => TV] M], x2} => {[x1, M1, M [x => convertirString(x2) | TV]], 'q} 
   if not(x2 == 'q) [print "hecho"] .
endm

***Módulo para obtener la parte de código de una transición x
mod REGLAS-TRANSICION is
  pr SISTEMA .


  vars x : Qid .
  var TV : TipoVariable .
  vars M M1 M2 M3 M4 M5 : Memoria .

  rl {M [x, M1, M2] M3, x} => {[x, M1, M2], 'q} .


endm 



***rew init .

***Módulo que meta-representa el módulo GRAMMAR
fmod META-SIGN is
 including GRAMMAR .
 pr META-LEVEL .

 op BUBBLES : -> FModule .
 op GRAMMAR : -> FModule [memo] .

 eq BUBBLES
    = (fmod 'GRAMMAR is
        including 'QID-LIST .
        sorts none .
        none
        op 'token : 'Qid -> '@Token@
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '<-&BLOCKNUMBER)))] .
        op 'bubble : 'QidList -> '@Bubble@
             [special(
               (id-hook('Bubble, '1 '-1)
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, 'eq 'ceq 'rl 'crl 'mb 'cmb 'sd 'csd
                                  'var 'vars 'forall 'exists
                                  'sorts 'subsort 'subsorts 'op 'ops
                                  'protecting 'pr 'including 'inc 'extending 
                                  'ctor 'assoc 'comm '== '/\ 'spec* 'spec! 'builtin '`{ '`} 'let 'Pair '`( '`) 'Some
                                  '; 'andb 'true 'BoolU 'Uint32 'Uint128 'Uint256 'Nil 'throw 'Emp 'field 'false
                                  'ev '= '| 'Unit 'orb ':= 'None 'fun 'Int32 'Int128 'match 'String 'ByStr32 'ByStr33 'ByStr20 
                                  'BNum 'Bool 'Message 'Error 'ByStr 'ByStr64 'Unit '<- 'event '@ 'send 'schnorr-verify 'ecdsa-verify
                                  'add '<-exists 'lt 'contains 'delete 'put ' 'negb 'blt 'get 'remove 'badd 'accept 'sub)))] .
        op 'neTokenList : 'QidList -> '@NeTokenList@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '. ': '`[ 'forall 'exists)))] .
        none
        none
     endfm) .
 eq GRAMMAR = addImports(BUBBLES, (including 'GRAMMAR .)) .

 var  SSDS : SubsortDeclSet .
 vars IL IL' : ImportList .
 var  EqS : EquationSet .
 var  ODS : OpDeclSet .
 var  MAS : MembAxSet .
 var  RS : RuleSet .
 var  M : Module .
 var  SS : SortSet .
 var  H : Header .

 op setImports : Module ImportList -> Module .
 eq setImports(fmod H is IL sorts SS . SSDS ODS MAS EqS endfm, IL')
    = fmod H is IL' sorts SS . SSDS ODS MAS EqS endfm .
 eq setImports(mod H is IL sorts SS . SSDS ODS MAS EqS RS endm, IL')
    = mod H is IL' sorts SS . SSDS ODS MAS EqS RS endm .
 eq setImports(fth H is IL sorts SS . SSDS ODS MAS EqS endfth, IL')
    = fth H is IL' sorts SS . SSDS ODS MAS EqS endfth .
 eq setImports(th H is IL sorts SS . SSDS ODS MAS EqS RS endth, IL')
    = th H is IL' sorts SS . SSDS ODS MAS EqS RS endth .

 op addImports : Module ImportList -> Module .
 eq addImports(M, IL) = setImports(M, (getImports(M) IL)) .
endfm