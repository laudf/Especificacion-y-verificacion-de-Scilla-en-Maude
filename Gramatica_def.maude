fmod GRAMMAR is
  pr STRING .
  pr INT .
  sorts @Token@ @Bubble@ @NeTokenList@ .
  sort @DeclaracionOp@ @Prog@ @TipoEntero@ @Num@ @Entero@ @TipoOpto@ @BNum@ @NombreTipo@ @Option@ @Lista@ @Par@ @Natural@ @Contrato@ .
  ***subsort @DeclaracionOp@ @Entero@ String @BNum@ @Option@ @Lista@ @Par@ @Natural@ @ParametrosInm@ @Campo_mod@ @Version@ < @Prog@ .

  ***DATOS PRMITIVOS

  ***ENTEROS
  ***Declaración de entero (Nombre de su tipo y el valor), los uint los trato como naturales.
  ops Uint32 Uint64 Uint128 Uint256 Int32 Int64 Int128 Int256 : -> @TipoEntero@ [ctor] .
  op __ : @TipoEntero@ Int -> @Entero@ [ctor prec 11] .
  ***op __ : @TipoEnteroInt@ Num -> @EnteroInt@ [ctor] . 

  ***Declaración de la operacion de igualdad.
  op eq__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor comm prec 13] .
  ***Declaración de la operación Suma.
  op add__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor comm prec 13] .
  ***Declaración de la operación resta
  op sub__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 14] .
  ***Declaración de la operación de multiplicación.
  op mul__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor comm prec 14] .
  ***Declaración de la operación de división.
  op div__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 14] .
  ***Declaración de la operación resto.
  op rem__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 14] .
  ***Declaración de la operación menor
  op lt__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 13] .
  ***Declaración de la operación de exponente.
  op pow__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 14] .
  ***Declaración de la operación de raíz cuadrada.
  op isqrt_ : @Token@ -> @DeclaracionOp@ [ctor prec 14] .
  ***Declaración de la operación to_nat.
  op to-nat_ : @Token@ -> @DeclaracionOp@ [ctor prec 14] .
  ***Declaración de la operación to_(u)int32/64/128/256.
  ops to-int32 to-int64 to-int128 to-int256 to-uint32 to-uint64 to-uint128 to-uint256 : -> @TipoOpto@ [ctor] .
  op __ : @TipoOpto@ @Token@ -> @DeclaracionOp@ [ctor prec 14] . 

  ***STRINGS
  ***La operación eq ya está definida anteriormente para los enteros y como es la misma es la que usaremos.
  ***Declaración de la operacion de concatenar dos strings.
  op concat__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor comm prec 14] .
  ***Declaración de la operación de substring (string posición_inicio longitud_substring).
  op substr___ : @Token@ @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 14] .
  ***op substr___ : @Token@ Nat Nat -> @DeclaracionOp@ [ctor] .
  ***Declaración de la operacion to-string que convierte un elemento de tipo Intx/Uintx/BystrX/ByStr a string.
  op to-string_ : @Token@ -> @DeclaracionOp@ [ctor prec 14] .
  ***Declaración de la operacion strlen (devuelve la longitud del string).
  op strlen_ : @Token@ -> @DeclaracionOp@ [ctor prec 14] .

  ***HASHES
  op sha256hash_ : @Token@ -> @DeclaracionOp@ [ctor prec 14] .
  op schnorr-verify___ : @Token@ @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 14] . 
  op ecdsa-verify___ : @Token@ @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 14] .

  ***MAPAS
  sort @TipoClave@ @TipoValor@ @MapVacio@ @Map@ @DeclaracionOpMapI@ @posicion@ @ListaPosiciones@ .
  ***subsort @TipoEntero@ < @NombreTipo@ .
  subsort @NombreTipo@ < @TipoClave@ .
  subsort @NombreTipo@ @Par@  < @TipoValor@ .
  subsort @posicion@ < @ListaPosiciones@ .

  op Emp__ : @TipoClave@ @TipoValor@ -> @MapVacio@ [ctor prec 15] .
  op Emp__ : @TipoClave@ @Bubble@ -> @MapVacio@ [ctor prec 15] .
  op Map__ : @TipoClave@ @TipoValor@ -> @Map@ [ctor prec 15] .
  op Map__ : @TipoClave@ @Bubble@ -> @Map@ [ctor prec 15] .
  op [_] : @Token@ -> @posicion@ [ctor prec 18] .
  op __ : @ListaPosiciones@ @ListaPosiciones@ -> @ListaPosiciones@ [ctor assoc prec 19] .
  ***Definición operación insertar.
---   ***Funcional
  op put___ : @Token@ @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 19] .
  ***In-place.
  op __:=_ : @Token@ @ListaPosiciones@ @Token@ -> @DeclaracionOpMapI@ [ctor prec 19] .
  ***Definición operación obtener valor.
  ***Funcional
  op get__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 13] .
  ***In-place
  op _<-__ : @Token@ @Token@ @ListaPosiciones@ -> @DeclaracionOpMapI@ [ctor prec 19] .
  ***Definición operación contener.
  ***Funcional
  op contains__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 13] .
  ***In-place
  op _<-exists__ : @Token@ @Token@ @ListaPosiciones@ -> @DeclaracionOpMapI@ [ctor prec 19] .
  ***Definición operación eliminar.
  ***Funcional
  op remove__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 13] .
  ***In-place
  op delete__ : @Token@ @ListaPosiciones@ -> @DeclaracionOpMapI@ [ctor prec 19] .

  ***BNUM
  ***Definición número de bloques
  op BNum_ : Int -> @BNum@ [ctor] .
  ***Definción de operaciones
  ***La operación eq ya está definida para los enteros.
  ***Definición operación blt(menor o igual).
  op blt__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 14] .
  ***Declaración operación badd (suma un Bnum con un UintX).
  op badd__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 14] .
  ***Declaración operación bsub(resta de dos Bnums).
  op bsub__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 14] .

  ***Falta por meter los mapas, hashes y direcciones.

  ***DATOS ALGEBRAICOS
  ***Declaración option
  subsort @TipoEntero@ @Map@ < @NombreTipo@ .
  ops String ByStr32 ByStr33 ByStr20 BNum Bool Message Error ByStr ByStr64 Unit : -> @NombreTipo@ [ctor] .  ***Falta meter los enteros
  op Option_ : @NombreTipo@ -> @Option@ [ctor prec 13] .  ***A lo mejor hay que hacer un tipo declaracionOption para diferenciarlo.
  ***Constructoras option
  op None{_} : @NombreTipo@ -> @Option@ [ctor prec 13] .
  op None : -> @Option@ [ctor] .
  op Some{_}_ : @NombreTipo@ @Token@ -> @Option@ [ctor prec 13] . 
  op Some_ : @Token@ -> @Option@ [ctor prec 13] .

  ***Declaración Lista
  op List_ : @NombreTipo@ -> @Lista@ [ctor prec 13] .
  ***Constructoras de las listas
  op Nil{_} : @NombreTipo@ -> @Lista@ [ctor prec 13] .
  op Cons{_}__ : @NombreTipo@ @Token@ @Token@ -> @Lista@ [ctor prec 13] .

  ***Declaración Pares
  op Pair__ : @NombreTipo@ @NombreTipo@ -> @Par@ [ctor prec 13] .
  ***Constructora Pair
  op Pair{__}__ : @NombreTipo@ @NombreTipo@ @Token@ @Token@ -> @Par@ [ctor prec 13] .

  ***Declaración Nat
  op Nat : -> @Natural@ [ctor] .
  ***Constructoras de Nat
  op Zero : -> @Natural@ [ctor] .
  op Succ_ : @Token@ -> @Natural@ [ctor prec 13] .

  ***PARÁMETROS INMUTABLES
  sort @TipoParamInm@ @ParamInm@ @ListaParamInm@ @ParametrosInm@ .
  subsort @NombreTipo@ @Map@ @Option@ < @TipoParamInm@ .
  subsort @ParamInm@ < @ListaParamInm@ .

  ***ops ByStr20 BNum String ByStr32 Bool Message : -> @TipoParamInm@ [ctor] .
  ***op _:_ : String TipoParamInm -> ParamInmSolo [ctor] .
  op _:_ : @Token@ @TipoParamInm@ -> @ParamInm@ [ctor prec 15] .
  op _:_ : @Token@ @Bubble@ -> @ParamInm@ [ctor prec 15] .
  ***op vacio : -> ListaParamInm [ctor] .
  ***op _ : ParamInm -> ListaParamInm [ctor] .
  op lpv : -> @ListaParamInm@ [ctor] .
  op (_,_) : @ListaParamInm@ @ListaParamInm@ -> @ListaParamInm@ [ctor assoc prec 17 id: lpv] . 
  ***op <> : -> ParametrosInm [ctor] .
  ***op _ : @ListaParamInm@ -> @ParametrosInm@ [ctor] .
  --- ***op [_with_=>] : ParametrosInm OperacionBooleana -> Restriccion [ctor] .

  ***CAMPOS MODIFICABLES
  sort @ValorCampo@ @Campo_mod@ @ListaCamposMod@ .
  ***subsort @Entero@ @Option@ @Lista@ @Par@ @Natural@ String Bool < @ValorCampo@ .
  subsort @Entero@ @Option@ @Lista@ @Par@ @Natural@ @MapVacio@ Bool @Expresion@ String < @ValorCampo@ .
  ***subsort Bool < @ValorCampo@ .
  subsort @Campo_mod@ < @ListaCamposMod@ .
  op cv : -> @Campo_mod@ [ctor] .
  op field_=_ : @ParamInm@ @ValorCampo@ -> @Campo_mod@ [ctor prec 19] .
  op field_=_ : @ParamInm@ @ExpresionAplicarF@ -> @Campo_mod@ [ctor prec 19] .
  op __ : @ListaCamposMod@ @ListaCamposMod@ -> @ListaCamposMod@ [ctor assoc prec 20] .

  ***EXPRESIONES
  sort @TipoDato@ @Expresion@ @Operacion@ @ExpresionFuncion@ @ListaArgumentos@ @OperacionBuilt@ @ListaExpresiones@ @TipoOpcion@ @Opcion@
       @ListaOpciones@ @Expresiones@ @ExpresionMatch@ @ListaArg@ @ExpresionLet@ @ExpresionAplicarF@ .
  --- ***Entero String Bool ExpresionBuilt Map ByStr32 ByStr20 BNum Option Lista Par Natural Expresion
  subsort @Entero@ String @BNum@ @Option@ @Lista@ @Par@ @Natural@ @ExpresionFuncion@ @Expresion@ @ExpresionMatch@ @MapVacio@ @ExpresionAplicarF@ < @TipoDato@ .
  --- --- subsort Expresion DeclaracionOpBools DeclaracionOpInts < Operacion .
  subsort @Expresion@ @Lista@ @ExpresionFuncion@ @ExpresionMatch@ @Excepcion@ @Par@ < @Operacion@ .
  subsort @TipoEntero@ @NombreTipo@ @Par@ < @ListaArgumentos@ .
  subsort @DeclaracionOp@ @DeclaracionOpBools@  < @OperacionBuilt@ .
  subsort @ExpresionLet@ @ADTS@ < @ListaExpresiones@ . 
 *** subsort @Declaracion@ @ExpresionMatch@ < @Expresiones@ .
  subsort @ListaDeclaraciones@ @Entero@ @Expresion@ < @Expresiones@ .
  subsort @Option@ @Par@ Bool < @TipoOpcion@ .
  subsort @Opcion@ < @ListaOpciones@ .
  subsort @Token@ < @ListaArg@ .
  ***subsort @Bubble@ < @ExpresionAplicarF@ .

  op let_=_ : @Token@ @TipoDato@ -> @ExpresionLet@ [ctor prec 20]  .
  ***op let_=_ : @Token@ @Bubble@ -> @ExpresionLet@ [ctor prec 20]  .
  op let_=_in_ : @Token@ @TipoDato@ @Operacion@ -> @Expresion@ [ctor prec 20] .
  ***op let_ : @Expresion@ -> @Expresion@ [ctor prec 20] .
  ***op let_in_ : @Expresion@ @Operacion@ -> @Expresion@ [ctor prec 20] .
  --- ***Falta añadir los mensajes
  op fun(_)=>_ : @ParamInm@ @Operacion@ -> @ExpresionFuncion@ [ctor prec 20] .
  ***op __ : @ListaArg@ @ListaArg@ -> @ListaArg@ [ctor assoc prec 19] .
  op `(_`) :  @Bubble@ -> @ExpresionAplicarF@ [ctor prec 19] .
  ***op _=__ : @Token@ @Token@ @NeTokenList@ -> @Expresion@ [ctor prec 20] .
  --- --- op tfun'_=>_ : String Operacion -> Expresion [ctor] .
  ***op String : -> @ListaArgumentos@ [ctor] .
  op __ : @ListaArgumentos@ @ListaArgumentos@ -> @ListaArgumentos@ [ctor assoc prec 19] .
  op @__ : @Token@ @ListaArgumentos@ -> @Expresion@ [ctor prec 20] .  

  --- --- op [_] : String -> Argumento [ctor] .
  --- --- op __ : ListaArgumentos ListaArgumentos -> ListaArgumentos [ctor] .
  --- --- ***op builtin__ : OperacionBuilt ListaArgumentos -> ExpresionBuilt [ctor] . ***No es exactamente string (hay que cambiarlo).
  op builtin_ : @OperacionBuilt@ -> @Expresion@ [ctor prec 19] .

  op ev : -> @Expresiones@ [ctor] .
  op |_=>_ : @TipoOpcion@ @Expresiones@ -> @Opcion@ [ctor prec 20] .  ***La segunda entrada no sería un string sino un statement.
  ***op _=>_ : @Constructora@ @Expresiones@ -> @Opcion@ [ctor prec 20] .
  op |_=>_ : @Bubble@ @Expresiones@ -> @Opcion@ [ctor prec 20] .
  op |_=>_ : @TipoOpcion@ @Bubble@ -> @Opcion@ [ctor prec 20] .
  op ov : -> @ListaOpciones@ [ctor] .
  op __ : @ListaOpciones@ @ListaOpciones@ -> @ListaOpciones@ [ctor assoc prec 21] .
  op match_with_end : @Token@ @ListaOpciones@ -> @ExpresionMatch@ [ctor prec 21] .
  op __ : @ListaExpresiones@ @ListaExpresiones@ -> @ListaExpresiones@ [ctor assoc prec 22] .

  ***DECLARACIONES
  sort @Declaracion@ @Valor@ @ListaDeclaraciones@ .
  ***@Entero@ String DeclaracionFuncion EventoMsg ExpresionBuilt Option Lista Par Natural DeclaracionOpBools DeclaracionOpInts
  subsorts @Entero@ String @Option@ @Lista@ @Par@ @Natural@ @Evento@ @Expresion@ @Mensaje@ Bool @DeclaracionOpBools@ @ExpresionMatch@ @ExpresionAplicarF@ < @Valor@ .
  subsort @Declaracion@ @ExpresionMatch@ @DeclaracionOpMapI@ @Expresion@ @Error@ @ExpresionAplicarF@ < @ListaDeclaraciones@ .
  ***subsort @Expresiones@ @DeclaracionOpMapI@ @Expresion@ < @ListaDeclaraciones@ .

  op _<-_ : @Token@ @Token@  -> @Declaracion@ [ctor prec 19] .
  op _:=_ : @Token@ @Token@ -> @Declaracion@ [ctor prec 19] .
  op _<-&BLOCKNUMBER : @Token@ -> @Declaracion@ [ctor prec 19] .
  op _=_ : @Token@ @Valor@ -> @Declaracion@ [ctor prec 19] .
  ***op _=_ : @Token@ @Bubble@ -> @Declaracion@ [ctor prec 19] .
  ***op __ : @Token@ @ListaArgumentos@ -> @Declaracion@ [ctor] .
  op forall__ : @Token@ @Token@ -> @Declaracion@ [ctor prec 19] .
  op accept : -> @Declaracion@ [ctor] .
  op send_ : @Token@ -> @Declaracion@ [ctor prec 19] .
  op event_ : @Token@ -> @Declaracion@ [ctor prec 19] .

  op _;_ : @ListaDeclaraciones@ @ListaDeclaraciones@ -> @ListaDeclaraciones@ [ctor assoc prec 20] .

  ***TRANSICIONES Y PROCEDIMIENTOS
  sort @Transicion@ @ListaTransiciones@ @Procedimiento@ .
  subsort @Transicion@ @Procedimiento@ < @ListaTransiciones@ .

  op procedure_(_)_end : @Token@ @ListaParamInm@ @ListaDeclaraciones@ -> @Procedimiento@ [ctor prec 23] .
  op transition_(_)_end : @Token@ @ListaParamInm@ @ListaDeclaraciones@ -> @Transicion@ [ctor prec 23] .
  op tv : -> @ListaTransiciones@ [ctor] .
  op __ : @ListaTransiciones@ @ListaTransiciones@ -> @ListaTransiciones@ [ctor assoc prec 24] .

  ***COMUNICACIONES
  sort @NombreEvento@ @ListaCamposEvento@ @Evento@ @CampoEvento@ @TagMensaje@ @EnvioMensaje@ @CantidadMensaje@ @Mensaje@ @NombreExcepcion@ @Excepcion@ .
  subsort @CampoEvento@ < @ListaCamposEvento@ .
  ***Eventos
  op -eventname:_ : String -> @NombreEvento@ [ctor prec 12] .
  op _:_ : @Token@ @Token@ -> @CampoEvento@ [ctor prec 12] .
  ***op _:_ : @Token@ String -> @CampoEvento@ [ctor prec 12] .
  op lcv : -> @ListaCamposEvento@ [ctor] .
  op _;_ : @ListaCamposEvento@ @ListaCamposEvento@ -> @ListaCamposEvento@ [ctor assoc prec 13] .
  op {_;_} : @NombreEvento@ @ListaCamposEvento@ -> @Evento@ [ctor prec 14] .
  ***Mensajes
  op -tag:_ : String -> @TagMensaje@ [ctor prec 12] .
  op -recipient:_ : @Token@ -> @EnvioMensaje@ [ctor prec 12] .
  op -amount:_ : @Entero@ -> @CantidadMensaje@ [ctor prec 12] .
  op -amount:_ : @Token@ -> @CantidadMensaje@ [ctor prec 12] .
  ***op {_;_;_;_} : @TagMensaje@ @EnvioMensaje@ @CantidadMensaje@ @ListaCamposEvento@ -> @Mensaje@ [ctor prec 14] .
  op {_;_;_;_} : @TagMensaje@ @EnvioMensaje@ @CantidadMensaje@ @ListaCamposEvento@ -> @Mensaje@ [ctor prec 14] .

  op -exception:_ : String -> @NombreExcepcion@ [ctor prec 12] .
  op {_;_} : @NombreExcepcion@ @ListaCamposEvento@ -> @Excepcion@ [ctor prec 14] .

  ***LIBRERIA BOOLUTILS
  sort @DeclaracionOpBools@ .

  ops andb__ orb__ : @Token@ @Token@ -> @DeclaracionOpBools@ [ctor prec 14] .
  ops negb_ bool-to-string_ : @Token@ -> @DeclaracionOpBools@ [ctor prec 14] .
  ops _.andb__ _.orb__ : @Token@ @Token@ @Token@ -> @DeclaracionOpBools@ [ctor prec 14] .
  ops _.negb_ _.bool-to-string_ : @Token@ @Token@ -> @DeclaracionOpBools@ [ctor prec 14] .



  ***ADTS
  sort @ADTS@ @Constructora@ @Constructoras@ .
  subsort @Constructora@ < @Constructoras@ .
  op |_ : @Token@ -> @Constructora@ [ctor prec 15] .
  --- ops String ByStr32 ByStr20 BNum Bool : -> ListaArgumentos [ctor] .
  --- op __ : ListaArgumentos ListaArgumentos -> ListaArgumentos [ctor assoc] .
  --- op |_of_ : Qid ListaArgumentos -> Constructora [ctor] . 
  op __ : @Constructoras@ @Constructoras@ -> @Constructoras@ [ctor assoc prec 16] .
  op type_=_ : @Token@ @Constructoras@ -> @ADTS@ [ctor prec 17] .

  ***ERRORES
  sort @Error@ .
  op throw : -> @Error@ [ctor] .
  op throw_ : @Token@ -> @Error@ [ctor prec 19] .

  

  sort @NombreLibreria@ @NombreContrato@ @Libreria@ @LibImportar@ @Importacion@ @ListaImportar@ .
  subsort @LibImportar@ < @ListaImportar@ .

  op library_ : @Token@ -> @NombreLibreria@ [ctor] .
  op contract_ : @Token@ -> @NombreContrato@ [ctor] .
  ops BoolUtils IntUtils PairUtils ListUtils : -> @LibImportar@ [ctor] .
  op iv : -> @Importacion@ [ctor] .
  op __ : @ListaImportar@ @ListaImportar@ -> @ListaImportar@ [ctor assoc] .
  op import_ : @ListaImportar@ -> @Importacion@ [ctor] .
  op import_as_ : @LibImportar@ @Token@ -> @Importacion@ [ctor] .

  op __ : @NombreLibreria@ @ListaExpresiones@ -> @Libreria@ [ctor] .

 


 


  
  op scilla-version_______ : Nat @Importacion@ @Libreria@ @NombreContrato@ @ListaParamInm@ @ListaCamposMod@ @ListaTransiciones@ -> @Contrato@ [ctor] .
  ***op scilla-version___ : Nat @Importacion@ @Libreria@ -> @Contrato@ [ctor] .

endfm

fmod Programa is
  pr QID .
  pr QID-LIST .
  pr INT .
  sort DeclaracionOp TipoEntero Entero Contrato Igualdad .
  subsort DeclaracionOp Entero < Expresion .

  ***DATOS PRMITIVOS

  ***ENTEROS
  ***Declaración de entero (Nombre de su tipo y el valor), los uint los trato como naturales.
  ops Uint32 Uint64 Uint128 Uint256 Int32 Int64 Int128 Int256 : -> TipoEntero [ctor] .
  op __ : TipoEntero Int -> Entero [ctor prec 11] .
  ***op __ : @TipoEnteroInt@ Num -> @EnteroInt@ [ctor] . 

  ***Declaración de la operacion de igualdad.
  op _==._ : Qid Qid -> DeclaracionOp [ctor comm prec 13] .
  op _==._ : Int Int -> DeclaracionOp [ctor comm prec 13] .
  ***Declaración de la operación Suma.
  op _+._ : Qid Qid -> DeclaracionOp [ctor comm prec 13] .
  ***Declaración de la operación resta
  op _-_ : Qid Qid -> DeclaracionOp [ctor prec 14] .
  ***Declaración de la operación de multiplicación.
  op _*_ : Qid Qid -> DeclaracionOp [ctor comm prec 14] .
  ***Declaración de la operación de división.
  op _/_ : Qid Qid -> DeclaracionOp [ctor prec 14] .
  ***Declaración de la operación resto.
  op _%_ : Qid Qid -> DeclaracionOp [ctor prec 14] .
  ***Declaración de la operación menor
  op _<._ : Qid Qid -> DeclaracionOp [ctor prec 13] .
  ***Declaración de la operación de exponente.
  op _^_ : Qid Qid -> DeclaracionOp [ctor prec 14] .
  ***Declaración de la operación de raíz cuadrada.
  op raiz_ : Qid -> DeclaracionOp [ctor prec 14] .

  op cv : -> Contrato [ctor] .
  op __ : Contrato Contrato -> Contrato [ctor id: cv] .
  ***Declaración de la operación to_nat.
  --- op to-nat_ : @Token@ -> @DeclaracionOp@ [ctor prec 14] .
  --- ***Declaración de la operación to_(u)int32/64/128/256.
  --- ops to-int32 to-int64 to-int128 to-int256 to-uint32 to-uint64 to-uint128 to-uint256 : -> @TipoOpto@ [ctor] .
  --- op __ : @TipoOpto@ @Token@ -> @DeclaracionOp@ [ctor prec 14] . 

  ***STRINGS
  ***La operación eq ya está definida anteriormente para los enteros y como es la misma es la que usaremos.
  ***Declaración de la operacion de concatenar dos strings.
  op _++_ : Qid Qid -> DeclaracionOp [ctor comm prec 14] .
  ***Declaración de la operación de substring (string posición_inicio longitud_substring).
  op substr___ : Qid Qid Qid -> DeclaracionOp [ctor prec 14] .
  ***op substr___ : @Token@ Nat Nat -> @DeclaracionOp@ [ctor] .
  ***Declaración de la operacion to-string que convierte un elemento de tipo Intx/Uintx/BystrX/ByStr a string.
  op to-string_ : Qid -> DeclaracionOp [ctor prec 14] .
  ***Declaración de la operacion strlen (devuelve la longitud del string).
  op length_ : Qid -> DeclaracionOp [ctor prec 14] .

  ***HASHES
  sort Byte ByStr20 .
  subsort Byte < ByStr20 .
  op a b c d e f 1 2 3 4 5 6 7 8 9 : -> Byte [ctor] .
  op __ : ByStr20 ByStr20 -> ByStr20 [ctor] .
  op sha256hash_ : Qid -> DeclaracionOp [ctor prec 14] .
  op schnorr-verify___ : Qid Qid Qid -> DeclaracionOp [ctor prec 14] . 
  op ecdsa-verify___ : Qid Qid Qid -> DeclaracionOp [ctor prec 14] .

  ***MAPAS
  sort TipoClave TipoValor MapVacio Map DeclaracionOpMapI posicion ListaPosiciones Clave .
  ***subsort @TipoEntero@ < @NombreTipo@ .
  subsort NombreTipo < TipoClave .
  subsort NombreTipo Par < TipoValor .
  subsort posicion < ListaPosiciones .
  subsort Bool Par < Clave .

  op Emp__ : TipoClave TipoValor -> MapVacio [ctor prec 15] .
  op Emp__ : TipoClave QidList -> MapVacio [ctor prec 15] .
  op Map__ : TipoClave TipoValor -> Map [ctor prec 15] .
  op Map__ : TipoClave QidList -> Map [ctor prec 15] .
  op posicion_ : Qid -> posicion [ctor prec 18] .
  op __ : ListaPosiciones ListaPosiciones -> ListaPosiciones [ctor assoc prec 19] .
  ***Definición operación insertar.
---   ***Funcional
  op put___ : Qid Qid Qid -> DeclaracionOp [ctor prec 19] .
  ***In-place.
  op insertar___ : Qid ListaPosiciones Qid -> DeclaracionOpMapI [ctor prec 19] .
  ***Definición operación obtener valor.
  ***Funcional
  op get__ : Qid Qid -> DeclaracionOp [ctor prec 13] .
  ***In-place
  op obtener___ : Qid Qid ListaPosiciones -> DeclaracionOpMapI [ctor prec 19] .
  ***Definición operación contener.
  ***Funcional
  op contains__ : Qid Qid -> DeclaracionOp [ctor prec 13] .
  ***In-place
  op existe___ : Qid Qid ListaPosiciones -> DeclaracionOpMapI [ctor prec 19] .
  ***Definición operación eliminar.
  ***Funcional
  op remove__ : Qid Qid -> DeclaracionOp [ctor prec 13] .
  ***In-place
  op delete__ : Qid ListaPosiciones -> DeclaracionOpMapI [ctor prec 19] .

  ***BNUM
  sort BNum .
  ***Definición número de bloques
  op BNum_ : Int -> BNum [ctor] .
  ***Definción de operaciones
  ***La operación eq ya está definida para los enteros.
  ***Definición operación blt(menor o igual).
  ***Se usa los de los enteros.
  --- op blt__ : Qid Qid -> DeclaracionOp [ctor prec 14] .
  --- ***Declaración operación badd (suma un Bnum con un UintX).
  --- op badd__ : Qid Qid -> DeclaracionOp [ctor prec 14] .
  --- ***Declaración operación bsub(resta de dos Bnums).
  --- op bsub__ : Qid Qid -> DeclaracionOp [ctor prec 14] .

  ***DATOS ALGEBRAICOS
  ***Declaración option
  sort NombreTipo Option Lista Par Natural .
  subsort TipoEntero Map < NombreTipo .
  ops String ByStr32 ByStr33 ByStr20 BNum Bool Message Error ByStr ByStr64 Unit : -> NombreTipo [ctor] .  ***Falta meter los enteros
  op Option_ : NombreTipo -> Option [ctor prec 13] .  ***A lo mejor hay que hacer un tipo declaracionOption para diferenciarlo.
  ***Constructoras option
  op None{_} : NombreTipo -> Option [ctor prec 13] .
  op None : -> Option [ctor] .
  op Some__ : NombreTipo Qid -> Option [ctor prec 13] . 
  op Some_ : Qid -> Option [ctor prec 13] .

  ***Declaración Lista
  op List_ : NombreTipo -> Lista [ctor prec 13] .
  ***Constructoras de las listas
  op Nil{_} : NombreTipo -> Lista [ctor prec 13] .
  op Cons___ : NombreTipo Qid Qid -> Lista [ctor prec 13] .

  ***Declaración Pares
  op Pair__ : NombreTipo NombreTipo -> Par [ctor prec 13] .
  ***Constructora Pair
  op Pair____ : NombreTipo NombreTipo Qid Qid -> Par [ctor prec 13] .

  ***Declaración Nat
  op Nat : -> Natural [ctor] .
  ***Constructoras de Nat
  op Zero : -> Natural [ctor] .
  op Sucesor_ : Qid -> Natural [ctor prec 13] .

  ***PARÁMETROS INMUTABLES
  sort TipoParamInm ParamInm ListaParamInm ParametrosInm .
  subsort NombreTipo Map Option < TipoParamInm .
  subsort ParamInm < ListaParamInm .

  ***ops ByStr20 BNum String ByStr32 Bool Message : -> @TipoParamInm@ [ctor] .
  ***op _:_ : String TipoParamInm -> ParamInmSolo [ctor] .
  op _:_ : Qid TipoParamInm -> ParamInm [ctor prec 15] .
  op _:_ : Qid QidList -> ParamInm [ctor prec 15] .
  op _:_ : Qid Qid -> ParamInm [ctor prec 15] .
  ***op vacio : -> ListaParamInm [ctor] .
  ***op _ : ParamInm -> ListaParamInm [ctor] .
  op lpv : -> ListaParamInm [ctor] .
  op (_,_) : ListaParamInm ListaParamInm -> ListaParamInm [ctor assoc prec 17] . 
  ***op <> : -> ParametrosInm [ctor] .
  ***op _ : @ListaParamInm@ -> @ParametrosInm@ [ctor] .
  --- ***op [_with_=>] : ParametrosInm OperacionBooleana -> Restriccion [ctor] .

  
  ***CAMPOS MODIFICABLES
  sort ValorCampo Campo_mod ListaCamposMod .
  ***subsort @Entero@ @Option@ @Lista@ @Par@ @Natural@ String Bool < @ValorCampo@ .
  subsort Entero Option Lista Par Natural MapVacio Bool Expresion String  < ValorCampo .
  ***subsort Bool < ValorCampo .
  subsort Campo_mod < ListaCamposMod .
  op cv : -> Campo_mod [ctor] .
  op campo_=_ : ParamInm ValorCampo -> Campo_mod [ctor prec 19] .
  op campo_=_ : ParamInm ExpresionAplicarF -> Campo_mod [ctor prec 19] .
  op lcmv : -> ListaCamposMod [ctor] .
  op __ : ListaCamposMod ListaCamposMod -> ListaCamposMod [ctor assoc prec 20 id: lcmv] .

  ***EXPRESIONES
  sort TipoDato Expresion Operacion ExpresionFuncion ListaArgumentos OperacionBuilt ListaExpresiones TipoOpcion Opcion
       ListaOpciones Expresiones ExpresionMatch ListaArg ExpresionLet ExpresionAplicarF ExpresionArr .
  --- ***Entero String Bool ExpresionBuilt Map ByStr32 ByStr20 BNum Option Lista Par Natural Expresion
  subsort Entero String BNum Option Lista Par Natural ExpresionFuncion Expresion ExpresionMatch MapVacio ExpresionAplicarF Bool < TipoDato .
  --- --- subsort Expresion DeclaracionOpBools DeclaracionOpInts < Operacion .
  subsort Expresion Lista ExpresionFuncion ExpresionMatch Excepcion Par Option DeclaracionOpBools < Operacion .
  subsort TipoEntero NombreTipo Par < ListaArgumentos .
  subsort DeclaracionOp DeclaracionOpBools  < OperacionBuilt .
  subsort ExpresionLet ADTS < ListaExpresiones . 
 *** subsort Declaracion ExpresionMatch < Expresiones .
  subsort ListaDeclaraciones Entero Option < Expresiones .
  subsort Option Par Bool < TipoOpcion .
  subsort Opcion < ListaOpciones .
  subsort Qid < ListaArg .
  ***subsort Bubble < ExpresionAplicarF .

  op let__ : Qid TipoDato -> ExpresionLet [ctor prec 20]  .
  ***op let_=_ : Token Bubble -> ExpresionLet [ctor prec 20]  .
  op let__in_ : Qid TipoDato Operacion -> Expresion [ctor prec 20] .
  ***op let_ : Expresion -> Expresion [ctor prec 20] .
  ***op let_in_ : Expresion Operacion -> Expresion [ctor prec 20] .
  --- ***Falta añadir los mensajes
  op funcion__ : ParamInm Operacion -> ExpresionFuncion [ctor prec 20] .
  ***op __ : ListaArg ListaArg -> ListaArg [ctor assoc prec 19] .
  op aplicarF_ :  QidList -> ExpresionAplicarF [ctor prec 19] .
  ***op _=__ : Token Token NeTokenList -> Expresion [ctor prec 20] .
  --- --- op tfun'_=>_ : String Operacion -> Expresion [ctor] .
  ***op String : -> ListaArgumentos [ctor] .
  op lav : -> ListaArgumentos [ctor] .
  --- op __ : ListaArgumentos ListaArgumentos -> ListaArgumentos [ctor assoc prec 20] .
  --- op @__ : Qid ListaArgumentos -> ExpresionArr [ctor prec 20] .  

  --- --- op [_] : String -> Argumento [ctor] .
  --- --- op __ : ListaArgumentos ListaArgumentos -> ListaArgumentos [ctor] .
  --- --- ***op builtin__ : OperacionBuilt ListaArgumentos -> ExpresionBuilt [ctor] . ***No es exactamente string (hay que cambiarlo).
  op builtin_ : OperacionBuilt -> Expresion [ctor prec 19] .

  op ev : -> Expresiones [ctor] .
  ***op __ : Expresiones Expresiones -> Expresiones [ctor assoc] .
  op opcionMatch__ : TipoOpcion Expresiones -> Opcion [ctor prec 20] .  ***La segunda entrada no sería un string sino un statement.
  ***op _=>_ : Constructora Expresiones -> Opcion [ctor prec 20] .
  op opcionMatch__ : QidList Expresiones -> Opcion [ctor prec 20] .
  op opcionMatch__ : TipoOpcion QidList -> Opcion [ctor prec 20] .
  op ov : -> ListaOpciones [ctor] .
  op __ : ListaOpciones ListaOpciones -> ListaOpciones [ctor assoc prec 21] .
  op match__ : Qid ListaOpciones -> ExpresionMatch [ctor prec 21] .
  op lev : -> ListaExpresiones [ctor] .
  op __ : ListaExpresiones ListaExpresiones -> ListaExpresiones [ctor assoc prec 22 id: lev] .

  ***DECLARACIONES
  sort Declaracion Valor ListaDeclaraciones .
  ***Entero String DeclaracionFuncion EventoMsg ExpresionBuilt Option Lista Par Natural DeclaracionOpBools DeclaracionOpInts
  subsorts Entero String Option Lista Par Natural Evento Expresion Mensaje Bool DeclaracionOpBools ExpresionMatch ExpresionAplicarF < Valor .
  subsort Declaracion ExpresionMatch DeclaracionOpMapI Expresion Error ExpresionAplicarF < ListaDeclaraciones .
  ***subsort Expresiones DeclaracionOpMapI Expresion < ListaDeclaraciones .

  op guardar__ : Qid Qid  -> Declaracion [ctor prec 19] .
  op actualizar__ : Qid Qid -> Declaracion [ctor prec 19] .
  op _<-&BLOCKNUMBER : Qid -> Declaracion [ctor prec 19] .
  op _=_ : Qid Valor -> Declaracion [ctor prec 19] .
  ***op _=_ : Token Bubble -> Declaracion [ctor prec 19] .
  ***op __ : Token ListaArgumentos -> Declaracion [ctor] .
  op forall__ : Qid Qid -> Declaracion [ctor prec 19] .
  op accept : -> Declaracion [ctor] .
  op enviar_ : Qid -> Declaracion [ctor prec 19] .
  op evento_ : Qid -> Declaracion [ctor prec 19] .
  op ldv : -> ListaDeclaraciones [ctor] .
  op __ : ListaDeclaraciones ListaDeclaraciones -> ListaDeclaraciones [ctor assoc prec 20 id: ldv] .

  ***TRANSICIONES Y PROCEDIMIENTOS
  sort Transicion ListaTransiciones Procedimiento .
  subsort Transicion Procedimiento < ListaTransiciones .

  op procedimiento___end : Qid ListaParamInm ListaDeclaraciones -> Procedimiento [ctor prec 23] .
  op transicion___end : Qid ListaParamInm ListaDeclaraciones -> Transicion [ctor prec 23] .
  op ltv : -> ListaTransiciones [ctor] .
  op __ : ListaTransiciones ListaTransiciones -> ListaTransiciones [ctor assoc prec 24 id: ltv] .

  ***COMUNICACIONES
  sort NombreEvento ListaCamposEvento Evento CampoEvento TagMensaje EnvioMensaje CantidadMensaje Mensaje NombreExcepcion Excepcion .
  subsort ParamInm < ListaCamposEvento .
  ***Eventos
  op -eventname:_ : String -> NombreEvento [ctor prec 12] .
  ***op _:_ : Qid Qid -> CampoEvento [ctor prec 12] .
  ***op _:_ : Qid String -> CampoEvento [ctor prec 12] .
  op lcv : -> ListaCamposEvento [ctor] .
  op _;_ : ListaCamposEvento ListaCamposEvento -> ListaCamposEvento [ctor assoc prec 13] .
  op {_;_} : NombreEvento ListaCamposEvento -> Evento [ctor prec 14] .
  ***Mensajes
  op -tag:_ : String -> TagMensaje [ctor prec 12] .
  op dirEnvio_ : Qid -> EnvioMensaje [ctor prec 12] .
  op cantidadEnvio_ : Entero -> CantidadMensaje [ctor prec 12] .
  op cantidadEnvio_ : Qid -> CantidadMensaje [ctor prec 12] .
  ***op {_;_;_;_} : TagMensaje EnvioMensaje CantidadMensaje ListaCamposEvento -> Mensaje [ctor prec 14] .
  op {_;_;_;_} : TagMensaje EnvioMensaje CantidadMensaje ListaCamposEvento -> Mensaje [ctor prec 14] .

  op -exception:_ : String -> NombreExcepcion [ctor prec 12] .
  op {_;_} : NombreExcepcion ListaCamposEvento -> Excepcion [ctor prec 14] .

  ***LIBRERIA BOOLUTILS
  sort DeclaracionOpBools .

  ops _and_ _or_ : Qid Qid -> DeclaracionOpBools [ctor prec 14] .
  ops negb_ bool-to-string_ : Qid -> DeclaracionOpBools [ctor prec 14] .
  ops _and.__ _or.__ : Qid Qid Qid -> DeclaracionOpBools [ctor prec 14] .
  ops negb.__ bool-to-string.__ : Qid Qid -> DeclaracionOpBools [ctor prec 14] .



  ***ADTS
  sort ADTS Constructora Constructoras .
  subsort Constructora < Constructoras .
  op |_ : Qid -> Constructora [ctor prec 15] .
  --- ops String ByStr32 ByStr20 BNum Bool : -> ListaArgumentos [ctor] .
  --- op __ : ListaArgumentos ListaArgumentos -> ListaArgumentos [ctor assoc] .
  --- op |_of_ : Qid ListaArgumentos -> Constructora [ctor] . 
  op __ : Constructoras Constructoras -> Constructoras [ctor assoc prec 16] .
  op tipo__ : Qid Constructoras -> ADTS [ctor prec 17] .

  ***ERRORES
  sort Error .
  op throw : -> Error [ctor] .
  op throw_ : Qid -> Error [ctor prec 19] .

  

  sort NombreLibreria NombreContrato Libreria LibImportar Importacion ListaImportar .
  subsort LibImportar < ListaImportar .

  op NombreLibreria_ : Qid -> NombreLibreria [ctor] .
  op NombreContrato_ : Qid -> NombreContrato [ctor] .
  ops BoolUtils IntUtils PairUtils ListUtils : -> LibImportar [ctor] .
  op iv : -> Importacion [ctor] .
  op __ : ListaImportar ListaImportar -> ListaImportar [ctor assoc] .
  op import_ : ListaImportar -> Importacion [ctor] .
  op import__ : LibImportar Qid -> Importacion [ctor] .

  op __ : NombreLibreria ListaExpresiones -> Libreria [ctor] .

 


 


  
  op Contrato_______ : Nat Importacion Libreria NombreContrato ListaParamInm ListaCamposMod ListaTransiciones -> Contrato [ctor] .


endfm



fmod MEMORIA is
  pr Programa .
  pr MAP{Nat, Bool} .
  ***pr MAP{Nat, Par} .

  sort Memoria Variable Val Pareja PilaMemoria ParejaFuncion letIn AmbitoAplicacion memoriaTransicion Opciones ListaT memoriaLetIn ParejaAct ParejaImportacion
       ParejaAplicar ParejaPar ParejaSome ParejaNil ParejaCons . 
  subsort Qid < Variable .
  subsort DeclaracionOp Entero String PilaMemoria ExpresionFuncion ParamInm Expresion ParejaFuncion Option Evento String Bool Lista MapVacio < Val .
  subsort Pareja < Memoria .
  subsort Option < AmbitoAplicacion .
  subsort memoriaTransicion memoriaLetIn ParejaAct ParejaImportacion ParejaAplicar ParejaPar ParejaSome ParejaNil ParejaCons < Pareja .
  ***subsort ListaDeclaraciones Pareja < ListaT .
  ***subsort ListaDeclaraciones Pareja < Opciones .
  
  ***op [_] : Val -> Pareja [ctor] .
  op [_] : Transicion -> Pareja [ctor] .
  op [_] : Declaracion -> Pareja [ctor] .
  op [_] : DeclaracionOp -> Pareja [ctor] .
  op [_] : Int -> Pareja [ctor] .
  op [_] : ExpresionMatch -> Pareja [ctor] .
  op [_] : Bool -> Pareja [ctor] .
  op [_=>_,_] : Variable Val AmbitoAplicacion -> letIn [ctor] .
 *** op Funcion[_,_] : ParamInm Expresion -> ParejaFuncion [ctor] .
  op Funcion[_,_] : Memoria Memoria -> ParejaFuncion [ctor] .
  op Actualizar[_,_] : Variable Qid -> ParejaAct [ctor] .
  op Actualizar[_,_] : Variable ValorCampo -> ParejaAct [ctor] .
  op Importaciones[_] : ListaImportar -> ParejaImportacion [ctor] .
  op AplicarF[_,_] : Variable QidList -> ParejaAplicar [ctor] .
  op AplicarF[_] : Variable -> ParejaAplicar [ctor] .
  op Par[_,_] : Qid Qid -> ParejaPar [ctor] .
  op Some[_] : Qid -> ParejaSome [ctor] .
  op Nil[_] : NombreTipo -> ParejaNil [ctor] .
  op Cons[_,_] : Qid Qid -> ParejaCons [ctor] .
  
  op [_=>_] : Variable Val -> Pareja [ctor] .
  op [_=>_] : Variable Qid -> Pareja [ctor] .
  op [_=>_] : Variable ListaOpciones -> Pareja [ctor] .
  op [_=>_] : Variable Int -> Pareja [ctor] .
  op [_=>_] : Variable Memoria -> Pareja [ctor] .
  op [_=>_] : TipoOpcion Memoria -> Pareja [ctor] .
  op [_=>_] : TipoOpcion ListaDeclaraciones -> Pareja [ctor] .
  op soloOpcion[_=>_] : TipoOpcion Memoria -> Pareja [ctor] .
  op [_=>_] : Variable TipoParamInm -> Pareja [ctor] .
  op [_=>_] : Variable ValorCampo -> Pareja [ctor] .
  ***op [_=>_] : Variable Map{Nat, Par} -> Pareja [ctor] .
  op [_=>_] : Variable Map{Nat, Bool} -> Pareja [ctor] .
  op [_=>_,_] : Variable Evento Memoria -> Pareja [ctor] .
  op [_=>_,_] : Variable TipoDato Memoria -> Pareja [ctor] .
  op [_=>_,_] : Variable Int Memoria -> Pareja [ctor] .
  op Existe[_=>_,_] : Variable Variable ListaPosiciones -> Pareja [ctor] .
  op Insertar[_=>_,_] : Variable Variable ListaPosiciones -> Pareja [ctor] .
  op Eliminar[_,_] : Qid ListaPosiciones -> Pareja [ctor] .
  op NumBloque[_] : Qid -> Pareja [ctor] .
  op [_,_,_,_,_] : Variable ListaParamInm ListaDeclaraciones Memoria Memoria -> memoriaTransicion [ctor] .
  op [_,_,_] : Variable Memoria Memoria -> memoriaTransicion [ctor] .
  ***op [_,_,_] : Variable TipoDato Operacion -> memoriaLetIn [ctor] .
  ***op [_,_,_] : Variable ListaParamInm ListaT -> memoriaTransicion [ctor] .
  op mv : -> Memoria [ctor] .
  op __ : Memoria Memoria -> Memoria [ctor assoc id: mv] .
 
  op pv : -> PilaMemoria [ctor] .
  op apila : Memoria PilaMemoria -> PilaMemoria [ctor] .

  vars x x1 x2 : Qid .
  var TD : TipoDato .
  var Op : Operacion .
  var E : Expresion .
  var OPB : OperacionBuilt .
  var TE : TipoEntero .
  var IN : Int .
  var V : Valor .
  var S : String .
  var LCE : ListaCamposEvento .
  var PI : ParamInm .
  vars M M1 M2 M3 M4 M5 : Memoria .
  var LPI : ListaParamInm .
  var TPI : TipoParamInm .
  var LOP : ListaOpciones .
  var TOP : TipoOpcion .
  var EXPS : Expresiones .
  var OPC : Opcion .
  var D : Declaracion .
  var LD : ListaDeclaraciones .
  var VAL : Val .
  var xl : QidList .
  var LP : ListaPosiciones .
  vars NT NT1 : NombreTipo .


  op esEntero : Val -> Bool [ctor] .
  eq esEntero(TE IN) = true .
  eq esEntero(VAL) = false [owise] .

  op almacenar : Expresion -> Memoria [ctor] .
  op almacenar : Declaracion -> Memoria [ctor] .
  op almacenar : ExpresionMatch -> Memoria [ctor] .
  op almacenar : ParamInm -> Memoria [ctor] .
  op almacenar : Bool -> Memoria [ctor] .

  eq almacenar(lpv) = mv .
  eq almacenar(lcv) = mv .
  eq almacenar(true) = [true] .
  eq almacenar(builtin OPB) = [OPB] .
  eq almacenar(guardar x x2) = [x => x2] .
  eq almacenar(insertar x LP x2) = Insertar[x => x2, LP] .
  eq almacenar(evento x) = ['evento => x] .
  eq almacenar(enviar x) = ['enviar => x] .
  eq almacenar(accept) = [accept] .
  eq almacenar(OPB) = [OPB] .
  eq almacenar(Pair NT NT1 x x1) = Par[x,x1] .
  eq almacenar(Some NT x) = Some[x] .
  ***eq almacenar(Nil{NT}) = Nil[NT] .
  eq almacenar(Cons NT x x2) = Cons[x,x2] .
  eq almacenar(x <-&BLOCKNUMBER) = NumBloque[x] .
  eq almacenar(x : TPI) = [x => TPI] .
  eq almacenar(x : x2) = [x => x2] .
  eq almacenar(PI , LPI) = almacenar(PI) almacenar(LPI) .
  eq almacenar(PI ; LCE) = almacenar(PI) almacenar(LCE) .
  eq almacenar(aplicarF x) = AplicarF[x] .
  eq almacenar(aplicarF (x xl)) = AplicarF[x , xl] .
  eq almacenar({-tag: S ; dirEnvio x ; cantidadEnvio TE IN ; LCE}) = ['tag => S] ['dirEnvio => x] ['cantidadEnvio => IN] almacenar(LCE) .
  eq almacenar({-tag: S ; dirEnvio x ; cantidadEnvio x1 ; LCE}) = ['tag => S] ['dirEnvio => x] ['cantidadEnvio => x1] almacenar(LCE) .
  eq almacenar({-eventname: S ; LCE}) = ['eventname => S] almacenar(LCE) .
  eq almacenar(x = V) = [x => almacenar(V)] .
  eq almacenar(actualizar x x2) = Actualizar[x, x2] .
  eq almacenar(let x TE IN in Op) = [x => IN , almacenar(Op)] .
  ceq almacenar(let x TD in Op) = [x => TD , almacenar(Op)] 
      if not(esEntero(TD)) .

  op almacenarMatch : ExpresionMatch -> Memoria [ctor] .
  op almacenarMatch : Opcion -> Memoria [ctor] .
  eq almacenarMatch(ldv) = mv .
  eq almacenarMatch(insertar x LP x2 LD) = Insertar[x => x2, LP] almacenarMatch(LD) .
  eq almacenarMatch(delete x LP LD) = Eliminar[x, LP] almacenarMatch(LD) .
  eq almacenarMatch(D LD) = almacenar(D) almacenarMatch(LD) .
  eq almacenarMatch(opcionMatch TOP EXPS) = [TOP => almacenarMatch(EXPS)] .
  eq almacenarMatch(OPC LOP) = almacenarMatch(OPC) almacenarMatch(LOP) .
  eq almacenarMatch(match x LOP) = [x => almacenarMatch(LOP)] .

  op sustituir : Memoria Memoria -> Memoria [ctor] .
  eq sustituir(M [x => IN] M2, M3 [x2 => x] M4) = M3 [x2 => IN] M4 .
  eq sustituir(M [x => V] M2, M3 [x2 => x] M4) = M3 [x2 => V] M4 .
  eq sustituir(M [x => M5] M2, M3 [x2 => x] M4) = M3 [x2 => M5] M4 .
  eq sustituir(M, M1 [x => M2] M3) = M1 [x => sustituir(M, M2)] M3 .
  eq sustituir(M, M1 [TOP => M2] M3) = M1 [TOP => sustituir(M, M2)] sustituir(M,M3) .
  ***eq sustituir(M, soloOpcion[TOP => M2]) = [TOP => sustituir(M, M2)] .
  eq sustituir(M, M2) = M2 [owise] .

  op sustituirMismoNivel : Memoria -> Memoria [ctor] .
  eq sustituirMismoNivel(M [x => M2] M3 [x2 => x] M4) = M [x => M2] M3 [x2 => M2] M4 .
  eq sustituirMismoNivel(M [x => M2] M3) = M [x => sustituirMismoNivel(M2)] M3 .
  eq sustituirMismoNivel(M [TOP => M2] M3) = M [TOP => sustituirMismoNivel(M2)] M3  .
  eq sustituirMismoNivel(M) = M [owise] .

  --- sort prueba .
  --- subsort Qid TipoOpcion < Prueba .
  --- var P : Prueba .
  op tenerModificar : Memoria -> Bool [ctor] .
  eq tenerModificar(M[x => x2]M1) = true  .
  ***eq tenerModificar(M[TOP => M2]M1) = tenerModificar(M2) .
  ***eq tenerModificar(soloOpcion[TOP => M2]) = tenerModificar(M2) .
  eq tenerModificar(M[x => M2]M1) = tenerModificar(M2) .
  eq tenerModificar(M) = false [owise] .

  op tenerModificar2 : Memoria -> Bool [ctor] .
  eq tenerModificar2(M[x => x2]M1) = true  .
  eq tenerModificar2(M[x => M2]M1) = tenerModificar(M2) .
  ***eq tenerModificar2(soloOpcion[TOP => M2]) = tenerModificar(M2) .
  eq tenerModificar2(M[TOP => M2]M1) = tenerModificar(M2) .
 *** eq tenerModificar2(M[x => M2]M1) = tenerModificar(M2) .
  eq tenerModificar2(M) = false [owise] .
  
  
  

endfm

fmod SISTEMA is
  pr MEMORIA .
  sort Sistema Memorias .

  op [_,_,_] : Contrato Memoria Memoria -> Sistema [ctor] .
  op [_,_] : Memoria Memoria -> Memorias [ctor] .
  op init : -> Sistema .
  eq init = [Contrato 0 iv NombreLibreria 'HelloWorld let 'one_msg funcion 'msg : Message let 'nil_msg Nil{Message} in
   Cons Message 'msg 'nil_msg let 'S1 Uint32 3 let 'S2 Uint32 2 NombreContrato 'HelloWorld ('owner : ByStr20) 
            campo 'welcome_msg : Uint32 = Uint32 1 transicion 'setHello ('msg : String) 'is_owner = builtin 1 ==. 2 end   , mv, mv] .

  --- eq init = [let 'S1 Uint32 1 in let 'b Uint32 2 in builtin 'S1 + 'b , mv, mv] .

endfm 

***Modulo de reglas para almacenar en la memoria
mod REGLAS is 
  pr SISTEMA .
  
  var M M' M1 M2 M3 M4 M5 M6 M7 M8 M10 M11 : Memoria .
  var x x' x2 x3 : Qid .
  vars E E' : Entero .
  var C : Contrato .
  var N : Nat .
  var I : Importacion .
  var L : Libreria .
  var NC : NombreContrato .
  var LPI : ListaParamInm .
  var LCM : ListaCamposMod .
  var LT : ListaTransiciones .
  var NL : NombreLibreria .
  var LE : ListaExpresiones .
  var TP : TipoParamInm .
  var V : Val .
  var P : PilaMemoria .
  var LD : ListaDeclaraciones .
  var PI : ParamInm .
  var Op : Operacion .
  var TD : TipoDato .
  var T : Transicion .
  var VL : Valor .
  var LOP : ListaOpciones .
  var D : Declaracion .
  var OPB : OperacionBuilt .
  var TE : TipoEntero .
  vars IN IN1 : Int .
  var S : String .
  var LCE : ListaCamposEvento .
  var EXP : Expresion .
  var EM : ExpresionMatch .
  var B : Bool .
  var LIMP : ListaImportar .
  vars VCP VCP1 : ValorCampo .
  var APF : ExpresionAplicarF .
  var LP : ListaPosiciones .
  vars NT NT1 : NombreTipo .
  var TV : TipoValor .

  ***Regla para guardar las importaciones
  rl[Contrato N import LIMP NL LE NC LPI LCM LT ,M, M'] => [Contrato N iv NL LE NC LPI LCM LT ,M Importaciones[LIMP], M'] .
  ***Regla para guardar una variable de un let en la memoria
  crl[Contrato N I NL let x V LE NC LPI LCM LT ,M, M'] => [Contrato N I NL LE NC LPI LCM LT ,M[x => V], M'] 
     if not(esEntero(V)) .
  rl[Contrato N I NL let x TE IN LE NC LPI LCM LT ,M, M'] => [Contrato N I NL LE NC LPI LCM LT ,M[x => IN], M'] .
  
  ***Regla para guardar los parametros inmutables en la memoria.
  crl[Contrato N I NL LE NC LPI LCM LT,M, M'] => [Contrato N I NL LE NC lpv LCM LT,M almacenar(LPI), M'] 
    if not(LPI == lpv) .
  ***Regla para quitar el tipo del entero de la memoria
  ***rl[Contrato N I NL LE NC LPI campo x : TP = TE IN LCM LT,M, M'] => [Contrato N I NL LE NC LPI LCM LT,M[x => IN], M'] .
  ***Regla para guardar un campo en la memoria
  rl[Contrato N I NL LE NC LPI campo x : TP = APF LCM LT,M, M'] => [Contrato N I NL LE NC LPI LCM LT,M[x => almacenar(APF)], M'] .
  rl[Contrato N I NL LE NC LPI campo x : TP = None{NT} LCM LT,M, M'] => [Contrato N I NL LE NC LPI LCM LT,M[x => None], M'] .
  rl[Contrato N I NL LE NC LPI campo x : TE = TE IN LCM LT,M, M'] => [Contrato N I NL LE NC LPI LCM LT,M[x => IN], M'] .
  crl[Contrato N I NL LE NC LPI campo x : TP = VCP LCM LT,M, M'] => [Contrato N I NL LE NC LPI LCM LT,M[x => VCP], M'] 
     if not(esEntero(VCP)) .
  rl[C,M [x => Emp NT TV]M1, M'] => [C,M[x => empty]M1, M'] .
  
  
  ***Regla para almacenar una funcion en la memoria.
  rl[C , M2[x => funcion PI Op]M , M'] => [C , M2[x => Funcion[almacenar(PI), almacenar(Op)]]M , M'] .
  ***Regla para guardar una transicion en la memoria (en este caso se guarda la regla entera)
  rl[Contrato N I NL LE NC LPI LCM T LT ,M,M'] => [Contrato N I NL LE NC LPI LCM LT,M,M'[T]] .
  ***Regla para guardar una transicion en la memoria (se divide la transicion en [nombre, entradas, cuerpo])
  rl[C , M , M2 [transicion x LPI LD end] M'] => [C , M , M2[x, LPI, LD, mv,  ['_amount => Uint128]['_sender => ByStr20]]M'] .
  ***Regla para almacenar las declaraciones en la memoria
  rl[C , M , M3[x, LPI, D LD, M2, M4]M'] => [C , M , M3[x, LPI, LD, M2 almacenar(D), M4 ]M'] .
  rl[C , M , M3[x, LPI, existe x2 x3 LP LD, M2, M4]M'] => [C , M , M3[x, LPI, LD, M2 Existe[x2 => x3,LP], M4 ]M'] .
  rl[C , M , M3[x, LPI, delete x2 LP LD, M2, M4]M'] => [C , M , M3[x, LPI, LD, M2 Eliminar[x2,LP], M4 ]M'] .
  
  ***Regla para almacenar las entradas en la memoria
  ***rl[C , M , M3[x, PI, LD, M2, M4]M'] => [C , M , M3[x, lpv, LD, M2, M4 almacenar(PI)]M'] .
  crl[C , M , M3[x, LPI, LD, M2, M4]M'] => [C , M , M3[x, lpv, LD, M2, M4 almacenar(LPI)]M'] 
     if not(LPI == lpv) .



  ***Regla para almacenar la expresion match en la memoria ([comprobacion = > cuerpo])
  rl[C , M , M3[x, LPI, EM LD, M2, M4]M'] => [C , M , M3[x, LPI, LD, M2[EM], M4 ]M'] .
  rl[C , M , M3[x, LPI, LD, M2[EM]M5, M4]M'] => [C , M , M3[x, LPI, LD, M2 almacenarMatch(EM) M5, M4 ]M'] .

  ***Regla para sustituir valores globales e las transiciones
  --- crl[C , M , M3[x, LPI, LD, M7, M6]M'] => [C , M , M3[x, LPI, LD, sustituir(M, M7), M6]M'] 
  ---    if tenerModificar(M7) [print "Entra" M7] .
  --- crl[C , M , M3[x, LPI, LD, M7, M6]M'] => [C , M , M3[x, LPI, LD, sustituir(M, M7), M6]M'] 
  ---    if tenerModificar2(M7) [print "Entra2" M7] .
  

 



  
  --- rl[let x V LE ,M, M'] => [LE,M[x => V], M'] .
  --- rl[let x V LE ,M, M'] => [LE ,M[x => V], M'] .
  --- rl[LE ,M[x => TE IN]M2, M'] => [LE ,M[x => IN]M2, M'] .
  --- rl[EXP LD, M, M'] => [LD, almacenar(EXP), M'] .


endm

view Clave from TRIV to Programa is 
  sort Elt to Par .
endv

***Modulo reglas para ejecutar transiciones
mod REGLAS-EJECUTAR is
  pr SISTEMA .
  ***pr MAP{Nat, Par} .
  pr MAP{Nat, Bool} .

  vars x x1 x2 x3 x4 x5 : Qid .
  var NT : NombreTipo .
  vars M M' M1 M2 M3 M4 M5 M6 M7 M8 M9 : Memoria .
  var LPI : ListaParamInm .
  var LD : ListaDeclaraciones .
  var TE : TipoEntero .
  vars IN IN1 : Int .
  var OPB : OperacionBuilt .
  var B : Bool .
  var P : Pareja .
  vars VCP VCP1 : ValorCampo .
  var V : Val .
  var TOP : TipoOpcion .
  var QL : QidList .
  vars L L1 : Lista .
  ***var MP : Map{Nat,Par} .
  var MP : Map{Nat,Bool} .
  var N : Nat .
 
  rl [M, M1 [x, LPI, LD, M4, M5]M7] => [M, M1 [x, M4, M5]M7] .
  rl [M[x => NT]M1, M2] => [M[x => 1]M1, M2] .
  rl [M, M1 [x, M4, M5 ['_amount => TE] M6]M7] => [M, M1 [x, M4, M5 ['_amount => 100] M6]M7] .
  rl [M, M1 [x, M4, M5 ['_sender => NT] M6]M7] => [M, M1 [x, M4, M5 ['_sender => 1] M6]M7] .
  rl [M, M1 [x, M4, M5 [x1 => NT] M6]M7] => [M, M1 [x, M4, M5 [x1 => "Hola"] M6]M7] .

  ***Reglas para sustituir variables globales (campos)
  rl[M [x => V] M1 [x2 => AplicarF[x]] M2 , M3] => [M [x => V] M1 [x2 => V] M2 , M3] .
  rl[M [x2 => AplicarF[x]] M1 [x => V] M2 , M3] => [M [x2 => V] M1 [x => V] M2 , M3] .

  ***Regla para sustituir valores globales en las transiciones (de forma directa, es decir, teniendo directamente un terminal)
  rl[M [x2 => IN] M7 , [x, M1[x1 => x2] M5, M6]] => [M [x2 => IN] M7 , [x,  M1[x1 => IN] M5, M6]] .
  crl[M [x2 => V] M7 , [x, M1[x1 => x2] M5, M6]] => [M [x2 => V] M7 , [x,  M1[x1 => V] M5, M6]] 
     if not(esEntero(V)) .

  ***Regla para sustituir valores globales en las transiciones (de forma directa)
  --- crl[C , M , M3[x, LPI, LD, M4[x' => M7]M5, M6]M'] => [C , M , M3[x, LPI, LD, M4[x' => sustituir(M,M7)]M5, M6]M'] 
  ---    if tenerModificar2(M7) .

  --- ***Raglas para sustituir valores locales.
  --- ***rl[C , M , M3[x, LPI, LD, M2[x2 => V]M5[x' => M6[x3 => x2]M7]M4, M8]M'] => [C , M , M3[x, LPI, LD, M2[x2 => V]M5[x' => M6[x3 => V]M7]M4, M8]M'] .
  --- crl[C , M , M3[x, LPI, LD, M2[x2 => IN] M5, M8]M'] => [C , M , M3[x, LPI, LD, M2 [x2 => IN] sustituir(M2[x2 => IN], M5), M8]M'] 
  ---   if tenerModificar(M5) .
  crl[M , [x, M2[x2 => V] M5, M6]] => [M , [x,   M2 [x2 => V] sustituir([x2 => V], M5), M6]] 
     if tenerModificar(M5) .
  crl[M , [x, M2[x2 => IN] M5, M6]] => [M , [x,   M2 [x2 => IN] sustituir([x2 => IN], M5), M6]] 
     if tenerModificar(M5) .
  crl[M , [x, M2[x2 => M6] M5, M7]] => [M , [x,   M2 [x2 => M6] sustituir(M2[x2 => M6], M5), M7]] 
     if tenerModificar(M5) /\ not(tenerModificar(M6))  .
  --- crl[C , M , M3[x, LPI, LD, M2[x2 => V] M5, M8]M'] => [C , M , M3[x, LPI, LD, M2 [x2 => V] sustituir(M2[x2 => V], M5), M8]M'] 
  ---   if tenerModificar(M5) .
  --- crl[C , M , M3[x, LPI, LD, M2[x2 => M6] M5, M7]M'] => [C , M , M3[x, LPI, LD, M2[x2 => M6] sustituir(M2[x2 => M6], M5), M7]M'] 
  ---   if tenerModificar(M5) /\ not(tenerModificar(M6))  .
  --- crl[C , M , M3[x, LPI, LD, M4[x' => M2]M5, M7]M'] => [C , M , M3[x, LPI, LD, M4[x' => sustituirMismoNivel(M2)]M5, M7]M'] 
  ---   if tenerModificar2(M2) .

  ***Reglas para ejecutar operaciones
  sort TipoEjecutar .
  subsort Bool OperacionBuilt < TipoEjecutar .
  op ejecutar : OperacionBuilt -> TipoEjecutar [ctor] .
  eq ejecutar(IN ==. IN1) = (IN == IN1) .
  eq ejecutar(OPB) = OPB [owise] .

  op opcionCorrecta : Memoria -> Memoria [ctor] .
  eq opcionCorrecta(M2[x2 => TOP] M5 [x2 => M6 [TOP => M7] M8] M1) = M2[x2 => TOP] M5 [x2 => soloOpcion[TOP => M7]] M1 .
  eq opcionCorrecta(M2[x2 => soloOpcion[TOP => M7]] M1) = M2[x2 => soloOpcion[TOP => opcionCorrecta(M7)]] M1 .

  op hayOpcion : Memoria -> Bool [ctor] .
  eq hayOpcion(M1[TOP => M]M2) = true .
  eq hayOpcion(soloOpcion[TOP => M7]) = hayOpcion(M7) .
  eq hayOpcion(M [x => M1] M2) = hayOpcion(M1) [print M1] .
  eq hayOpcion(M) = false [owise] .

  rl[M[x4 => IN]M1 , [x, M2[x2 => [x3 ==. x4]] M3, M4[x3 => IN1] M5]] => [M[x4 => IN]M1 , [x, M2[x2 => IN1 == IN] M3, M4[x3 => IN1] M5]] .
  ***rl[M , M3[x, M2[x2 => IN ==. IN1] M5, M4]M'] => [M , M3[x, M2[x2 => IN == IN1] M5, M4]M'] .
  ***Regla para quedarte con la opción que te interesa del match
---   crl[M , [x, M2[x2 => soloOpcion[TOP => M7]] M1, M4]] => [M , [x, M2[x2 => soloOpcion[TOP => opcionCorrecta(M7)]] M1, M4]] 
---      if hayOpcion(M7) .
  crl[M , [x, M2, M4]] => [M , [x, opcionCorrecta(M2), M4]] 
    if hayOpcion(M2) .
  ***Ragla para ejecutar la declaracion actualizar
  rl[M , M3[x, [x2 => [B => Actualizar[x3, x4] M7]] M1, M4 [x4 => VCP]M5]M'] => [M , M3[x, [x2 => [B => Actualizar[x3, VCP] M7]] M1, M4 [x4 => VCP]M5]M'] .
  rl[M [x3 => VCP1] M2 , M3[x, [x2 => [B => Actualizar[x3, VCP] M7]] M1, M4]M'] => [M[x3 => VCP] M2  , M3[x, [x2 => [B => M7]] M1, M4]M'] .
  ***Regla para sustituir la declaracion evento
  rl[M, [x, M1[x2 => soloOpcion[TOP => M2[x3 => M3]['evento => x3] M4]] M5, M6]] => [M, [x, M1[x2 => soloOpcion[TOP => M2[x3 => M3]['evento => M3] M4]] M5, M6]] .
  ***Regla para sustituir la declaracion enviar
  rl[M, [x, M1[x2 => soloOpcion[TOP => M2[x3 => M3]M4['enviar => x3] M5]] M6, M7]] => [M, M1[x, [x2 => soloOpcion[TOP => M2[x3 => M3]M4['enviar => M3] M5]] M6, M7]] .
  ***Regla para ejecutar una funcion 
  rl[M[x => Funcion[[x5 => NT],M1]]M2, [x1, M3[x2 => soloOpcion[TOP => M4[x3 => M5]M6[x4 => AplicarF[x,x3]] M7]] M8, M9]] => [M[x4 => Funcion[[x5 => NT],M1]]M2, [x, M3[x2 => soloOpcion[TOP => M4[x3 => M5]M6[x4 => Funcion[[x5 => M5],M1]] M7]] M8, M9]] .
  rl[M, [x, M1[x1 => soloOpcion[TOP => M2[x3 => Funcion[[x4 => M5],M8]] M4]] M6, M7]] => [M, [x, M1[x1 => soloOpcion[TOP => M2[x3 =>  M5] M4]] M6, M7]] .
  ***Regla para ejecutar la operacion existe
  rl[M [x => MP] M1, [x1, M2 Existe[x2 => x,posicion x3]M3, M4[x3 => N]M5]] => [M [x => MP] M1, [x1, M2 [x2 => $hasMapping(MP, N)]M3, M4[x3 => N]M5]] .
  ***Reglas para ejecutar la operacion suma (dentro de un match)
  rl[M[x5 => IN]M1 , [x, M2 [x4 => IN1] M3 [x2 => soloOpcion[TOP => M4[x3 => [x4 +. x5]]M5]] M6, M7]] => [M[x5 => IN]M1 , [x, M2 [x4 => IN1] M3 [x2 => soloOpcion[TOP => M4[x3 => IN1 + IN]M5]] M6, M7]] .
  ***Regla para ejecutar la operacion insertar dentro de un match
   rl[M[x4 => V] M1 [x3 => MP]M2 , [x, M3 [x2 => soloOpcion[TOP => M4 Insertar[x3 => x4, posicion x5]M5]] M6, M7[x5 => N]]] => [M[x4 => V] M1 [x3 => insert(N, V, MP)]M2 , [x, M3 [x2 => soloOpcion[TOP => M4 M5]] M6, M7[x5 => N]]] .
  ***Regla para ejecutar la declaracion actualizar dentro de un match
  rl[M [x3 => IN] M1 , [x, M2[x2 => soloOpcion[TOP => M3 [x4 => IN1] M4 Actualizar[x3, x4] M5]] M6, M7]] => [M [x3 => IN1] M1 , [x, M2[x2 => soloOpcion[TOP => M3 [x4 => IN1] M4  M5]] M6, M7]] .
  ***Regla para ejecutar la expresion let in dentro de un match
  rl[M, [x, M2[x2 => soloOpcion[TOP => M3 [x1 => [x4 => IN, [x5 <. x4]]] M4 ]] M6, M7[x5 => IN1]M8]] => [M, [x, M2[x2 => soloOpcion[TOP => M3 [x1 => IN1 < IN] M4 ]] M6, M7[x5 => IN1]M8]] .
  ***Reglas para sustutuir la variables de un evento o mensaje
  rl[M[x4 => IN1]M2, [x, M1[x2 => soloOpcion[TOP => M3 [x3 => M4 [x5 => x4]M5] M6]] M7, M8]] => [M[x4 => IN1]M2, [x, M1[x2 => soloOpcion[TOP => M3 [x3 => M4 [x5 => IN1]M5] M6]] M7, M8]] .
  rl[M, [x, M1[x4 => IN1]M2[x2 => soloOpcion[TOP => M3 [x3 => M4 [x5 => x4]M5] M6]] M7, M8]] => [M, [x, M1[x4 => IN1]M2[x2 => soloOpcion[TOP => M3 [x3 => M4 [x5 => IN1]M5] M6]] M7, M8]] .
  rl[M, [x, M1[x2 => soloOpcion[TOP => M2 [x4 => IN1] M3 [x3 => M4 [x5 => x4]M5] M6]] M7, M8]] => [M, [x, M1[x2 => soloOpcion[TOP => M2 [x4 => IN1] M3 [x3 => M4 [x5 => IN1]M5] M6]] M7, M8]] .

endm

rew init .
red tenerModificar([false => ['x2 => ['x4 => 'x5]]]) .
red sustituir(['x1 => "ss"] ['x => ""], ['c => 'v] [false => ['x2 => ['x4 => 'x]]]) .
red almacenar(let 'x Nil{Message} in Cons Message 'msg 'nil_msg) .
--- search init =>* [cv , M:Memoria] .



fmod META-SIGN is
 including GRAMMAR .
 pr META-LEVEL .

 op BUBBLES : -> FModule .
 op GRAMMAR : -> FModule [memo] .

 eq BUBBLES
    = (fmod 'GRAMMAR is
        including 'QID-LIST .
        sorts none .
        none
        op 'token : 'Qid -> '@Token@
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '<-&BLOCKNUMBER)))] .
        op 'bubble : 'QidList -> '@Bubble@
             [special(
               (id-hook('Bubble, '1 '-1)
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, 'eq 'ceq 'rl 'crl 'mb 'cmb 'sd 'csd
                                  'var 'vars 'forall 'exists
                                  'sorts 'subsort 'subsorts 'op 'ops
                                  'protecting 'pr 'including 'inc 'extending 
                                  'ctor 'assoc 'comm '== '/\ 'spec* 'spec! 'builtin '`{ '`} 'let 'Pair '`( '`) 'Some
                                  '; 'andb 'true 'BoolU 'Uint32 'Uint128 'Uint256 'Nil 'throw 'Emp 'field 'false
                                  'ev '= '| 'Unit 'orb ':= 'None 'fun 'Int32 'Int128 'match 'String 'ByStr32 'ByStr33 'ByStr20 
                                  'BNum 'Bool 'Message 'Error 'ByStr 'ByStr64 'Unit '<- 'event '@ 'send 'schnorr-verify 'ecdsa-verify
                                  'add '<-exists 'lt 'contains 'delete 'put ' 'negb 'blt 'get 'remove 'badd 'accept 'sub)))] .
        op 'neTokenList : 'QidList -> '@NeTokenList@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '. ': '`[ 'forall 'exists)))] .
        none
        none
     endfm) .
 eq GRAMMAR = addImports(BUBBLES, (including 'GRAMMAR .)) .

 var  SSDS : SubsortDeclSet .
 vars IL IL' : ImportList .
 var  EqS : EquationSet .
 var  ODS : OpDeclSet .
 var  MAS : MembAxSet .
 var  RS : RuleSet .
 var  M : Module .
 var  SS : SortSet .
 var  H : Header .

 op setImports : Module ImportList -> Module .
 eq setImports(fmod H is IL sorts SS . SSDS ODS MAS EqS endfm, IL')
    = fmod H is IL' sorts SS . SSDS ODS MAS EqS endfm .
 eq setImports(mod H is IL sorts SS . SSDS ODS MAS EqS RS endm, IL')
    = mod H is IL' sorts SS . SSDS ODS MAS EqS RS endm .
 eq setImports(fth H is IL sorts SS . SSDS ODS MAS EqS endfth, IL')
    = fth H is IL' sorts SS . SSDS ODS MAS EqS endfth .
 eq setImports(th H is IL sorts SS . SSDS ODS MAS EqS RS endth, IL')
    = th H is IL' sorts SS . SSDS ODS MAS EqS RS endth .

 op addImports : Module ImportList -> Module .
 eq addImports(M, IL) = setImports(M, (getImports(M) IL)) .
endfm