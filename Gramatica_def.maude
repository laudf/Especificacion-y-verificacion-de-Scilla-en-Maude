fmod GRAMMAR is
  pr STRING .
  pr INT .
  sorts @Token@ @Bubble@ @NeTokenList@ .
  sort @DeclaracionOp@ @Prog@ @TipoEntero@ @Num@ @Entero@ @TipoOpto@ @BNum@ @NombreTipo@ @Option@ @Lista@ @Par@ @Natural@ @Contrato@ .
  ***subsort @DeclaracionOp@ @Entero@ String @BNum@ @Option@ @Lista@ @Par@ @Natural@ @ParametrosInm@ @Campo_mod@ @Version@ < @Prog@ .

  ***DATOS PRMITIVOS

  ***ENTEROS
  ***Declaración de entero (Nombre de su tipo y el valor), los uint los trato como naturales.
  ops Uint32 Uint64 Uint128 Uint256 Int32 Int64 Int128 Int256 : -> @TipoEntero@ [ctor] .
  op __ : @TipoEntero@ Int -> @Entero@ [ctor prec 11] .
  ***op __ : @TipoEnteroInt@ Num -> @EnteroInt@ [ctor] . 

  ***Declaración de la operacion de igualdad.
  op eq__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor comm prec 13] .
  ***Declaración de la operación Suma.
  op add__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor comm prec 13] .
  ***Declaración de la operación resta
  op sub__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 14] .
  ***Declaración de la operación de multiplicación.
  op mul__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor comm prec 14] .
  ***Declaración de la operación de división.
  op div__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 14] .
  ***Declaración de la operación resto.
  op rem__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 14] .
  ***Declaración de la operación menor
  op lt__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 13] .
  ***Declaración de la operación de exponente.
  op pow__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 14] .
  ***Declaración de la operación de raíz cuadrada.
  op isqrt_ : @Token@ -> @DeclaracionOp@ [ctor prec 14] .
  ***Declaración de la operación to_nat.
  op to-nat_ : @Token@ -> @DeclaracionOp@ [ctor prec 14] .
  ***Declaración de la operación to_(u)int32/64/128/256.
  ops to-int32 to-int64 to-int128 to-int256 to-uint32 to-uint64 to-uint128 to-uint256 : -> @TipoOpto@ [ctor] .
  op __ : @TipoOpto@ @Token@ -> @DeclaracionOp@ [ctor prec 14] . 

  ***STRINGS
  ***La operación eq ya está definida anteriormente para los enteros y como es la misma es la que usaremos.
  ***Declaración de la operacion de concatenar dos strings.
  op concat__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor comm prec 14] .
  ***Declaración de la operación de substring (string posición_inicio longitud_substring).
  op substr___ : @Token@ @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 14] .
  ***op substr___ : @Token@ Nat Nat -> @DeclaracionOp@ [ctor] .
  ***Declaración de la operacion to-string que convierte un elemento de tipo Intx/Uintx/BystrX/ByStr a string.
  op to-string_ : @Token@ -> @DeclaracionOp@ [ctor prec 14] .
  ***Declaración de la operacion strlen (devuelve la longitud del string).
  op strlen_ : @Token@ -> @DeclaracionOp@ [ctor prec 14] .

  ***HASHES
  op sha256hash_ : @Token@ -> @DeclaracionOp@ [ctor prec 14] .
  op schnorr-verify___ : @Token@ @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 14] . 
  op ecdsa-verify___ : @Token@ @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 14] .

  ***MAPAS
  sort @TipoClave@ @TipoValor@ @MapVacio@ @Map@ @DeclaracionOpMapI@ @posicion@ @ListaPosiciones@ .
  ***subsort @TipoEntero@ < @NombreTipo@ .
  subsort @NombreTipo@ < @TipoClave@ .
  subsort @NombreTipo@ @Par@  < @TipoValor@ .
  subsort @posicion@ < @ListaPosiciones@ .

  op Emp__ : @TipoClave@ @TipoValor@ -> @MapVacio@ [ctor prec 15] .
  op Emp__ : @TipoClave@ @Bubble@ -> @MapVacio@ [ctor prec 15] .
  op Map__ : @TipoClave@ @TipoValor@ -> @Map@ [ctor prec 15] .
  op Map__ : @TipoClave@ @Bubble@ -> @Map@ [ctor prec 15] .
  op [_] : @Token@ -> @posicion@ [ctor prec 18] .
  op __ : @ListaPosiciones@ @ListaPosiciones@ -> @ListaPosiciones@ [ctor assoc prec 19] .
  ***Definición operación insertar.
---   ***Funcional
  op put___ : @Token@ @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 19] .
  ***In-place.
  op __:=_ : @Token@ @ListaPosiciones@ @Token@ -> @DeclaracionOpMapI@ [ctor prec 19] .
  ***Definición operación obtener valor.
  ***Funcional
  op get__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 13] .
  ***In-place
  op _<-__ : @Token@ @Token@ @ListaPosiciones@ -> @DeclaracionOpMapI@ [ctor prec 19] .
  ***Definición operación contener.
  ***Funcional
  op contains__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 13] .
  ***In-place
  op _<-exists__ : @Token@ @Token@ @ListaPosiciones@ -> @DeclaracionOpMapI@ [ctor prec 19] .
  ***Definición operación eliminar.
  ***Funcional
  op remove__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 13] .
  ***In-place
  op delete__ : @Token@ @ListaPosiciones@ -> @DeclaracionOpMapI@ [ctor prec 19] .

  ***BNUM
  ***Definición número de bloques
  op BNum_ : Int -> @BNum@ [ctor] .
  ***Definción de operaciones
  ***La operación eq ya está definida para los enteros.
  ***Definición operación blt(menor o igual).
  op blt__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 14] .
  ***Declaración operación badd (suma un Bnum con un UintX).
  op badd__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 14] .
  ***Declaración operación bsub(resta de dos Bnums).
  op bsub__ : @Token@ @Token@ -> @DeclaracionOp@ [ctor prec 14] .

  ***Falta por meter los mapas, hashes y direcciones.

  ***DATOS ALGEBRAICOS
  ***Declaración option
  subsort @TipoEntero@ @Map@ < @NombreTipo@ .
  ops String ByStr32 ByStr33 ByStr20 BNum Bool Message Error ByStr ByStr64 Unit : -> @NombreTipo@ [ctor] .  ***Falta meter los enteros
  op Option_ : @NombreTipo@ -> @Option@ [ctor prec 13] .  ***A lo mejor hay que hacer un tipo declaracionOption para diferenciarlo.
  ***Constructoras option
  op None{_} : @NombreTipo@ -> @Option@ [ctor prec 13] .
  op None : -> @Option@ [ctor] .
  op Some{_}_ : @NombreTipo@ @Token@ -> @Option@ [ctor prec 13] . 
  op Some_ : @Token@ -> @Option@ [ctor prec 13] .

  ***Declaración Lista
  op List_ : @NombreTipo@ -> @Lista@ [ctor prec 13] .
  ***Constructoras de las listas
  op Nil{_} : @NombreTipo@ -> @Lista@ [ctor prec 13] .
  op Cons{_}__ : @NombreTipo@ @Token@ @Token@ -> @Lista@ [ctor prec 13] .

  ***Declaración Pares
  op Pair__ : @NombreTipo@ @NombreTipo@ -> @Par@ [ctor prec 13] .
  ***Constructora Pair
  op Pair{__}__ : @NombreTipo@ @NombreTipo@ @Token@ @Token@ -> @Par@ [ctor prec 13] .

  ***Declaración Nat
  op Nat : -> @Natural@ [ctor] .
  ***Constructoras de Nat
  op Zero : -> @Natural@ [ctor] .
  op Succ_ : @Token@ -> @Natural@ [ctor prec 13] .

  ***PARÁMETROS INMUTABLES
  sort @TipoParamInm@ @ParamInm@ @ListaParamInm@ @ParametrosInm@ .
  subsort @NombreTipo@ @Map@ @Option@ < @TipoParamInm@ .
  subsort @ParamInm@ < @ListaParamInm@ .

  ***ops ByStr20 BNum String ByStr32 Bool Message : -> @TipoParamInm@ [ctor] .
  ***op _:_ : String TipoParamInm -> ParamInmSolo [ctor] .
  op _:_ : @Token@ @TipoParamInm@ -> @ParamInm@ [ctor prec 15] .
  op _:_ : @Token@ @Bubble@ -> @ParamInm@ [ctor prec 15] .
  ***op vacio : -> ListaParamInm [ctor] .
  ***op _ : ParamInm -> ListaParamInm [ctor] .
  op lpv : -> @ListaParamInm@ [ctor] .
  op (_,_) : @ListaParamInm@ @ListaParamInm@ -> @ListaParamInm@ [ctor assoc prec 17 id: lpv] . 
  ***op <> : -> ParametrosInm [ctor] .
  ***op _ : @ListaParamInm@ -> @ParametrosInm@ [ctor] .
  --- ***op [_with_=>] : ParametrosInm OperacionBooleana -> Restriccion [ctor] .

  ***CAMPOS MODIFICABLES
  sort @ValorCampo@ @Campo_mod@ @ListaCamposMod@ .
  ***subsort @Entero@ @Option@ @Lista@ @Par@ @Natural@ String Bool < @ValorCampo@ .
  subsort @Entero@ @Option@ @Lista@ @Par@ @Natural@ @MapVacio@ Bool @Expresion@ String < @ValorCampo@ .
  ***subsort Bool < @ValorCampo@ .
  subsort @Campo_mod@ < @ListaCamposMod@ .
  op cv : -> @Campo_mod@ [ctor] .
  op field_=_ : @ParamInm@ @ValorCampo@ -> @Campo_mod@ [ctor prec 19] .
  op field_=_ : @ParamInm@ @ExpresionAplicarF@ -> @Campo_mod@ [ctor prec 19] .
  op __ : @ListaCamposMod@ @ListaCamposMod@ -> @ListaCamposMod@ [ctor assoc prec 20] .

  ***EXPRESIONES
  sort @TipoDato@ @Expresion@ @Operacion@ @ExpresionFuncion@ @ListaArgumentos@ @OperacionBuilt@ @ListaExpresiones@ @TipoOpcion@ @Opcion@
       @ListaOpciones@ @Expresiones@ @ExpresionMatch@ @ListaArg@ @ExpresionLet@ @ExpresionAplicarF@ .
  --- ***Entero String Bool ExpresionBuilt Map ByStr32 ByStr20 BNum Option Lista Par Natural Expresion
  subsort @Entero@ String @BNum@ @Option@ @Lista@ @Par@ @Natural@ @ExpresionFuncion@ @Expresion@ @ExpresionMatch@ @MapVacio@ @ExpresionAplicarF@ < @TipoDato@ .
  --- --- subsort Expresion DeclaracionOpBools DeclaracionOpInts < Operacion .
  subsort @Expresion@ @Lista@ @ExpresionFuncion@ @ExpresionMatch@ @Excepcion@ @Par@ < @Operacion@ .
  subsort @TipoEntero@ @NombreTipo@ @Par@ < @ListaArgumentos@ .
  subsort @DeclaracionOp@ @DeclaracionOpBools@  < @OperacionBuilt@ .
  subsort @ExpresionLet@ @ADTS@ < @ListaExpresiones@ . 
 *** subsort @Declaracion@ @ExpresionMatch@ < @Expresiones@ .
  subsort @ListaDeclaraciones@ @Entero@ @Expresion@ < @Expresiones@ .
  subsort @Option@ @Par@ Bool < @TipoOpcion@ .
  subsort @Opcion@ < @ListaOpciones@ .
  subsort @Token@ < @ListaArg@ .
  ***subsort @Bubble@ < @ExpresionAplicarF@ .

  op let_=_ : @Token@ @TipoDato@ -> @ExpresionLet@ [ctor prec 20]  .
  ***op let_=_ : @Token@ @Bubble@ -> @ExpresionLet@ [ctor prec 20]  .
  op let_=_in_ : @Token@ @TipoDato@ @Operacion@ -> @Expresion@ [ctor prec 20] .
  ***op let_ : @Expresion@ -> @Expresion@ [ctor prec 20] .
  ***op let_in_ : @Expresion@ @Operacion@ -> @Expresion@ [ctor prec 20] .
  --- ***Falta añadir los mensajes
  op fun(_)=>_ : @ParamInm@ @Operacion@ -> @ExpresionFuncion@ [ctor prec 20] .
  ***op __ : @ListaArg@ @ListaArg@ -> @ListaArg@ [ctor assoc prec 19] .
  op `(_`) :  @Bubble@ -> @ExpresionAplicarF@ [ctor prec 19] .
  ***op _=__ : @Token@ @Token@ @NeTokenList@ -> @Expresion@ [ctor prec 20] .
  --- --- op tfun'_=>_ : String Operacion -> Expresion [ctor] .
  ***op String : -> @ListaArgumentos@ [ctor] .
  op __ : @ListaArgumentos@ @ListaArgumentos@ -> @ListaArgumentos@ [ctor assoc prec 19] .
  op @__ : @Token@ @ListaArgumentos@ -> @Expresion@ [ctor prec 20] .  

  --- --- op [_] : String -> Argumento [ctor] .
  --- --- op __ : ListaArgumentos ListaArgumentos -> ListaArgumentos [ctor] .
  --- --- ***op builtin__ : OperacionBuilt ListaArgumentos -> ExpresionBuilt [ctor] . ***No es exactamente string (hay que cambiarlo).
  op builtin_ : @OperacionBuilt@ -> @Expresion@ [ctor prec 19] .

  op ev : -> @Expresiones@ [ctor] .
  op |_=>_ : @TipoOpcion@ @Expresiones@ -> @Opcion@ [ctor prec 20] .  ***La segunda entrada no sería un string sino un statement.
  ***op _=>_ : @Constructora@ @Expresiones@ -> @Opcion@ [ctor prec 20] .
  op |_=>_ : @Bubble@ @Expresiones@ -> @Opcion@ [ctor prec 20] .
  op |_=>_ : @TipoOpcion@ @Bubble@ -> @Opcion@ [ctor prec 20] .
  op ov : -> @ListaOpciones@ [ctor] .
  op __ : @ListaOpciones@ @ListaOpciones@ -> @ListaOpciones@ [ctor assoc prec 21] .
  op match_with_end : @Token@ @ListaOpciones@ -> @ExpresionMatch@ [ctor prec 21] .
  op __ : @ListaExpresiones@ @ListaExpresiones@ -> @ListaExpresiones@ [ctor assoc prec 22] .

  ***DECLARACIONES
  sort @Declaracion@ @Valor@ @ListaDeclaraciones@ .
  ***@Entero@ String DeclaracionFuncion EventoMsg ExpresionBuilt Option Lista Par Natural DeclaracionOpBools DeclaracionOpInts
  subsorts @Entero@ String @Option@ @Lista@ @Par@ @Natural@ @Evento@ @Expresion@ @Mensaje@ Bool @DeclaracionOpBools@ @ExpresionMatch@ @ExpresionAplicarF@ < @Valor@ .
  subsort @Declaracion@ @ExpresionMatch@ @DeclaracionOpMapI@ @Expresion@ @Error@ @ExpresionAplicarF@ < @ListaDeclaraciones@ .
  ***subsort @Expresiones@ @DeclaracionOpMapI@ @Expresion@ < @ListaDeclaraciones@ .

  op _<-_ : @Token@ @Token@  -> @Declaracion@ [ctor prec 19] .
  op _:=_ : @Token@ @Token@ -> @Declaracion@ [ctor prec 19] .
  op _<-&BLOCKNUMBER : @Token@ -> @Declaracion@ [ctor prec 19] .
  op _=_ : @Token@ @Valor@ -> @Declaracion@ [ctor prec 19] .
  ***op _=_ : @Token@ @Bubble@ -> @Declaracion@ [ctor prec 19] .
  ***op __ : @Token@ @ListaArgumentos@ -> @Declaracion@ [ctor] .
  op forall__ : @Token@ @Token@ -> @Declaracion@ [ctor prec 19] .
  op accept : -> @Declaracion@ [ctor] .
  op send_ : @Token@ -> @Declaracion@ [ctor prec 19] .
  op event_ : @Token@ -> @Declaracion@ [ctor prec 19] .

  op _;_ : @ListaDeclaraciones@ @ListaDeclaraciones@ -> @ListaDeclaraciones@ [ctor assoc prec 20] .

  ***TRANSICIONES Y PROCEDIMIENTOS
  sort @Transicion@ @ListaTransiciones@ @Procedimiento@ .
  subsort @Transicion@ @Procedimiento@ < @ListaTransiciones@ .

  op procedure_(_)_end : @Token@ @ListaParamInm@ @ListaDeclaraciones@ -> @Procedimiento@ [ctor prec 23] .
  op transition_(_)_end : @Token@ @ListaParamInm@ @ListaDeclaraciones@ -> @Transicion@ [ctor prec 23] .
  op tv : -> @ListaTransiciones@ [ctor] .
  op __ : @ListaTransiciones@ @ListaTransiciones@ -> @ListaTransiciones@ [ctor assoc prec 24] .

  ***COMUNICACIONES
  sort @NombreEvento@ @ListaCamposEvento@ @Evento@ @CampoEvento@ @TagMensaje@ @EnvioMensaje@ @CantidadMensaje@ @Mensaje@ @NombreExcepcion@ @Excepcion@ .
  subsort @CampoEvento@ < @ListaCamposEvento@ .
  ***Eventos
  op -eventname:_ : String -> @NombreEvento@ [ctor prec 12] .
  op _:_ : @Token@ @Token@ -> @CampoEvento@ [ctor prec 12] .
  ***op _:_ : @Token@ String -> @CampoEvento@ [ctor prec 12] .
  op lcv : -> @ListaCamposEvento@ [ctor] .
  op _;_ : @ListaCamposEvento@ @ListaCamposEvento@ -> @ListaCamposEvento@ [ctor assoc prec 13] .
  op {_;_} : @NombreEvento@ @ListaCamposEvento@ -> @Evento@ [ctor prec 14] .
  ***Mensajes
  op -tag:_ : String -> @TagMensaje@ [ctor prec 12] .
  op -recipient:_ : @Token@ -> @EnvioMensaje@ [ctor prec 12] .
  op -amount:_ : @Entero@ -> @CantidadMensaje@ [ctor prec 12] .
  op -amount:_ : @Token@ -> @CantidadMensaje@ [ctor prec 12] .
  ***op {_;_;_;_} : @TagMensaje@ @EnvioMensaje@ @CantidadMensaje@ @ListaCamposEvento@ -> @Mensaje@ [ctor prec 14] .
  op {_;_;_;_} : @TagMensaje@ @EnvioMensaje@ @CantidadMensaje@ @ListaCamposEvento@ -> @Mensaje@ [ctor prec 14] .

  op -exception:_ : String -> @NombreExcepcion@ [ctor prec 12] .
  op {_;_} : @NombreExcepcion@ @ListaCamposEvento@ -> @Excepcion@ [ctor prec 14] .

  ***LIBRERIA BOOLUTILS
  sort @DeclaracionOpBools@ .

  ops andb__ orb__ : @Token@ @Token@ -> @DeclaracionOpBools@ [ctor prec 14] .
  ops negb_ bool-to-string_ : @Token@ -> @DeclaracionOpBools@ [ctor prec 14] .
  ops _.andb__ _.orb__ : @Token@ @Token@ @Token@ -> @DeclaracionOpBools@ [ctor prec 14] .
  ops _.negb_ _.bool-to-string_ : @Token@ @Token@ -> @DeclaracionOpBools@ [ctor prec 14] .



  ***ADTS
  sort @ADTS@ @Constructora@ @Constructoras@ .
  subsort @Constructora@ < @Constructoras@ .
  op |_ : @Token@ -> @Constructora@ [ctor prec 15] .
  --- ops String ByStr32 ByStr20 BNum Bool : -> ListaArgumentos [ctor] .
  --- op __ : ListaArgumentos ListaArgumentos -> ListaArgumentos [ctor assoc] .
  --- op |_of_ : Qid ListaArgumentos -> Constructora [ctor] . 
  op __ : @Constructoras@ @Constructoras@ -> @Constructoras@ [ctor assoc prec 16] .
  op type_=_ : @Token@ @Constructoras@ -> @ADTS@ [ctor prec 17] .

  ***ERRORES
  sort @Error@ .
  op throw : -> @Error@ [ctor] .
  op throw_ : @Token@ -> @Error@ [ctor prec 19] .

  

  sort @NombreLibreria@ @NombreContrato@ @Libreria@ @LibImportar@ @Importacion@ @ListaImportar@ .
  subsort @LibImportar@ < @ListaImportar@ .

  op library_ : @Token@ -> @NombreLibreria@ [ctor] .
  op contract_ : @Token@ -> @NombreContrato@ [ctor] .
  ops BoolUtils IntUtils PairUtils ListUtils : -> @LibImportar@ [ctor] .
  op iv : -> @Importacion@ [ctor] .
  op __ : @ListaImportar@ @ListaImportar@ -> @ListaImportar@ [ctor assoc] .
  op import_ : @ListaImportar@ -> @Importacion@ [ctor] .
  op import_as_ : @LibImportar@ @Token@ -> @Importacion@ [ctor] .

  op __ : @NombreLibreria@ @ListaExpresiones@ -> @Libreria@ [ctor] .

 


 


  
  op scilla-version_______ : Nat @Importacion@ @Libreria@ @NombreContrato@ @ListaParamInm@ @ListaCamposMod@ @ListaTransiciones@ -> @Contrato@ [ctor] .
  ***op scilla-version___ : Nat @Importacion@ @Libreria@ -> @Contrato@ [ctor] .

endfm

fmod Programa is
  pr QID .
  pr QID-LIST .
  pr INT .
  sort DeclaracionOp TipoEntero Entero Contrato Igualdad .
  subsort DeclaracionOp Entero < Expresion .

  ***DATOS PRMITIVOS

  ***ENTEROS
  ***Declaración de entero (Nombre de su tipo y el valor), los uint los trato como naturales.
  ops Uint32 Uint64 Uint128 Uint256 Int32 Int64 Int128 Int256 : -> TipoEntero [ctor] .
  op __ : TipoEntero Int -> Entero [ctor prec 11] .
  ***op __ : @TipoEnteroInt@ Num -> @EnteroInt@ [ctor] . 

  ***Declaración de la operacion de igualdad.
  op _==_ : Qid Qid -> DeclaracionOp [ctor comm prec 13] .
  ***Declaración de la operación Suma.
  op _+_ : Qid Qid -> DeclaracionOp [ctor comm prec 13] .
  ***Declaración de la operación resta
  op _-_ : Qid Qid -> DeclaracionOp [ctor prec 14] .
  ***Declaración de la operación de multiplicación.
  op _*_ : Qid Qid -> DeclaracionOp [ctor comm prec 14] .
  ***Declaración de la operación de división.
  op _/_ : Qid Qid -> DeclaracionOp [ctor prec 14] .
  ***Declaración de la operación resto.
  op _%_ : Qid Qid -> DeclaracionOp [ctor prec 14] .
  ***Declaración de la operación menor
  op _<_ : Qid Qid -> DeclaracionOp [ctor prec 13] .
  ***Declaración de la operación de exponente.
  op _^_ : Qid Qid -> DeclaracionOp [ctor prec 14] .
  ***Declaración de la operación de raíz cuadrada.
  op raiz_ : Qid -> DeclaracionOp [ctor prec 14] .

  op cv : -> Contrato [ctor] .
  op __ : Contrato Contrato -> Contrato [ctor id: cv] .
  ***Declaración de la operación to_nat.
  --- op to-nat_ : @Token@ -> @DeclaracionOp@ [ctor prec 14] .
  --- ***Declaración de la operación to_(u)int32/64/128/256.
  --- ops to-int32 to-int64 to-int128 to-int256 to-uint32 to-uint64 to-uint128 to-uint256 : -> @TipoOpto@ [ctor] .
  --- op __ : @TipoOpto@ @Token@ -> @DeclaracionOp@ [ctor prec 14] . 

  ***STRINGS
  ***La operación eq ya está definida anteriormente para los enteros y como es la misma es la que usaremos.
  ***Declaración de la operacion de concatenar dos strings.
  op _++_ : Qid Qid -> DeclaracionOp [ctor comm prec 14] .
  ***Declaración de la operación de substring (string posición_inicio longitud_substring).
  op substr___ : Qid Qid Qid -> DeclaracionOp [ctor prec 14] .
  ***op substr___ : @Token@ Nat Nat -> @DeclaracionOp@ [ctor] .
  ***Declaración de la operacion to-string que convierte un elemento de tipo Intx/Uintx/BystrX/ByStr a string.
  op to-string_ : Qid -> DeclaracionOp [ctor prec 14] .
  ***Declaración de la operacion strlen (devuelve la longitud del string).
  op length_ : Qid -> DeclaracionOp [ctor prec 14] .

  ***HASHES
  op sha256hash_ : Qid -> DeclaracionOp [ctor prec 14] .
  op schnorr-verify___ : Qid Qid Qid -> DeclaracionOp [ctor prec 14] . 
  op ecdsa-verify___ : Qid Qid Qid -> DeclaracionOp [ctor prec 14] .

  ***MAPAS
  sort TipoClave TipoValor MapVacio Map DeclaracionOpMapI posicion ListaPosiciones .
  ***subsort @TipoEntero@ < @NombreTipo@ .
  subsort NombreTipo < TipoClave .
  subsort NombreTipo Par < TipoValor .
  subsort posicion < ListaPosiciones .

  op Emp__ : TipoClave TipoValor -> MapVacio [ctor prec 15] .
  op Emp__ : TipoClave QidList -> MapVacio [ctor prec 15] .
  op Map__ : TipoClave TipoValor -> Map [ctor prec 15] .
  op Map__ : TipoClave QidList -> Map [ctor prec 15] .
  op [_] : Qid -> posicion [ctor prec 18] .
  op __ : ListaPosiciones ListaPosiciones -> ListaPosiciones [ctor assoc prec 19] .
  ***Definición operación insertar.
---   ***Funcional
  op put___ : Qid Qid Qid -> DeclaracionOp [ctor prec 19] .
  ***In-place.
  op insertar___ : Qid ListaPosiciones Qid -> DeclaracionOpMapI [ctor prec 19] .
  ***Definición operación obtener valor.
  ***Funcional
  op get__ : Qid Qid -> DeclaracionOp [ctor prec 13] .
  ***In-place
  op obtener___ : Qid Qid ListaPosiciones -> DeclaracionOpMapI [ctor prec 19] .
  ***Definición operación contener.
  ***Funcional
  op contains__ : Qid Qid -> DeclaracionOp [ctor prec 13] .
  ***In-place
  op existe___ : Qid Qid ListaPosiciones -> DeclaracionOpMapI [ctor prec 19] .
  ***Definición operación eliminar.
  ***Funcional
  op remove__ : Qid Qid -> DeclaracionOp [ctor prec 13] .
  ***In-place
  op delete__ : Qid ListaPosiciones -> DeclaracionOpMapI [ctor prec 19] .

  ***BNUM
  sort BNum .
  ***Definición número de bloques
  op BNum_ : Int -> BNum [ctor] .
  ***Definción de operaciones
  ***La operación eq ya está definida para los enteros.
  ***Definición operación blt(menor o igual).
  ***Se usa los de los enteros.
  --- op blt__ : Qid Qid -> DeclaracionOp [ctor prec 14] .
  --- ***Declaración operación badd (suma un Bnum con un UintX).
  --- op badd__ : Qid Qid -> DeclaracionOp [ctor prec 14] .
  --- ***Declaración operación bsub(resta de dos Bnums).
  --- op bsub__ : Qid Qid -> DeclaracionOp [ctor prec 14] .

  ***DATOS ALGEBRAICOS
  ***Declaración option
  sort NombreTipo Option Lista Par Natural .
  subsort TipoEntero Map < NombreTipo .
  ops String ByStr32 ByStr33 ByStr20 BNum Bool Message Error ByStr ByStr64 Unit : -> NombreTipo [ctor] .  ***Falta meter los enteros
  op Option_ : NombreTipo -> Option [ctor prec 13] .  ***A lo mejor hay que hacer un tipo declaracionOption para diferenciarlo.
  ***Constructoras option
  op None{_} : NombreTipo -> Option [ctor prec 13] .
  op None : -> Option [ctor] .
  op Some__ : NombreTipo Qid -> Option [ctor prec 13] . 
  op Some_ : Qid -> Option [ctor prec 13] .

  ***Declaración Lista
  op List_ : NombreTipo -> Lista [ctor prec 13] .
  ***Constructoras de las listas
  op Nil{_} : NombreTipo -> Lista [ctor prec 13] .
  op Cons___ : NombreTipo Qid Qid -> Lista [ctor prec 13] .

  ***Declaración Pares
  op Pair__ : NombreTipo NombreTipo -> Par [ctor prec 13] .
  ***Constructora Pair
  op Pair____ : NombreTipo NombreTipo Qid Qid -> Par [ctor prec 13] .

  ***Declaración Nat
  op Nat : -> Natural [ctor] .
  ***Constructoras de Nat
  op Zero : -> Natural [ctor] .
  op Sucesor_ : Qid -> Natural [ctor prec 13] .

  ***PARÁMETROS INMUTABLES
  sort TipoParamInm ParamInm ListaParamInm ParametrosInm .
  subsort NombreTipo Map Option < TipoParamInm .
  subsort ParamInm < ListaParamInm .

  ***ops ByStr20 BNum String ByStr32 Bool Message : -> @TipoParamInm@ [ctor] .
  ***op _:_ : String TipoParamInm -> ParamInmSolo [ctor] .
  op _:_ : Qid TipoParamInm -> ParamInm [ctor prec 15] .
  op _:_ : Qid QidList -> ParamInm [ctor prec 15] .
  op _:_ : Qid Qid -> ParamInm [ctor prec 15] .
  ***op vacio : -> ListaParamInm [ctor] .
  ***op _ : ParamInm -> ListaParamInm [ctor] .
  op lpv : -> ListaParamInm [ctor] .
  op (_,_) : ListaParamInm ListaParamInm -> ListaParamInm [ctor assoc prec 17] . 
  ***op <> : -> ParametrosInm [ctor] .
  ***op _ : @ListaParamInm@ -> @ParametrosInm@ [ctor] .
  --- ***op [_with_=>] : ParametrosInm OperacionBooleana -> Restriccion [ctor] .

  
  ***CAMPOS MODIFICABLES
  sort ValorCampo Campo_mod ListaCamposMod .
  ***subsort @Entero@ @Option@ @Lista@ @Par@ @Natural@ String Bool < @ValorCampo@ .
  subsort Entero Option Lista Par Natural MapVacio Bool Expresion String < ValorCampo .
  ***subsort Bool < ValorCampo .
  subsort Campo_mod < ListaCamposMod .
  op cv : -> Campo_mod [ctor] .
  op campo_=_ : ParamInm ValorCampo -> Campo_mod [ctor prec 19] .
  op campo_=_ : ParamInm ExpresionAplicarF -> Campo_mod [ctor prec 19] .
  op lcmv : -> ListaCamposMod [ctor] .
  op __ : ListaCamposMod ListaCamposMod -> ListaCamposMod [ctor assoc prec 20 id: lcmv] .

  ***EXPRESIONES
  sort TipoDato Expresion Operacion ExpresionFuncion ListaArgumentos OperacionBuilt ListaExpresiones TipoOpcion Opcion
       ListaOpciones Expresiones ExpresionMatch ListaArg ExpresionLet ExpresionAplicarF .
  --- ***Entero String Bool ExpresionBuilt Map ByStr32 ByStr20 BNum Option Lista Par Natural Expresion
  subsort Entero String BNum Option Lista Par Natural ExpresionFuncion Expresion ExpresionMatch MapVacio ExpresionAplicarF < TipoDato .
  --- --- subsort Expresion DeclaracionOpBools DeclaracionOpInts < Operacion .
  subsort Expresion Lista ExpresionFuncion ExpresionMatch Excepcion Par < Operacion .
  subsort TipoEntero NombreTipo Par < ListaArgumentos .
  subsort DeclaracionOp DeclaracionOpBools  < OperacionBuilt .
  subsort ExpresionLet ADTS < ListaExpresiones . 
 *** subsort Declaracion ExpresionMatch < Expresiones .
  subsort ListaDeclaraciones Entero Expresion < Expresiones .
  subsort Option Par Bool < TipoOpcion .
  subsort Opcion < ListaOpciones .
  subsort Qid < ListaArg .
  ***subsort Bubble < ExpresionAplicarF .

  op let__ : Qid TipoDato -> ExpresionLet [ctor prec 20]  .
  ***op let_=_ : Token Bubble -> ExpresionLet [ctor prec 20]  .
  op let__in_ : Qid TipoDato Operacion -> Expresion [ctor prec 20] .
  ***op let_ : Expresion -> Expresion [ctor prec 20] .
  ***op let_in_ : Expresion Operacion -> Expresion [ctor prec 20] .
  --- ***Falta añadir los mensajes
  op funcion__ : ParamInm Operacion -> ExpresionFuncion [ctor prec 20] .
  ***op __ : ListaArg ListaArg -> ListaArg [ctor assoc prec 19] .
  op `(_`) :  QidList -> ExpresionAplicarF [ctor prec 19] .
  ***op _=__ : Token Token NeTokenList -> Expresion [ctor prec 20] .
  --- --- op tfun'_=>_ : String Operacion -> Expresion [ctor] .
  ***op String : -> ListaArgumentos [ctor] .
  --- op __ : ListaArgumentos ListaArgumentos -> ListaArgumentos [ctor assoc prec 19] .
  --- op __ : Qid ListaArgumentos -> Expresion [ctor prec 20] .  

  --- --- op [_] : String -> Argumento [ctor] .
  --- --- op __ : ListaArgumentos ListaArgumentos -> ListaArgumentos [ctor] .
  --- --- ***op builtin__ : OperacionBuilt ListaArgumentos -> ExpresionBuilt [ctor] . ***No es exactamente string (hay que cambiarlo).
  op builtin_ : OperacionBuilt -> Expresion [ctor prec 19] .

  op ev : -> Expresiones [ctor] .
  op opcionMatch__ : TipoOpcion Expresiones -> Opcion [ctor prec 20] .  ***La segunda entrada no sería un string sino un statement.
  ***op _=>_ : Constructora Expresiones -> Opcion [ctor prec 20] .
  op opcionMatch__ : QidList Expresiones -> Opcion [ctor prec 20] .
  op opcionMatch__ : TipoOpcion QidList -> Opcion [ctor prec 20] .
  op ov : -> ListaOpciones [ctor] .
  op __ : ListaOpciones ListaOpciones -> ListaOpciones [ctor assoc prec 21] .
  op match__ : Qid ListaOpciones -> ExpresionMatch [ctor prec 21] .
  op lev : -> ListaExpresiones [ctor] .
  op __ : ListaExpresiones ListaExpresiones -> ListaExpresiones [ctor assoc prec 22 id: lev] .

  ***DECLARACIONES
  sort Declaracion Valor ListaDeclaraciones .
  ***Entero String DeclaracionFuncion EventoMsg ExpresionBuilt Option Lista Par Natural DeclaracionOpBools DeclaracionOpInts
  subsorts Entero String Option Lista Par Natural Evento Expresion Mensaje Bool DeclaracionOpBools ExpresionMatch ExpresionAplicarF < Valor .
  subsort Declaracion ExpresionMatch DeclaracionOpMapI Expresion Error ExpresionAplicarF < ListaDeclaraciones .
  ***subsort Expresiones DeclaracionOpMapI Expresion < ListaDeclaraciones .

  op guardar__ : Qid Qid  -> Declaracion [ctor prec 19] .
  op actualizar__ : Qid Qid -> Declaracion [ctor prec 19] .
  op _<-&BLOCKNUMBER : Qid -> Declaracion [ctor prec 19] .
  op _=_ : Qid Valor -> Declaracion [ctor prec 19] .
  ***op _=_ : Token Bubble -> Declaracion [ctor prec 19] .
  ***op __ : Token ListaArgumentos -> Declaracion [ctor] .
  op forall__ : Qid Qid -> Declaracion [ctor prec 19] .
  op accept : -> Declaracion [ctor] .
  op enviar_ : Qid -> Declaracion [ctor prec 19] .
  op evento_ : Qid -> Declaracion [ctor prec 19] .
  op ldv : -> ListaDeclaraciones [ctor] .
  op __ : ListaDeclaraciones ListaDeclaraciones -> ListaDeclaraciones [ctor assoc prec 20 id: ldv] .

  ***TRANSICIONES Y PROCEDIMIENTOS
  sort Transicion ListaTransiciones Procedimiento .
  subsort Transicion Procedimiento < ListaTransiciones .

  op procedimiento___end : Qid ListaParamInm ListaDeclaraciones -> Procedimiento [ctor prec 23] .
  op transicion___end : Qid ListaParamInm ListaDeclaraciones -> Transicion [ctor prec 23] .
  op ltv : -> ListaTransiciones [ctor] .
  op __ : ListaTransiciones ListaTransiciones -> ListaTransiciones [ctor assoc prec 24 id: ltv] .

  ***COMUNICACIONES
  sort NombreEvento ListaCamposEvento Evento CampoEvento TagMensaje EnvioMensaje CantidadMensaje Mensaje NombreExcepcion Excepcion .
  subsort ParamInm < ListaCamposEvento .
  ***Eventos
  op -eventname:_ : String -> NombreEvento [ctor prec 12] .
  ***op _:_ : Qid Qid -> CampoEvento [ctor prec 12] .
  ***op _:_ : Qid String -> CampoEvento [ctor prec 12] .
  op lcv : -> ListaCamposEvento [ctor] .
  op _;_ : ListaCamposEvento ListaCamposEvento -> ListaCamposEvento [ctor assoc prec 13] .
  op {_;_} : NombreEvento ListaCamposEvento -> Evento [ctor prec 14] .
  ***Mensajes
  op -tag:_ : String -> TagMensaje [ctor prec 12] .
  op dirEnvio_ : Qid -> EnvioMensaje [ctor prec 12] .
  op cantidadEnvio_ : Entero -> CantidadMensaje [ctor prec 12] .
  op cantidadEnvio_ : Qid -> CantidadMensaje [ctor prec 12] .
  ***op {_;_;_;_} : TagMensaje EnvioMensaje CantidadMensaje ListaCamposEvento -> Mensaje [ctor prec 14] .
  op contenidoMensaje____ : TagMensaje EnvioMensaje CantidadMensaje ListaCamposEvento -> Mensaje [ctor prec 14] .

  op -exception:_ : String -> NombreExcepcion [ctor prec 12] .
  op {_;_} : NombreExcepcion ListaCamposEvento -> Excepcion [ctor prec 14] .

  ***LIBRERIA BOOLUTILS
  sort DeclaracionOpBools .

  ops _and_ _or_ : Qid Qid -> DeclaracionOpBools [ctor prec 14] .
  ops negb_ bool-to-string_ : Qid -> DeclaracionOpBools [ctor prec 14] .
  ops _and.__ _or.__ : Qid Qid Qid -> DeclaracionOpBools [ctor prec 14] .
  ops negb.__ bool-to-string.__ : Qid Qid -> DeclaracionOpBools [ctor prec 14] .



  ***ADTS
  sort ADTS Constructora Constructoras .
  subsort Constructora < Constructoras .
  op |_ : Qid -> Constructora [ctor prec 15] .
  --- ops String ByStr32 ByStr20 BNum Bool : -> ListaArgumentos [ctor] .
  --- op __ : ListaArgumentos ListaArgumentos -> ListaArgumentos [ctor assoc] .
  --- op |_of_ : Qid ListaArgumentos -> Constructora [ctor] . 
  op __ : Constructoras Constructoras -> Constructoras [ctor assoc prec 16] .
  op tipo__ : Qid Constructoras -> ADTS [ctor prec 17] .

  ***ERRORES
  sort Error .
  op throw : -> Error [ctor] .
  op throw_ : Qid -> Error [ctor prec 19] .

  

  sort NombreLibreria NombreContrato Libreria LibImportar Importacion ListaImportar .
  subsort LibImportar < ListaImportar .

  op NombreLibreria_ : Qid -> NombreLibreria [ctor] .
  op NombreContrato_ : Qid -> NombreContrato [ctor] .
  ops BoolUtils IntUtils PairUtils ListUtils : -> LibImportar [ctor] .
  op iv : -> Importacion [ctor] .
  op __ : ListaImportar ListaImportar -> ListaImportar [ctor assoc] .
  op import_ : ListaImportar -> Importacion [ctor] .
  op import__ : LibImportar Qid -> Importacion [ctor] .

  op __ : NombreLibreria ListaExpresiones -> Libreria [ctor] .

 


 


  
  op Contrato_______ : Nat Importacion Libreria NombreContrato ListaParamInm ListaCamposMod ListaTransiciones -> Contrato [ctor] .


endfm

fmod MEMORIA is
  pr Programa .
  sort Memoria Variable Val Pareja PilaMemoria ParejaFuncion letIn AmbitoAplicacion memoriaTransicion Opciones ListaT memoriaLetIn . 
  subsort Qid < Variable .
  subsort DeclaracionOp Entero String PilaMemoria ExpresionFuncion ParamInm Expresion ParejaFuncion Option Evento < Val .
  subsort Pareja memoriaTransicion memoriaLetIn < Memoria .
  subsort Option < AmbitoAplicacion .
  ***subsort ListaDeclaraciones Pareja < ListaT .
  ***subsort ListaDeclaraciones Pareja < Opciones .
  
  ***op [_] : Val -> Pareja [ctor] .
  op [_] : Transicion -> Pareja [ctor] .
  op [_] : Declaracion -> Pareja [ctor] .
  op [_] : DeclaracionOp -> Pareja [ctor] .
  op [_] : Int -> Pareja [ctor] .
  op [_=>_,_] : Variable Val AmbitoAplicacion -> letIn [ctor] .
  op Funcion[_,_] : ParamInm Expresion -> ParejaFuncion [ctor] .
  op Funcion[_,_] : ParamInm memoriaLetIn -> ParejaFuncion [ctor] .
  
  op [_=>_] : Variable Val -> Pareja [ctor] .
  op [_=>_] : Variable Qid -> Pareja [ctor] .
  op [_=>_] : Variable ListaOpciones -> Pareja [ctor] .
  op [_=>_] : Variable Int -> Pareja [ctor] .
  op [_=>_,_] : Variable Evento Memoria -> Pareja [ctor] .
  op [_=>_,_] : Variable TipoDato Memoria -> Pareja [ctor] .
  op [_=>_,_] : Variable Int Memoria -> Pareja [ctor] .
  op [_,_,_,_] : Variable ListaParamInm ListaDeclaraciones Memoria -> memoriaTransicion [ctor] .
  op [_,_,_] : Variable TipoDato Operacion -> memoriaLetIn [ctor] .
  ***op [_,_,_] : Variable ListaParamInm ListaT -> memoriaTransicion [ctor] .
  op mv : -> Memoria [ctor] .
  op __ : Memoria Memoria -> Memoria [ctor assoc id: mv] .
 
  op pv : -> PilaMemoria [ctor] .
  op apila : Memoria PilaMemoria -> PilaMemoria [ctor] .

  var x x2 : Qid .
  var TD : TipoDato .
  var Op : Operacion .
  var E : Expresion .
  var OPB : OperacionBuilt .
  var TE : TipoEntero .
  var IN : Int .
  op almacenar : Expresion -> Memoria [ctor] .
  eq almacenar(builtin OPB) = [OPB] .
  eq almacenar(guardar x x2) = [x => x2] .
  eq almacenar(let x TE IN in Op) = [x => IN , almacenar(Op)] .
  eq almacenar(let x TD in Op) = [x => TD , almacenar(Op)] .

endfm

fmod SISTEMA is
  pr MEMORIA .
  sort Sistema .

  op [_,_,_] : Contrato Memoria Memoria -> Sistema [ctor] .
  op init : -> Sistema .
  eq init = [Contrato 0 iv NombreLibreria 'HelloWorld let 'one_msg funcion 'msg : Message let 'nil_msg Nil{Message} in
   Cons Message 'msg 'nil_msg let 'S1 Uint32 1 let 'S2 Uint32 2 NombreContrato 'HelloWorld ('owner : ByStr20) 
            campo 'welcome_msg : String = "" transicion ('getHello) (lpv) (guardar 'r  'welcome_msg   evento 'e 'e = {-eventname: "getHello" ; 'msg : 'r })
             end transicion 'setHello ('msg : String) 'is_owner = builtin 'owner == '_sender end  , mv, mv] .

  --- eq init = [let 'S1 Uint32 1 in let 'b Uint32 2 in builtin 'S1 + 'b , mv, mv] .

endfm 

mod REGLAS is 
  pr SISTEMA .

  var M M' M2 M3 M4 M5 : Memoria .
  var x x' x2 x3 : Qid .
  vars E E' : Entero .
  var C : Contrato .
  var N : Nat .
  var I : Importacion .
  var L : Libreria .
  var NC : NombreContrato .
  var LPI : ListaParamInm .
  var LCM : ListaCamposMod .
  var LT : ListaTransiciones .
  var NL : NombreLibreria .
  var LE : ListaExpresiones .
  var TP : TipoParamInm .
  var V : Val .
  var P : PilaMemoria .
  var LD : ListaDeclaraciones .
  var PI : ParamInm .
  var Op : Operacion .
  var TD : TipoDato .
  var T : Transicion .
  var VL : Valor .
  var LOP : ListaOpciones .
  var D : Declaracion .
  var OPB : OperacionBuilt .
  var TE : TipoEntero .
  var IN : Int .
  var S : String .
  var LCE : ListaCamposEvento .
  var EXP : Expresion .

  ***Regla para guardar una variable de un let en la memoria
  rl[Contrato N I NL let x V LE NC LPI LCM LT ,M, M'] => [Contrato N I NL LE NC LPI LCM LT ,M[x => V], M'] .
  ***Regla para quitar el tipo del entero de la memoria
  rl[C ,M [x => TE IN] M2, M'] => [C ,M [x => IN] M2, M'] .
  ***Regla para guardar un campo en la memoria
  rl[Contrato N I NL LE NC LPI campo x : TP = V LCM LT,M, M'] => [Contrato N I NL LE NC LPI LCM LT,M[x => V], M'] .
  rl[C , [x => funcion PI Op]M , M'] => [C , [x => Funcion[PI, Op]]M , M'] .
  ***rl[C , [x => Funcion[PI, let 'x TD in Op]]M , M'] => [C , [x => Funcion[PI, ['x, Op]]M , M'] .
  ***rl[C , [x => funcion PI let x TD in Op]M , M'] => [C , [x => Funcion[PI, let x TD in Op]]M , M'] .
  ***rl[C , [x => funcion PI let x TD in Op]M , M'] => [C , [x => Funcion[PI , [x => TD , Op]]]M , M'] .
  ***rl[C , [x => funcion PI Op]M , M'] => [C , [x => apila([PI] [Op],pv)]M , M'] .
  ***Regla para guardar una transicion en la memoria (en este caso se guarda la regla entera)
  rl[Contrato N I NL LE NC LPI LCM T LT ,M,M'] => [Contrato N I NL LE NC LPI LCM LT,M,M'[T]] .
  ***Regla para guardar una transicion en la memoria (se divide la transicion en [nombre, entradas, cuerpo])
  rl[C , M , M2 [transicion x LPI LD end] M'] => [C , M , M2[x, LPI, LD, mv]M'] .
 *** rl[C , M , M3[x, LPI, guardar x' x2 LD, M2]M'] => [C , M , M3[x, LPI, LD, M2[x' => x2] ]M'] .
  ***Regla para almacenar la declaracion guardar en la memoria
  rl[C , M , M3[x, LPI, D LD, M2]M'] => [C , M , M3[x, LPI, LD, M2 almacenar(D) ]M'] .
  ***Regla para almacenar la declaracion evento en la memoria
  rl[C , M , M3[x, LPI, evento x' LD, M2]M'] => [C , M , M3[x, LPI, LD, M2['evento => x'] ]M'] .
  ***Regla para quitar la expresion builtin y quedarte con la operacion real 
  rl[C , M , M3[x, LPI, LD, M2[x' => builtin OPB]M4]M'] => [C , M , M3[x, LPI, LD, M2[x' => OPB]M4 ]M'] .
  ***Regla para almacenar la declaracion = en la memoria
  ***rl[C , M , M3[x, LPI, x' = {-eventname: S ; LCE} LD, M2]M'] => [C , M , M3[x, LPI, x' = {-eventname: S ; LCE} LD, M2[x' => [-eventname: => S]] ]M'] .
 *** rl[C , M , M3[x, LPI, x' = {PI ; LCE} LD, M2]M'] => [C , M , M3[x, LPI, x' = {LCE} LD, M2[x' => [-eventname: => S]] ]M'] .
  rl[C , M , M3[x, LPI, x' = VL LD, M2]M'] => [C , M , M3[x, LPI, LD, M2[x' => VL] ]M'] .
  ***rl[C , M , M3[x, LPI, LD, M2[x' => {-eventname: S ; LCE}]M4]M'] => [C , M , M3[x, LPI, LD, M2[x' => {-eventname: S ; LCE}, ['-eventname: => S]]M4 ]M'] .
  ***rl[C , M , M3[x, LPI, LD, M2[x' => {-eventname: S ; x2 : x3 LCE}, M5]M4]M'] => [C , M , M3[x, LPI, LD, M2[x' => {-eventname: S ; LCE}, M5[x2 => x3]]M4 ]M'] .
  --- rl[C , M , M3[x, LPI, D LD, M2]M'] => [C , M , M3[x, LPI, LD, M2[D] ]M'] .
  --- rl[C , M , M3[x, LPI, LD, M2['x = VL]]M'] => [C , M , M3[x, LPI, LD, M2['x => VL]]M'] .
  ***rl[C , M , M3[x, LPI, LD, M2]M'] => [C , M , M3[x, LPI, LD, M2['evento => x'] ]M'] .

  ***Regla para almacenar la expresion match en la memoria ([comprobacion = > cuerpo])
  rl[C , M , M3[x, LPI, match x' LOP , M2]M'] => [C , M , M3[x, LPI, ldv, M2[x' => LOP] ]M'] .

  ***Regla para sustituir valores globales e las transiciones
  rl[C , M [x2 => V] M2 , M3[x, LPI, LD, M5[x' => x2]M4]M'] => [C , M [x2 => V] M2 , M3[x, LPI, LD, M5[x' => V]M4]M'] .
  --- rl[let x V LE ,M, M'] => [LE,M[x => V], M'] .


  --- rl[let x V LE ,M, M'] => [LE ,M[x => V], M'] .
  --- rl[LE ,M[x => TE IN]M2, M'] => [LE ,M[x => IN]M2, M'] .
  --- rl[EXP LD, M, M'] => [LD, almacenar(EXP), M'] .


endm

rew init .
--- search init =>* [cv , M:Memoria] .



fmod META-SIGN is
 including GRAMMAR .
 pr META-LEVEL .

 op BUBBLES : -> FModule .
 op GRAMMAR : -> FModule [memo] .

 eq BUBBLES
    = (fmod 'GRAMMAR is
        including 'QID-LIST .
        sorts none .
        none
        op 'token : 'Qid -> '@Token@
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '<-&BLOCKNUMBER)))] .
        op 'bubble : 'QidList -> '@Bubble@
             [special(
               (id-hook('Bubble, '1 '-1)
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, 'eq 'ceq 'rl 'crl 'mb 'cmb 'sd 'csd
                                  'var 'vars 'forall 'exists
                                  'sorts 'subsort 'subsorts 'op 'ops
                                  'protecting 'pr 'including 'inc 'extending 
                                  'ctor 'assoc 'comm '== '/\ 'spec* 'spec! 'builtin '`{ '`} 'let 'Pair '`( '`) 'Some
                                  '; 'andb 'true 'BoolU 'Uint32 'Uint128 'Uint256 'Nil 'throw 'Emp 'field 'false
                                  'ev '= '| 'Unit 'orb ':= 'None 'fun 'Int32 'Int128 'match 'String 'ByStr32 'ByStr33 'ByStr20 
                                  'BNum 'Bool 'Message 'Error 'ByStr 'ByStr64 'Unit '<- 'event '@ 'send 'schnorr-verify 'ecdsa-verify
                                  'add '<-exists 'lt 'contains 'delete 'put ' 'negb 'blt 'get 'remove 'badd 'accept 'sub)))] .
        op 'neTokenList : 'QidList -> '@NeTokenList@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '. ': '`[ 'forall 'exists)))] .
        none
        none
     endfm) .
 eq GRAMMAR = addImports(BUBBLES, (including 'GRAMMAR .)) .

 var  SSDS : SubsortDeclSet .
 vars IL IL' : ImportList .
 var  EqS : EquationSet .
 var  ODS : OpDeclSet .
 var  MAS : MembAxSet .
 var  RS : RuleSet .
 var  M : Module .
 var  SS : SortSet .
 var  H : Header .

 op setImports : Module ImportList -> Module .
 eq setImports(fmod H is IL sorts SS . SSDS ODS MAS EqS endfm, IL')
    = fmod H is IL' sorts SS . SSDS ODS MAS EqS endfm .
 eq setImports(mod H is IL sorts SS . SSDS ODS MAS EqS RS endm, IL')
    = mod H is IL' sorts SS . SSDS ODS MAS EqS RS endm .
 eq setImports(fth H is IL sorts SS . SSDS ODS MAS EqS endfth, IL')
    = fth H is IL' sorts SS . SSDS ODS MAS EqS endfth .
 eq setImports(th H is IL sorts SS . SSDS ODS MAS EqS RS endth, IL')
    = th H is IL' sorts SS . SSDS ODS MAS EqS RS endth .

 op addImports : Module ImportList -> Module .
 eq addImports(M, IL) = setImports(M, (getImports(M) IL)) .
endfm