load preparse.maude
load Gramatica_def.maude
load file.maude

fmod PARSING is
 pr META-LEVEL .
 pr CONVERSION .
 pr PREPARSE .
 pr datos_primitivos .

---  sort ParsingRes .
---  op <_> : Term -> ParsingRes [ctor] .

 vars T T1 T1' T2 T2' T3 T3' T4 T4' T5 T5' T6 T6' T7 T7' : Term .
 var  TL : TermList .
 var  Ct : Constant .
 var  S : String .
 var  F : Float .
 var  Q : Qid .
 var  I : Int .

 op parse : Term -> Term .
 ***eq parse(T) = parse(upModule('campos_modificables, true), T) .
 ***eq parse(T) = parse(T) .

 ***op parse : Term -> ParsingRes .
 ceq parse('scilla-version_______[T1, T2, T3, T4, T5, T6, T7]) = 'Contrato_______[T1', T2', T3', T4', T5', T6', T7']
  if T1' := parse(T1) /\
     T2' := parse(T2) /\
     T3' := parse(T3) /\
     T4' := parse(T4) /\
     T5' := parse(T5) /\
     T6' := parse(T6) /\
     T7' := parse(T7)  .
--- ceq parse('scilla-version__[T1, T2]) = 'Contrato__[T1', T2']
---   if T1' := parse(T1) /\ 
---      T2' := parse(T2).
 ceq parse('token[T]) = upTerm(F)
  if Q := downQid(T) /\
     S := string(Q) /\
     F := float(S) .
 ceq parse('token[T]) = upTerm(F)
  if Q := downQid(T) /\
     S := string(Q) /\
     rat(S, 10) :: Nat /\
     F := float(S + ".0") .
 ceq parse('token[T]) = T
  if Q := downQid(T) /\
     S := string(Q) /\
     not (float(S) :: Float) /\
     not (rat(S, 10) :: Nat) .
 ceq parse('_=_;[T1, T2]) = '_=_;[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('_+_[T1, T2]) = '_+._[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ***ENTEROS
 ceq parse('eq__[T1, T2]) = '_==_[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('add__[T1, T2]) = '_+_[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('sub__[T1, T2]) = '_-_[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('mul__[T1, T2]) = '_*_[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('div__[T1, T2]) = '_/_[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('rem__[T1, T2]) = '_rem_[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('lt__[T1, T2]) = '_<_[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('pow__[T1, T2]) = '_^_[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('isqrt_[T1]) = 'raiz_[T1']
  if T1' := parse(T1) .
 ceq parse('to-nat_[T1]) = 'to-nat_[T1']
  if T1' := parse(T1) .

 ***STRINGS
 ceq parse('concat__[T1, T2]) = '_++_[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('substr___[T1, T2, T3]) = 'substr___[T1', T2', T3']
  if T1' := parse(T1) /\
     T2' := parse(T2) /\
     T3' := parse(T3) .
 ceq parse('to-string_[T1]) = 'to-string_[T1']
  if T1' := parse(T1) .
 ceq parse('strlen_[T1]) = 'length_[T1']
  if T1' := parse(T1) .

 ***MAPS
 ceq parse('put___[T1, T2, T3]) = 'put___[T1', T2', T3']
  if T1' := parse(T1) /\
     T2' := parse(T2) /\
     T3' := parse(T3) .
 ceq parse('_`[_`]:=_[T1, T2, T3]) = 'insertar___[T1', T2', T3']
  if T1' := parse(T1) /\
     T2' := parse(T2) /\
     T3' := parse(T3) .
ceq parse('_<-_`[_`][T1, T2, T3]) = 'obtener___[T1', T2', T3']
  if T1' := parse(T1) /\
     T2' := parse(T2) /\
     T3' := parse(T3) .
 ceq parse('get__[T1, T2]) = 'get__[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('contains__[T1, T2]) = 'contains__[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('remove__[T1, T2]) = 'remove__[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('delete_`[_`][T1, T2]) = 'delete__[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .

 ***BNUM
 ceq parse('blt__[T1, T2]) = '_<_[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('badd__[T1, T2]) = '_+_[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('bsub__[T1, T2]) = '_-_[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .

 ***DATOS ALGEBRAICOS
 ***Option
 ceq parse('Some`{_`}_[T1, T2]) = 'Some__[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('Some_[T1]) = 'Some_[T1']
  if T1' := parse(T1) .
 ***Listas
 ceq parse('Cons`{_`}__[T1, T2, T3]) = 'Cons___[T1', T2', T3']
  if T1' := parse(T1) /\
     T2' := parse(T2) /\
     T3' := parse(T3) .
 ***Pares
 ceq parse('Pair`{__`}__[T1, T2, T3, T4]) = 'Pair____[T1', T2', T3', T4']
  if T1' := parse(T1) /\
     T2' := parse(T2) /\
     T3' := parse(T3) /\ 
     T4' := parse(T4) .
 ***Naturales
 ceq parse('Succ_[T1]) = 'Sucesor_[T1']
  if T1' := parse(T1) .

 ***PARÁMETROS INMUTABLES
 ceq parse('_:_[T1, T2]) = '_:_[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
---  ceq parse(M, '_`,_[T1, T2]) = M2, 'ListaParamInm__[T1', T2']
---   if M1, T1' := parse(M, T1) /\
---      M2, T2' := parse(M1, T2) .
 eq parse('_`,_[TL]) = 'LParamInm__[parseL(TL)]  .

 ***CAMPOS MODIFICABLES
 ceq parse('field_=_[T1, T2]) = 'campo__[T1', T2'] 
  if T1'  := parse(T1) /\
     T2'  := parse(T2) .
 eq parse('__[TL]) = 'ListaCamposMod__[parseL(TL)] .

 ***EXPRESIONES
 ceq parse('let_=_[T1, T2]) = 'let__[T1', T2'] 
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('let_=_in_[T1, T2, T3]) = 'let__in_[T1', T2', T3']
  if T1' := parse(T1) /\
     T2' := parse(T2) /\
     T3' := parse(T3) .
 ceq parse('fun`(_`)=>_[T1, T2]) = 'funcion__[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('_=__[T1, T2, T3]) = 'aplicarFuncion___[T1', T2', T3']
  if T1' := parse(T1) /\
     T2' := parse(T2) /\
     T3' := parse(T3) .
---  ceq parse(M, '__[T1, T2]) = M2, 'Funcion__[T1', T2']
---   if M1, T1' := parse(M, T1) /\
---      M2, T2' := parse(M1, T2) .
 ceq parse('@__[T1, T2]) = '@__[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('builtin_[T1]) = 'builtin_[T1']
  if T1' := parse(T1) .
 ceq parse('|_=>_[T1, T2]) = 'opcionMatch__[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('match_with_end[T1, T2]) = 'match__[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .

 ***DECLARACIONES
 ceq parse('_<-_[T1, T2]) = 'guardar__[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('_:=_[T1, T2]) = 'actualizar__[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('_<-&BLOCKNUMBER[T1]) = '_<-&BLOCKNUMBER[T1']
  if T1' := parse(T1) .
 ceq parse('_=_[T1, T2]) = '_=_[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('forall__[T1, T2]) = 'forall__[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('send_[T1]) = 'enviar_[T1']
  if T1' := parse(T1) .
 ceq parse('event_[T1]) = 'evento_[T1']
  if T1' := parse(T1) .
 eq parse('_;_[TL]) = 'ListaDec__[parseL(TL)] .

 ***COMUNICACIONES 
 ceq parse('`{_;_`}[T1, T2]) = 'contenidoEvento__[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('-recipient:_[T1]) = 'dirEnvio_[T1']
  if T1' := parse(T1) .
 ceq parse('`{_;_;_;_`}[T1, T2, T3, T4]) = 'contenidoMensaje___[T1', T2', T3', T4']
  if T1' := parse(T1) /\
     T2' := parse(T2) /\
     T3' := parse(T3) /\
     T4' := parse(T4) .

 ***TRANSICIONES Y PROCEDIMIENTOS
 ceq parse('procedure_`(_`)_end[T1, T2, T3]) = 'procedimiento___[T1', T2', T3']
  if T1' := parse(T1) /\
     T2' := parse(T2) /\
     T3' := parse(T3) .
 ceq parse('transition_`(_`)_end[T1, T2, T3]) = 'transicion___[T1', T2', T3']
  if T1' := parse(T1) /\
     T2' := parse(T2) /\
     T3' := parse(T3) .

***BOOLUTILS
 ceq parse('andb__[T1, T2]) = '_and_[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('_.andb__[T1, T2, T3]) = '_and.__[T1', T2', T3']
  if T1' := parse(T1) /\
     T2' := parse(T2) /\
     T3' := parse(T3) .
 ceq parse('orb__[T1, T2]) = '_or_[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('_.orb__[T1, T2, T3]) = '_or.__[T1', T2', T3']
  if T1' := parse(T1) /\
     T2' := parse(T2) /\
     T3' := parse(T3) .
 ceq parse('negb_[T1]) = 'negb_[T1']
  if T1' := parse(T1) .
 ceq parse('_.negb_[T1, T2]) = 'negb.__[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .
 ceq parse('bool-to-string_[T1]) = 'bool-to-string_[T1']
  if T1' := parse(T1) .
ceq parse('_.bool-to-string_[T1, T2]) = 'bool-to-string.__[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .

 ceq parse('library_[T1]) = 'NombreLibreria_[T1']
  if T1' := parse(T1) .
 ceq parse('contract_[T1]) = 'NombreContrato_[T1']
  if T1' := parse(T1) .
 ceq parse('import_as_[T1, T2]) = 'import__[T1', T2']
  if T1' := parse(T1) /\
     T2' := parse(T2) .




 *** TODO: terminar

 eq parse(T) = T [owise] .

 op parseL : TermList -> TermList .
 eq parseL(empty) = empty .
 eq parseL((T, TL)) = parse(T), parseL(TL) .

 op downQid : Term -> [Qid] [memo] .
 eq downQid(Ct)
    = qid(substr(string(getName(Ct)), 1, length(string(getName(Ct))))) .

endfm

mod MTP is
 inc STD-STREAM .
 pr  CONVERSION .
 pr META-SIGN .
 pr  LEXICAL .
 pr PARSING .
 inc FILE .

 vars Text Original Read Source : String .
 var  Attrs : AttributeSet .
 vars FHIn FHOut : Oid .
 var  QIL : QidList .
 vars T T' : Term .
 var  M : Module .
 vars N N' : Nat .
 var  Ty : Type .
 var  Q : Qid .

 *** Object and class definition
 op EXAMPLE : -> Cid [ctor] .
 op example : -> Oid [ctor] .

 op noFile : -> Oid [ctor] .

 *** Attributes
 op file:_ : Oid -> Attribute [ctor] .
 op read:_ : String -> Attribute [ctor] .
 op state:_ : State -> Attribute [ctor] .
 op terms:_ : TermList -> Attribute [ctor gather (&)] .

 sort State .
 ops idle reading parsing : -> State [ctor] .

 *** Run command
 op run : -> Configuration [ctor] .

 ***                        ***
 ***          LOAD          ***
 ***                        ***

 crl [loadComm] :
    gotLine(example, stdin, Text)
    < example : EXAMPLE | Attrs >
 => < example : EXAMPLE | Attrs >
    openFile(fileManager, example, Source, "r")
  if Q := tokenize(Text) /\
     Source := printTokens(Q) .

 crl [loadCommERROR] :
    gotLine(example, stdin, Text)
    < example : EXAMPLE | Attrs >
 => < example : EXAMPLE | Attrs >
    write(stdout, example, "File name incorrect.\n")
  if Q QIL := tokenize(Text) /\
     QIL =/= nil .

 rl [openedFile] :
    openedFile(example, fileManager, FHIn)
    < example : EXAMPLE | file: noFile, state: idle, Attrs >
 => < example : EXAMPLE | file: FHIn, state: reading, Attrs >
    getLine(FHIn, example) .

 rl [openFileError] :
    fileError(example, fileManager, Text)
    < example : EXAMPLE | Attrs >
 => < example : EXAMPLE | Attrs >
    write(stdout, example, Text + "\n") .

 ***                           ***
 ***          GotLine          ***
 ***                           ***


rl [newLine] :
   gotLine(example, FHIn, Text)
   < example : EXAMPLE | file: FHIn, read: Read, state: reading, Attrs >
=> if Text == ""
   then < example : EXAMPLE | file: FHIn, read: Read, state: parsing, Attrs > 
        closeFile(FHIn, example)
   else < example : EXAMPLE | file: FHIn, read: (Read + preparse(Text)), state: reading, Attrs >
        getLine(FHIn, example)
   fi .

crl [parsing] :
    < example : EXAMPLE | read: Read, state: parsing, Attrs >
 => < example : EXAMPLE | read: "", Attrs >
    write(stdout, example, "Parsed.\n")
 if Read =/= "" /\
    QIL := tokenize(Read) /\
    {T, Ty} := metaParse(GRAMMAR, QIL, anyType) /\
    T' := parse(T) [print T "\nParseado: " T'] .

 ***                              ***
 ***          closedFile          ***
 ***                              ***

 rl [closedFile] :
    closedFile(example, FHIn)
    < example : EXAMPLE | file: FHIn, Attrs >
 => < example : EXAMPLE | file: noFile, Attrs > .

 ***                          ***
 ***          WROTE           ***
 ***                          ***

 rl [wrote] :
    wrote(example, stdout)
    < example : EXAMPLE | file: noFile, Attrs >
 => < example : EXAMPLE | file: noFile, Attrs > .

 ***                        ***
 ***          RUN           ***
 ***                        ***

 eq run =
    <> < example : EXAMPLE | file: noFile, read: "", state: idle, terms: empty >
    getLine(stdin, example, "Introduce file name> ") .
endm



red metaParse(GRAMMAR, tokenize("If xxw\nThen 4 = 4 + w ;\nElse z = 4.5 ;\nFi"), anyType) .
red metaParse(GRAMMAR, tokenize("scilla-version 0 (a : String , b : BNum , c : Uint32) cv | None => @ a Uint32 | None => @ a Uint32"), anyType) .
red metaParse(GRAMMAR, tokenize("type Unit = | Unit let zero = Uint128 0"), anyType) .
red metaParse(GRAMMAR, tokenize("a = builtin eq a a ; match a with | true => e = {-eventname: \"setHello\" ; code : not_owner_code} ; event e end"), anyType) .
red metaParse(GRAMMAR, tokenize("let a = fun (msg : Message) => let nil_msg = Nil {Message} in Cons {Message} msg nil_msg let code_success = Uint32 0"), anyType) .
red metaParse(GRAMMAR, tokenize("transition addMember (name : String , addr : ByStr20 , memberType : Uint32) match is_authorized with | true => valid_type = let three = Uint32 3 in builtin lt memberType three ; match valid_type with | true => p = Pair {(String) (Uint32)} name memberType ; members[addr] := p ; msg = {-tag: \"\" ; -recipient: _sender ; -amount: Uint128 0 ; code : code_success} ; msgs = one_msg msg ; send msgs  | false =>  send msgs end end end"), anyType) .
red metaParse(GRAMMAR, tokenize("transition setHello (msg : String) is_owner = builtin eq owner _sender ; match is_owner with | false => e = {-eventname: \"setHello\" ; code : not_owner_code} , event e | true => welcome_msg := msg , e = {-eventname: \"setHello\" ; code : set_hello_code} , event e end end"), anyType) .
red metaParse(GRAMMAR, tokenize("is_authorized = builtin eq _sender owner "), anyType) .
red metaParse(GRAMMAR, tokenize("match is_owner with | false => e = {-eventname: \"setHello\" ; code : not_owner_code} ; event e | true => welcome_msg := msg ; e = {-eventname: \"setHello\" ; code : set_hello_code} ; event e end"), anyType) .
red metaParse(GRAMMAR, tokenize("field welcome_msg : String = \"\""), anyType) .
red metaParse(GRAMMAR, tokenize("fun (some_val : Option Uint128) => match some_val with | Some val => val | None => zero end"), anyType) .
red metaParse(GRAMMAR, tokenize("match result with | CodeIsSender => (Int32 -1) end"), anyType) .
red metaParse(GRAMMAR, tokenize("after_end = (let one = Uint128 1 in builtin badd endtime one)"), anyType) .

set print attribute on .

erew run .