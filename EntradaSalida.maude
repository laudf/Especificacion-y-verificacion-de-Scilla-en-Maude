load Gramatica_def.maude
load file.maude

fmod PARSING is
 pr META-LEVEL .
 pr CONVERSION .

 sort ParsingRes .
 op <_,_> : Module Term -> ParsingRes [ctor] .

 vars T T1 T1' T2 T2' T3 T3' T4 T4' T5 T5' : Term .
 vars M M1 M2 M3 M4 M5 : Module .
 var  Ct : Constant .
 var  S : String .
 var  F : Float .
 var  Q : Qid .
 var  I : Int .

 op parse : Term -> ParsingRes .
 eq parse(T) = parse(upModule('campos_modificables, true), T) .

 op parse : Module Term -> ParsingRes .
 ceq parse(M, 'scilla-version____[T1, T2, T3, T4]) = < M4, 'Contrato____[T1', T2', T3', T4'] >
  if < M1, T1' > := parse(M, T1) /\
     < M2, T2' > := parse(M1, T2) /\
     < M3, T3' > := parse(M2, T3) /\
     < M4, T4' > := parse(M3, T4) . *** /\
     ***< M5, T5' > := parse(M4, T5) .
--- ceq parse(M, 'scilla-version__[T1, T2]) = < M2, 'Contrato__[T1', T2'] >
---   if < M1, T1' > := parse(M, T1) /\ 
---      < M2, T2' > := parse(M1, T2).
 ceq parse(M, 'token[T]) = < M, upTerm(F) >
  if Q := downQid(T) /\
     S := string(Q) /\
     F := float(S) .
 ceq parse(M, 'token[T]) = < M, upTerm(F) >
  if Q := downQid(T) /\
     S := string(Q) /\
     rat(S, 10) :: Nat /\
     F := float(S + ".0") .
 ceq parse(M, 'token[T]) = < M, T >
  if Q := downQid(T) /\
     S := string(Q) /\
     not (float(S) :: Float) /\
     not (rat(S, 10) :: Nat) .
 ceq parse(M, '_=_;[T1, T2]) = < M2, '_=_;[T1', T2'] >
  if < M1, T1' > := parse(M, T1) /\
     < M2, T2' > := parse(M1, T2) .
 ceq parse(M, '_+_[T1, T2]) = < M2, '_+._[T1', T2'] >
  if < M1, T1' > := parse(M, T1) /\
     < M2, T2' > := parse(M1, T2) .
 ***ENTEROS
 ceq parse(M, 'eq__[T1, T2]) = < M2, '_==_[T1', T2'] >
  if < M1, T1' > := parse(M, T1) /\
     < M2, T2' > := parse(M1, T2) .
 ceq parse(M, 'add__[T1, T2]) = < M2, '_+_[T1', T2'] >
  if < M1, T1' > := parse(M, T1) /\
     < M2, T2' > := parse(M1, T2) .
 ceq parse(M, 'sub__[T1, T2]) = < M2, '_-_[T1', T2'] >
  if < M1, T1' > := parse(M, T1) /\
     < M2, T2' > := parse(M1, T2) .
 ceq parse(M, 'mul__[T1, T2]) = < M2, '_*_[T1', T2'] >
  if < M1, T1' > := parse(M, T1) /\
     < M2, T2' > := parse(M1, T2) .
 ceq parse(M, 'div__[T1, T2]) = < M2, '_/_[T1', T2'] >
  if < M1, T1' > := parse(M, T1) /\
     < M2, T2' > := parse(M1, T2) .
 ceq parse(M, 'rem__[T1, T2]) = < M2, '_rem_[T1', T2'] >
  if < M1, T1' > := parse(M, T1) /\
     < M2, T2' > := parse(M1, T2) .
 ceq parse(M, 'lt__[T1, T2]) = < M2, '_<_[T1', T2'] >
  if < M1, T1' > := parse(M, T1) /\
     < M2, T2' > := parse(M1, T2) .
 ceq parse(M, 'pow__[T1, T2]) = < M2, '_^_[T1', T2'] >
  if < M1, T1' > := parse(M, T1) /\
     < M2, T2' > := parse(M1, T2) .
 ceq parse(M, 'isqrt_[T1]) = < M1, 'raiz_[T1'] >
  if < M1, T1' > := parse(M, T1) .
 ceq parse(M, 'to-nat_[T1]) = < M1, 'to-nat_[T1'] >
  if < M1, T1' > := parse(M, T1) .

 ***STRINGS
 ceq parse(M, 'concat__[T1, T2]) = < M2, '_++_[T1', T2'] >
  if < M1, T1' > := parse(M, T1) /\
     < M2, T2' > := parse(M1, T2) .
 ceq parse(M, 'substr___[T1, T2, T3]) = < M3, 'substr___[T1', T2', T3'] >
  if < M1, T1' > := parse(M, T1) /\
     < M2, T2' > := parse(M1, T2) /\
     < M3, T3' > := parse(M2, T3) .
 ceq parse(M, 'to-string_[T1]) = < M1, 'to-string_[T1'] >
  if < M1, T1' > := parse(M, T1) .
 ceq parse(M, 'strlen_[T1]) = < M1, 'length_[T1'] >
  if < M1, T1' > := parse(M, T1) .

 ***BNUM
 ceq parse(M, 'blt__[T1, T2]) = < M2, '_<_[T1', T2'] >
  if < M1, T1' > := parse(M, T1) /\
     < M2, T2' > := parse(M1, T2) .
 ceq parse(M, 'badd__[T1, T2]) = < M2, '_+_[T1', T2'] >
  if < M1, T1' > := parse(M, T1) /\
     < M2, T2' > := parse(M1, T2) .
 ceq parse(M, 'bsub__[T1, T2]) = < M2, '_-_[T1', T2'] >
  if < M1, T1' > := parse(M, T1) /\
     < M2, T2' > := parse(M1, T2) .

 ***DATOS ALGEBRAICOS
 ***Option
 ceq parse(M, 'Some__[T1, T2]) = < M2, 'Some__[T1', T2'] >
  if < M1, T1' > := parse(M, T1) /\
     < M2, T2' > := parse(M1, T2) .
 ceq parse(M, 'Some_[T1]) = < M1, 'Some_[T1'] >
  if < M1, T1' > := parse(M, T1) .
 ***Listas
 ceq parse(M, 'Cons___[T1, T2, T3]) = < M3, 'Cons___[T1', T2', T3'] >
  if < M1, T1' > := parse(M, T1) /\
     < M2, T2' > := parse(M1, T2) /\
     < M3, T3' > := parse(M2, T3) .
 ***Pares
 ceq parse(M, 'Pair____[T1, T2, T3, T4]) = < M4, 'Pair____[T1', T2', T3', T4'] >
  if < M1, T1' > := parse(M, T1) /\
     < M2, T2' > := parse(M1, T2) /\
     < M3, T3' > := parse(M2, T3) /\ 
     < M4, T4' > := parse(M3, T4) .
 ***Naturales
 ceq parse(M, 'Succ_[T1]) = < M1, 'Sucesor_[T1'] >
  if < M1, T1' > := parse(M, T1) .

 ***PAR√ÅMETROS INMUTABLES
 ceq parse(M, '_:_[T1, T2]) = < M2, '_:_[T1', T2'] >
  if < M1, T1' > := parse(M, T1) /\
     < M2, T2' > := parse(M1, T2) .
 ceq parse(M, '_`,_[T1, T2]) = < M2, 'ListaParamInm__[T1', T2'] >
  if < M1, T1' > := parse(M, T1) /\
     < M2, T2' > := parse(M1, T2) .

 ***CAMPOS MODIFICABLES
 ceq parse(M, 'field_=_[T1, T2]) = < M2, 'campo__[T1', T2'] >
  if < M1, T1' > := parse(M, T1) /\
     < M2, T2' > := parse(M1, T2) .
 ceq parse(M, '__[T1, T2]) = < M2, 'ListaCamposMod__[T1', T2'] >
  if < M1, T1' > := parse(M, T1) /\
     < M2, T2' > := parse(M1, T2) .

 ***EXPRESIONES
 ceq parse(M, 'let_=_[T1, T2]) = < M2, 'let__[T1', T2'] >
  if < M1, T1' > := parse(M, T1) /\
     < M2, T2' > := parse(M1, T2) .
 ceq parse(M, 'let_=_in_[T1, T2, T3]) = < M3, 'let__in_[T1', T2', T3'] >
  if < M1, T1' > := parse(M, T1) /\
     < M2, T2' > := parse(M1, T2) /\
     < M3, T3' > := parse(M2, T3) .
---  ceq parse(M, '__[T1, T2]) = < M2, 'lista__[T1', T2'] >
---   if < M1, T1' > := parse(M, T1) /\
---      < M2, T2' > := parse(M1, T2) .
---  ceq parse(M, '__[T1, T2]) = < M2, 'Funcion__[T1', T2'] >
---   if < M1, T1' > := parse(M, T1) /\
---      < M2, T2' > := parse(M1, T2) .
 ceq parse(M, '@__[T1, T2]) = < M2, '@__[T1', T2'] >
  if < M1, T1' > := parse(M, T1) /\
     < M2, T2' > := parse(M1, T2) .

 ***DECLARACIONES
 ceq parse(M, '_<-_[T1, T2]) = < M2, 'guardar__[T1', T2'] >
  if < M1, T1' > := parse(M, T1) /\
     < M2, T2' > := parse(M1, T2) .
 ceq parse(M, '_:=_[T1, T2]) = < M2, 'actualizar__[T1', T2'] >
  if < M1, T1' > := parse(M, T1) /\
     < M2, T2' > := parse(M1, T2) .
 ceq parse(M, '_<-&BLOCKNUMBER[T1]) = < M1, '_<-&BLOCKNUMBER[T1'] >
  if < M1, T1' > := parse(M, T1) .
 ceq parse(M, '_=_[T1, T2]) = < M2, '_=_[T1', T2'] >
  if < M1, T1' > := parse(M, T1) /\
     < M2, T2' > := parse(M1, T2) .
 ceq parse(M, 'forall__[T1, T2]) = < M2, 'forall__[T1', T2'] >
  if < M1, T1' > := parse(M, T1) /\
     < M2, T2' > := parse(M1, T2) .
 ceq parse(M, 'send_[T1]) = < M1, 'enviar_[T1'] >
  if < M1, T1' > := parse(M, T1) .
 ceq parse(M, 'event_[T1]) = < M1, 'evento_[T1'] >
  if < M1, T1' > := parse(M, T1) .
 ceq parse(M, '_;_[T1, T2]) = < M2, 'ListaDec__[T1', T2'] >
  if < M1, T1' > := parse(M, T1) /\
     < M2, T2' > := parse(M1, T2) .

 ***TRANSICIONES
 ceq parse(M, 'transition_`(_`)_end[T1, T2, T3]) = < M3, 'transicion___[T1', T2', T3'] >
  if < M1, T1' > := parse(M, T1) /\
     < M2, T2' > := parse(M1, T2) /\
     < M3, T3' > := parse(M2, T3) .




 *** TODO: terminar
 eq parse(M, T) = < M, T > [owise] .

 op downQid : Term -> [Qid] [memo] .
 eq downQid(Ct)
    = qid(substr(string(getName(Ct)), 1, length(string(getName(Ct))))) .
endfm

mod MTP is
 inc STD-STREAM .
 pr  CONVERSION .
 pr META-SIGN .
 pr  LEXICAL .
 pr PARSING .
 inc FILE .

 vars Text Original Read Source : String .
 var  Attrs : AttributeSet .
 vars FHIn FHOut : Oid .
 var  QIL : QidList .
 vars T T' : Term .
 var  M : Module .
 vars N N' : Nat .
 var  Ty : Type .
 var  Q : Qid .

 *** Object and class definition
 op EXAMPLE : -> Cid [ctor] .
 op example : -> Oid [ctor] .

 op noFile : -> Oid [ctor] .

 *** Attributes
 op file:_ : Oid -> Attribute [ctor] .
 op read:_ : String -> Attribute [ctor] .
 op state:_ : State -> Attribute [ctor] .
 op terms:_ : TermList -> Attribute [ctor gather (&)] .

 sort State .
 ops idle reading parsing : -> State [ctor] .

 *** Run command
 op run : -> Configuration [ctor] .

 ***                        ***
 ***          LOAD          ***
 ***                        ***

 crl [loadComm] :
    gotLine(example, stdin, Text)
    < example : EXAMPLE | Attrs >
 => < example : EXAMPLE | Attrs >
    openFile(fileManager, example, Source, "r")
  if Q := tokenize(Text) /\
     Source := printTokens(Q) .

 crl [loadCommERROR] :
    gotLine(example, stdin, Text)
    < example : EXAMPLE | Attrs >
 => < example : EXAMPLE | Attrs >
    write(stdout, example, "File name incorrect.\n")
  if Q QIL := tokenize(Text) /\
     QIL =/= nil .

 rl [openedFile] :
    openedFile(example, fileManager, FHIn)
    < example : EXAMPLE | file: noFile, state: idle, Attrs >
 => < example : EXAMPLE | file: FHIn, state: reading, Attrs >
    getLine(FHIn, example) .

 rl [openFileError] :
    fileError(example, fileManager, Text)
    < example : EXAMPLE | Attrs >
 => < example : EXAMPLE | Attrs >
    write(stdout, example, Text + "\n") .

 ***                           ***
 ***          GotLine          ***
 ***                           ***


rl [newLine] :
   gotLine(example, FHIn, Text)
   < example : EXAMPLE | file: FHIn, read: Read, state: reading, Attrs >
=> if Text == ""
   then < example : EXAMPLE | file: FHIn, read: Read, state: parsing, Attrs >
        closeFile(FHIn, example)
   else < example : EXAMPLE | file: FHIn, read: (Read + Text), state: reading, Attrs >
        getLine(FHIn, example)
   fi .

crl [parsing] :
    < example : EXAMPLE | read: Read, state: parsing, Attrs >
 => < example : EXAMPLE | read: "", Attrs >
    write(stdout, example, "Parsed.\n")
 if Read =/= "" /\
    QIL := tokenize(Read) /\
    {T, Ty} := metaParse(GRAMMAR, QIL, anyType) /\
    < M, T' > := parse(T) [print T "\nParseado: " T'] .

 ***                              ***
 ***          closedFile          ***
 ***                              ***

 rl [closedFile] :
    closedFile(example, FHIn)
    < example : EXAMPLE | file: FHIn, Attrs >
 => < example : EXAMPLE | file: noFile, Attrs > .

 ***                          ***
 ***          WROTE           ***
 ***                          ***

 rl [wrote] :
    wrote(example, stdout)
    < example : EXAMPLE | file: noFile, Attrs >
 => < example : EXAMPLE | file: noFile, Attrs > .

 ***                        ***
 ***          RUN           ***
 ***                        ***

 eq run =
    <> < example : EXAMPLE | file: noFile, read: "", state: idle, terms: empty >
    getLine(stdin, example, "Introduce file name> ") .
endm



red metaParse(GRAMMAR, tokenize("If xxw\nThen 4 = 4 + w ;\nElse z = 4.5 ;\nFi"), anyType) .
red metaParse(GRAMMAR, tokenize("scilla-version 0 (a : String , b : BNum , c : Uint32) cv | None => @ a Uint32 | None => @ a Uint32"), anyType) .

set print attribute on .

erew run .